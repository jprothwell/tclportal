/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * wgui_categories.c
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   Ordinary categories.
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/**
 * Copyright Notice
 * (c) 2002 - 2003, Pixtel Communications, Inc., 1489 43rd Ave. W.,
 * Vancouver, B.C. V6M 4K8 Canada. All Rights Reserved.
 *  (It is illegal to remove this copyright notice from this software or any
 *  portion of it)
 */

/**********************************************************************************
   Filename:      wgui_categories.c
   Author:        manju, Vandana Mehtani, Vandana Dhawan
   Date Created:  August-07-2002
   Contains:      PixTel UI wrapper routines
               High Level Category screen wrappers.
**********************************************************************************/

#include "MMI_features.h"
#include "stdC.h"
#include "mmi_platform.h"
#include "mmi_frm_gprot.h"
#include "GlobalDefs.h"
#include "CustDataProts.h"
#include "CustMenuRes.h"
#include "WguiCategoryGprot.h"
#include "wgui_tab_bars.h"
#include "wgui_dynamic_menus.h"
#include "gui_dynamic_menus.h"
#include "IdleAppDef.h"
#include "IdleAppProt.h"
#include "WallpaperDefs.h"
#include "ScreenSaverDefs.h"
#include "MainMenuDef.h"
#include "SettingGProts.h"
#include "ShortcutsDefs.h"
#include "SimDetectionGexdcl.h"
#include "wgui_fixed_menuitems.h"
#include "wgui_softkeys.h"
//#include "PhoneBookGprot.h"
#include "ScreenRotationGprot.h"
#include "gui_font_size.h"
#ifdef __MMI_AUDIO_PLAYER__
/* dependent headers for AudioPlayerXXX.h" */
#include "mdi_datatype.h"
#include "kal_release.h"
#include "Conversions.h"
#include "FileMgr.h"
#include "AudioPlayerDef.h"
#include "AudioPlayerType.h"
#include "AudioPlayerProt.h"
#include "AudioPlayerMainScreen.h"
#endif /* __MMI_AUDIO_PLAYER__ */ 

/* MTK Elvis for R2L characters */
#include "BIDIDEF.h"
#include "BIDIProt.h"
/* MTK end */

#ifdef __MMI_AVATAR__
#include "mmi_phnset_dispchar.h"
#include "avatarGprot.h"
#endif

#if defined(__MMI_SMART_MESSAGE_MO__) && !defined(__MMI_MESSAGES_EMS__)
#include "SmsGuiInterfaceType.h"
#endif /* defined(__MMI_SMART_MESSAGE_MO__) && !defined(__MMI_MESSAGES_EMS__) */ 
#if defined(__MMI_TOUCH_SCREEN__)
#include "wgui_virtual_keyboard.h"
#endif /* defined(__MMI_TOUCH_SCREEN__) */ 

#ifdef __MMI_EDITABLE_AUDIO_EQUALIZER__
#include "SoundEffect.h"
#endif /* __MMI_EDITABLE_AUDIO_EQUALIZER__ */ 

#if defined(__MMI_TOUCH_SCREEN__) && defined(__MMI_WALLPAPER_ON_BOTTOM__)
#include "VolumeHandler.h"
#endif 

#if (defined(__MTK_TARGET__) && !defined(__MAUI_BASIC__) && !defined(__L1_STANDALONE__) && !defined(EMPTY_MMI))
#include "bmt.h"
#include "pwic.h"
extern kal_bool custom_cfg_gpio_set_level(kal_uint8 gpio_dev_type, kal_uint8 gpio_dev_level);
extern void setup_UI_wrappers(void);
#endif /* (defined(__MTK_TARGET__) && !defined(__MAUI_BASIC__) && !defined(__L1_STANDALONE__) && !defined(EMPTY_MMI)) */ 

#include "WorldclockResDef.h"

#include "ImmProt.h"

#include "mmi_include.h"

#if defined (__MMI_MAINLCD_240X320__) || defined (__MMI_MAINLCD_240X400__)
#define MMI_CAT401_X_OFFSET   17
#elif defined (__MMI_MAINLCD_320X240__)
#define MMI_CAT401_X_OFFSET   17
#elif defined (__MMI_MAINLCD_176X220__)
#define MMI_CAT401_X_OFFSET   14
#else
#define MMI_CAT401_X_OFFSET   10
#endif

/* for NFB progress bar images */
extern U8 *nfb_progress_images[];

#ifdef __MMI_BIDI_ALG__
extern U8 visual_str[];
#endif 
extern BOOL r2lMMIFlag;

/* Externals for graphics context switching  */
extern bitmap main_LCD_device_bitmap;
extern bitmap sub_LCD_device_bitmap;
extern bitmap *current_LCD_device_bitmap;

/* store Main lcd width */
extern S32 MAIN_LCD_device_width;

/* store Main LCD height */
extern S32 MAIN_LCD_device_height;

extern BOOL dynamic_item_text_align_left;

extern FuncPtr gExitFullScreenCallBack;

extern mmi_editor_handler_struct g_mmi_editor_hanler;

void UI_set_main_LCD_graphics_context(void);
void UI_set_sub_LCD_graphics_context(void);

extern pBOOL GetShowAOC(void);
extern S32 UI_get_font_height(UI_font_type f);

extern void wgui_title_set_no_icon_shct(MMI_BOOL no_icon_shct);

extern void UI_draw_horizontal_line(S32 x1, S32 x2, S32 y, color c);
extern void UI_putpixel(S32 x, S32 y, color c);
extern void UI_draw_vertical_line(S32 y1, S32 y2, S32 x, color c);
extern void wgui_setup_singleline_inputbox(
                S32 x,
                S32 y,
                S32 width,
                S32 height,
                U8 *buffer,
                S32 buffer_size,
                U16 category_screen_ID,
                UI_string_type RSK_label,
                PU8 RSK_icon,
                U32 input_type,
                U8 *history_buffer,
                U8 information_bar_flag);
extern void wgui_close_singleline_inputbox(void);
extern void get_singleline_inputbox_category_history(U16 history_ID, U8 *history_buffer);
extern void move_slide_control_value(slide_control *s, S32 x, S32 y);

extern void (*ExitCategoryFunction) (void);
 

extern void dm_set_scr_bg_image_no_draw(U16 image_id, S8 *file_name, S32 x, S32 y, U8 opacity);


extern void wgui_title_set_no_icon_shct(MMI_BOOL no_icon_shct);

extern void SetListScreenFunctions(S32 cat_id);
extern gdi_handle wgui_base_layer;
#ifdef __MMI_CALORIE__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __MMI_CALORIE__ */ 

/* Store current menu type..matrix,list,circular */
S32 MMI_current_menu_type = MATRIX_MENU;

S32 volume_level_UI;

U16 on_idle_screen = 0;

U8 Category154Align = 0;
U8 cat9_show_message = 0;

/* a flagused to check if text dispaly in category125 is scrolling or not */
U8 flag_scroll = FALSE;

/* used by category125 to display valeu in dispaly valeu bar beliow title bar */
U8 *disp_valuestr = NULL;

/* used by categopry 125 */
U8 *disp_barstr = NULL, *left_value = NULL, *right_value = NULL;

S16 status_icon = 0;

/* global variable store the image height,width ,and no_of_pixtel */
S32 no_of_pixel = 0;

/* store category142 image list */
U16 *category_142_image_list = NULL;

/* store the category142 image list inex */
U8 **category_142_image_file_name_list = NULL;

/* store the category142 image filename list inex */
S32 *category_142_image_list_index = NULL;

/* store number of items of category 142 */
S32 category_142_image_list_n_items = 0;

/* vertical scroll bar of category 142 */
vertical_scrollbar category142_vbar;

/* list of titles of category 142 */
U8 **category_142_list_of_titles = NULL;


/* category 154 message 1 y postition */
S32 category_154_message1_y = 0;

/* category 154 message 2 y position  */
S32 category_154_message2_y = 0;

UI_string_type category155_slide_string = NULL;

#if defined (__MMI_WALLPAPER_ON_BOTTOM__)
static MMI_ID_TYPE idle_scr_bg_ID;
static S8 *idle_scr_bg_filename;
static S32 idle_scr_bg_x, idle_scr_bg_y;
static U8 idle_scr_bg_opacity;
static S32 idle_scr_bg_flags;
#endif /* defined (__MMI_WALLPAPER_ON_BOTTOM__) */ 

extern U16 title_bg_id;

U16 Cat402PercentageBarId = 0;

/* Start of Common List Category Screen   */
extern PU8 subMenuDataPtrs[MAX_SUB_MENUS];

#ifdef __J2ME__
extern gdi_handle jui_layer_handle;
extern void ExitCategory176Screen(void);
#if defined (MMI_SHOW_STATUS_ICON_IN_TITLE)
extern void gui_title_oem_show_normal_ex(void);
#endif
#endif /* __J2ME__ */ 

U32 status_bar_flag[MAX_STATUS_ICON_BARS];

/* for category 75 and 77 */
static U8 old_font_size = 0;
static S8 old_font_style = 0;


/*****************************************************************************
 * FUNCTION
 *  ExitCategoryDummyScreen
 * DESCRIPTION
 *  Exits the dummy category screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void ExitCategoryDummyScreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    set_status_icon_bar_type(0, status_bar_flag[0]);
    set_status_icon_bar_type(1, status_bar_flag[1]);
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategoryDummyScreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    status_bar_flag[0] = get_status_icon_bar_type(0);
    hide_status_icon_bar(0);
    status_bar_flag[1] = get_status_icon_bar_type(1);
    hide_status_icon_bar(1);

    ExitCategoryFunction = ExitCategoryDummyScreen;
    RedrawCategoryFunction = dm_redraw_category_screen;
    GetCategoryHistory = dummy_get_history;
    GetCategoryHistorySize = dummy_get_history_size;
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategoryDummySmallScreen
 * DESCRIPTION
 *  Exits the dummy small category screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void ExitCategoryDummySmallScreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    reset_small_screen();
#endif
    ExitCategoryDummyScreen();
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategoryDummySmallScreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if defined(__MMI_SCREEN_ROTATE__)
	mmi_frm_screen_rotate_enum rotate;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_SCREEN_ROTATE__)
	rotate = mmi_frm_get_previous_screen_rotate();	
	mmi_frm_screen_rotate(rotate);
#endif

#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    set_small_screen();    
#endif
    ShowCategoryDummyScreen();
    ExitCategoryFunction = ExitCategoryDummySmallScreen;
}


/*****************************************************************************
 * FUNCTION
 *  RedrawListCategoryScreen
 * DESCRIPTION
 *  Redraw category function of current main lcd category scrren using list menu
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void RedrawListCategoryScreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_TITLE_TRANSITION__
    S32 no_transition_in_title = 0;

    {
        if ((gOnFullScreen & MMI_IN_FULL_SCREEN || gOnFullScreen & MMI_LEAVE_FULL_SCREEN) &&
            !(gOnFullScreen & MMI_LEAVE_FULL_IDLE_SCREEN))
        {
            no_transition_in_title = 1;
        }
        if (get_title_transition() != WGUI_TRANSITION_NONE && !no_transition_in_title)
        {
            draw_title();
        }
    }
#endif /* __MMI_UI_TITLE_TRANSITION__ */ 

    gdi_layer_lock_frame_buffer();
#if(UI_ENABLE_POP_UP_DESCRIPTIONS)
    gui_pop_up_description_stop_scroll();
#endif 

#ifdef __MMI_WGUI_MINI_TAB_BAR__
    if (wgui_if_mini_tab_bar_enable() == MMI_TRUE)
    {
        move_fixed_list(MMI_fixed_list_menu.x, MMI_content_y + 5);
        resize_fixed_list(MMI_fixed_list_menu.width, MMI_fixed_list_menu.height - 5);
        wgui_show_mini_tab_bar();
    }
#endif /* __MMI_WGUI_MINI_TAB_BAR__ */ 
    clear_buttonbar();
    show_title_status_icon();

#ifdef __MMI_UI_TITLE_TRANSITION__
    if (no_transition_in_title || get_title_transition() == WGUI_TRANSITION_NONE)
#endif 

    /* For transition, title function call should be from here */
    draw_title();


    show_fixed_list();
    show_softkey_background();
    show_left_softkey();
    show_right_softkey();
    gdi_layer_unlock_frame_buffer();



    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
   
}   /* end of RedrawListCategoryScreen */


/*****************************************************************************
 * FUNCTION
 *  ExitListCategoryScreen
 * DESCRIPTION
 *  Exit category function of current main lcd category scrren using list menu
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitListCategoryScreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_title_disable_menu_shortcut_display(MMI_FALSE);
    ClearHighlightHandler();
    reset_softkeys();
    reset_menu_shortcut_handler();
    reset_fixed_list();
    reset_pop_up_descriptions();
    /* Reset key callback in editor option menu */
    wgui_inputs_option_menu_reset_key_callback();
    wgui_inputs_option_menu_reset_highlight_callback();
#ifdef __MMI_UI_HINTS_IN_MENUITEM__
    reset_all_force_flags_for_hints();
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gui_unblock_list_effect();
#endif 
#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 
#ifdef __MMI_UI_HINT_TOGGLE_TRANSITION__
    wgui_reset_pop_up_description_transition();
#endif

}   /* end of ExitListCategoryScreen */


/*****************************************************************************
 * FUNCTION
 *  ShowListCategoryScreen_ext
 * DESCRIPTION
 *  Common function to show category screens containing list menu.
 * PARAMETERS
 *  title                   [IN]        String of title
 *  title_icon              [IN]        Icon of title
 *  left_softkey            [IN]        String of left softkey
 *  left_softkey_icon       [IN]        Icon of left softkey
 *  right_softkey           [IN]        String of right softkey
 *  right_softkey_icon      [IN]        Icon of right softkey
 * RETURNS
 *  void
 *****************************************************************************/
void ShowListCategoryScreen_ext(
        UI_string_type title,
        PU8 title_icon,
        UI_string_type left_softkey,
        PU8 left_softkey_icon,
        UI_string_type right_softkey,
        PU8 right_softkey_icon)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    dm_add_title(title, title_icon);
    dm_add_softkey(left_softkey, left_softkey_icon, right_softkey, right_softkey_icon);
}


/*****************************************************************************
 * FUNCTION
 *  ShowListCategoryScreen
 * DESCRIPTION
 *  Common function to show category screens containing list menu.
 * PARAMETERS
 *  title                   [IN]        String of title
 *  title_icon              [IN]        Icon of title
 *  left_softkey            [IN]        String of left softkey
 *  left_softkey_icon       [IN]        Icon of left softkey
 *  right_softkey           [IN]        String of right softkey
 *  right_softkey_icon      [IN]        Icon of right softkey
 *  number_of_items         [IN]        Number of items in list menu
 * RETURNS
 *  void
 *****************************************************************************/
void ShowListCategoryScreen(
        UI_string_type title,
        PU8 title_icon,
        UI_string_type left_softkey,
        PU8 left_softkey_icon,
        UI_string_type right_softkey,
        PU8 right_softkey_icon,
        S32 number_of_items)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 shortcut_width;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    ShowListCategoryScreen_ext(
        title,
        title_icon,
        left_softkey,
        left_softkey_icon,
        right_softkey,
        right_softkey_icon);
    /* ShortCut */
    if (!wgui_is_disable_shortcut_display())
    {
        wgui_title_set_menu_shortcut_number(-1);
        register_fixed_list_shortcut_handler();
        shortcut_width = set_menu_item_count(number_of_items) + 7;
        resize_menu_shortcut_handler(shortcut_width, MMI_title_height);
        move_menu_shortcut_handler(MMI_title_x + MMI_title_width - MMI_menu_shortcut_box.width, MMI_title_y);
        register_hide_menu_shortcut(gui_redraw_menu_shortcut);
    }
    else
    {
        wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    }

    /* List */
    MMI_current_menu_type = LIST_MENU;
    register_fixed_list_keys();
    resize_fixed_icontext_menuitems(0, MMI_MENUITEM_HEIGHT);

    resize_fixed_icontext_menuitems(
        MMI_fixed_list_menu.width - MMI_fixed_list_menu.vbar.width - GUI_MENUITEM_X1_GAP - GUI_MENUITEM_X2_GAP,
        MMI_fixed_icontext_menuitem.height);

    register_fixed_list_highlight_handler(standard_list_highlight_handler);
    //set_fixed_icontext_positions(MMI_MENUITEM_HEIGHT + 2, 0, 1, 0);

    gdi_layer_unlock_frame_buffer();
}   /* end of ShowListCategoryScreen */

/* End of Common List Category Screen  */


/*****************************************************************************
 * FUNCTION
 *  ShowCategory2Screen
 * DESCRIPTION
 *  Displays the category2 screen
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the Left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  message                 [IN]        Message string
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory2Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U16 message,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *message_str = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    message_str = (U8*) get_string((MMI_ID_TYPE) message);
    ShowCategory7Screen(
        title,
        title_icon,
        left_softkey,
        left_softkey_icon,
        right_softkey,
        right_softkey_icon,
        message_str,
        history_buffer);
}   /* end of ShowCategory2Screen */


/*****************************************************************************
 * FUNCTION
 *  ShowCategory7Screen
 * DESCRIPTION
 *  Displays the category7 screen
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  message                 [IN]        Notification message (string. Not string ID)
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory7Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U8 *message,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 l;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);

    gdi_layer_lock_frame_buffer();

    wgui_title_set_menu_shortcut_number(-1);

	dm_add_title(get_string(title), get_image(title_icon));
	dm_add_softkey(get_string(left_softkey), get_image(left_softkey_icon), get_string(right_softkey), get_image(right_softkey_icon));
    MMI_message_string = (UI_string_type) (message);
    l = gui_strlen(MMI_message_string);
    create_multiline_inputbox_set_buffer(MMI_message_string, l, l, 0);
	register_multiline_inputbox_viewer_keys();
    MMI_multiline_inputbox.flags |=
        (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_TRANSPARENT_BACKGROUND |
         UI_MULTI_LINE_INPUT_BOX_AUTO_DISABLE_SCROLLBAR | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE);
#ifdef __MMI_WALLPAPER_ON_BOTTOM__ 
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_TRANSPARENT_BACKGROUND;
    dm_get_scr_bg_opacity(&idle_scr_bg_opacity);
    dm_set_scr_bg_opacity((U8)(current_MMI_theme->bg_opacity_low));
#endif
	set_multiline_inputbox_category_history(MMI_CATEGORY7_ID, history_buffer);
    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = ExitCategory7Screen;
    RedrawCategoryFunction = dm_redraw_category_screen;
    GetCategoryHistory = dm_get_category_history;
    GetCategoryHistorySize = dm_get_category_history_size;
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY7_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();

}   /* end of ShowCategory7Screen */


/*****************************************************************************
 * FUNCTION
 *  ExitCategory7Screen
 * DESCRIPTION
 *  Exits the category7 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory7Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    reset_softkeys();
#ifdef __MMI_WALLPAPER_ON_BOTTOM__ 
    dm_set_scr_bg_opacity(idle_scr_bg_opacity);
#endif  
}   /* end of ExitCategory7Screen */


/*****************************************************************************
 * FUNCTION
 *  ShowCategory8Screen
 * DESCRIPTION
 *  Displays the category8 screen
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  message                 [IN]        Notification message
 *  message_icon            [IN]        Message icon
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory8Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U16 message,
        U16 message_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ShowCategory66Screen(
        title,
        title_icon,
        left_softkey,
        left_softkey_icon,
        right_softkey,
        right_softkey_icon,
        (U8*) get_string(message),
        message_icon,
        history_buffer);
}   /* end of ShowCategory8Screen */


/*****************************************************************************
 * FUNCTION
 *  ShowCategory208Screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  message                 [IN]        String of message
 *  message_icon            [IN]        Icon of message
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory208Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        S8 *message,
        U16 message_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ShowCategory66Screen(
        title,
        title_icon,
        left_softkey,
        left_softkey_icon,
        right_softkey,
        right_softkey_icon,
        (U8*) message,
        message_icon,
        history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory9Screen
 * DESCRIPTION
 *  Displays the category9 screen
 * PARAMETERS
 *  message             [IN]        Message string
 *  message_icon        [IN]        Message icon
 *  history_buffer      [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory9Screen(U16 message, U16 message_icon, U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 l;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    dm_reset_context();
    UI_UNUSED_PARAMETER(history_buffer);
    gdi_layer_lock_frame_buffer();
    entry_full_screen();
    wgui_title_set_menu_shortcut_number(-1);
    clear_category_screen_key_handlers();
    clear_left_softkey();
    clear_right_softkey();

    if (message != 0)
    {
        MMI_message_string = (UI_string_type) get_string(message);
        l = gui_strlen(MMI_message_string);
        create_multiline_inputbox_set_buffer(MMI_message_string, l, l, 0);
        MMI_multiline_inputbox.normal_text_color = gui_color(0, 0, 0);
        MMI_multiline_inputbox.flags |=
            (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY |
             UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND | UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR);
    }
    else
    {
        MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_DRAW;
    }
    dm_add_image(get_image(message_icon), NULL, NULL);

    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = UI_dummy_function;
    RedrawCategoryFunction = dm_redraw_category_screen;
    GetCategoryHistory = dm_get_category_history;
    GetCategoryHistorySize = dm_get_category_history_size;
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY9_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND_COLOR;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();

}   /* end of ShowCategory9Screen */


/*****************************************************************************
 * FUNCTION
 *  ExitCategory9Screen
 * DESCRIPTION
 *  Exits the category9 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory9Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_hide_animations();
}   /* end of ExitCategory9Screen */
 
/*****************************************************************************
 * FUNCTION
 *  ShowCategory21Screen
 * DESCRIPTION
 *  Displays the category21 screen
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  message                 [IN]        Notification message (string. Not string ID)
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory21Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U16 message,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);
    gdi_layer_lock_frame_buffer();
    wgui_title_set_menu_shortcut_number(-1);
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    SetupCategoryKeyHandlers();

    MMI_title_string = (UI_string_type) get_string(title);
    MMI_title_icon = (PU8) get_image(title_icon);
    MMI_message_string = (UI_string_type) get_string(message);
    create_multiline_inputbox_set_buffer(
        MMI_message_string,
        gui_strlen((UI_string_type) MMI_message_string),
        gui_strlen((UI_string_type) MMI_message_string),
        0);
    SetKeyHandler(multiline_inputbox_previous_line, KEY_UP_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(multiline_inputbox_next_line, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
    MMI_multiline_inputbox.flags |=
        (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE);
#ifdef __MMI_WALLPAPER_ON_BOTTOM__ 
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_TRANSPARENT_BACKGROUND;
    dm_get_scr_bg_opacity(&idle_scr_bg_opacity);
    dm_set_scr_bg_opacity((U8)(current_MMI_theme->bg_opacity_low));
#endif
    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = ExitCategory21Screen;
    RedrawCategoryFunction = dm_redraw_category_screen;
    GetCategoryHistory = dm_get_category_history;
    GetCategoryHistorySize = dm_get_category_history_size;
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY21_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();

}   /* end of ShowCategory21Screen */


/*****************************************************************************
 * FUNCTION
 *  ExitCategory21Screen
 * DESCRIPTION
 *  Exits the category21 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory21Screen(void) 
{
#ifdef __MMI_WALLPAPER_ON_BOTTOM__ 
    dm_set_scr_bg_opacity(idle_scr_bg_opacity);
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory22Screen
 * DESCRIPTION
 *  Displays the category22 screen
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon displayed with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Left softkey icon
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Right softkey icon
 *  num_of_symbols          [IN]        Number of symbols
 *  MMI_symbols             [IN]        Symbols specific to application
 *  highlighted_item        [IN]        Default item to be highlighted (if there is no history)
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory22Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        S32 num_of_symbols,
        U8 **MMI_symbols,
        S32 highlighted_item,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 i, w = 0, h = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gui_block_list_effect();
#endif 

    gdi_layer_lock_frame_buffer();
    dm_add_title(get_string(title), get_image(title_icon));
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    SetupCategoryKeyHandlers();
    wgui_fixed_matrix_create_menu(num_of_symbols, highlighted_item, WGUI_LIST_MENU_DISABLE_SHORTCUT, MMI_CATEGORY22_ID, history_buffer);
    MMI_fixed_icontext_menuitem.flags |= UI_MENUITEM_CENTER_TEXT_X;
    
    MMI_fixed_icontext_menuitem.selected_filler = current_MMI_theme->symbol_picker_highlight_filler;
    MMI_fixed_icontext_menuitem.focussed_filler = current_MMI_theme->symbol_picker_highlight_filler;
    resize_fixed_matrix(MMI_content_width, MMI_content_height);
    wgui_fixed_matrix_begin_add_one_item();
    for (i = 0; i < num_of_symbols; i++)
    {
        S32 tw, th;
        wgui_fixed_matrix_add_one_item(i, MMI_symbols[i], NULL);
		
		gui_set_font(&MMI_medium_font);

        gui_measure_string((UI_string_type) MMI_symbols[i], &tw, &th);
        w = (tw > w) ? tw : w;
        h = (th > h) ? th : h;
    }
	/* if the highlight image is larger than the matrix item, enlarge the matrix item dimension to the image */
    if (current_MMI_theme->symbol_picker_highlight_filler && 
        ((current_MMI_theme->symbol_picker_highlight_filler->flags & 0xFF) == UI_FILLED_AREA_TYPE_BITMAP) &&
        current_MMI_theme->symbol_picker_highlight_filler->b)
    {
        S32 iw, ih;
		
        gdi_image_get_dimension(current_MMI_theme->symbol_picker_highlight_filler->b, &iw, &ih);
		
        /* 2 for 2-pixel spacing (see configure_fixed_matrix() below) */
        if ((iw >= w) && (ih >= h))
        {
            w = iw - 2;
            h = ih - 2;
        }
    }

    configure_fixed_matrix(w + 2, h + 2, 0, 0);
    wgui_fixed_matrix_end_add_one_item();
    wgui_fixed_matrix_override_highlight_handler(standard_noshortcut_matrix_highlight_handler);

    MMI_fixed_matrix_menu.flags |= UI_MATRIX_MENU_LOOP;

    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = ExitCategory22Screen;
    RedrawCategoryFunction = dm_redraw_category_screen;
    GetCategoryHistory = dm_get_category_history;
    GetCategoryHistorySize = dm_get_category_history_size;
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY22_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();

}   /* end of ShowCategory22Screen */


/*****************************************************************************
 * FUNCTION
 *  ExitCategory22Screen
 * DESCRIPTION
 *  Exits the category22 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory22Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ClearHighlightHandler();
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gui_unblock_list_effect();
#endif 
    reset_softkeys();
    reset_menu_shortcut_handler();
    reset_fixed_matrix();
}   /* end of ExitCategory22Screen */


/*****************************************************************************
 * FUNCTION
 *  GetCategory22HistorySize
 * DESCRIPTION
 *  Get category22 history size.
 * PARAMETERS
 *  void
 * RETURNS
 *  the size of history buffer
 *****************************************************************************/
S32 GetCategory22HistorySize(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    // TODO: need to revise.
    return (20);
}   /* end of GetCategory22HistorySize */


/*****************************************************************************
 * FUNCTION
 *  GetCategory22History
 * DESCRIPTION
 *  Get category22 history.
 * PARAMETERS
 *  history_buffer      [IN]        History buffer
 * RETURNS
 *  hitsory buffer
 *****************************************************************************/
U8 *GetCategory22History(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    get_matrix_menu_category_history(MMI_CATEGORY22_ID, history_buffer);
    return (history_buffer);
}   /* end of GetCategory22History */


/*****************************************************************************
 * FUNCTION
 *  GetCategory32HistorySize
 * DESCRIPTION
 *  Get category32 history size.
 * PARAMETERS
 *  void
 * RETURNS
 *  the size of history buffer
 *****************************************************************************/
S32 GetCategory32HistorySize(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    return (((sizeof(list_menu_category_history) + 3) & (~3)) + sizeof(multiline_inputbox_category_history));
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory32History
 * DESCRIPTION
 *  Get category32 history.
 * PARAMETERS
 *  history_buffer      [OUT]        History buffer
 * RETURNS
 *  hitsory buffer
 *****************************************************************************/
U8 *GetCategory32History(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 offset;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    get_list_menu_category_history(MMI_CATEGORY32_ID, history_buffer);
    offset = (sizeof(list_menu_category_history) + 3) & (~3);
    wgui_inputs_ml_get_category_history(MMI_CATEGORY32_ID, (U8*)(history_buffer + offset));
    return (history_buffer);
}

/*****************************************************************************
 * FUNCTION
 *  category32_keyboard_key_handler
 * DESCRIPTION
 *  Key handler of category32 for WIN32
 * PARAMETERS
 *  vkey_code       [IN]        Type of key
 *  key_state       [IN]        State of key
 * RETURNS
 *  void
 *****************************************************************************/
void category32_keyboard_key_handler(S32 vkey_code, S32 key_state)
{
    UI_UNUSED_PARAMETER(vkey_code);
    UI_UNUSED_PARAMETER(key_state);
}   /* end of category32_keyboard_key_handler */


/*****************************************************************************
 * FUNCTION
 *  category32_list_highlight_handler
 * DESCRIPTION
 *  high light handler of category32
 * PARAMETERS
 *  item_index      [IN]        Index of current highlighted item
 * RETURNS
 *  void
 *****************************************************************************/
void category32_list_highlight_handler(S32 item_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_title_set_menu_shortcut_number(item_index + 1);
    MMI_highlighted_item_text = get_item_text(item_index);
    gdi_layer_lock_frame_buffer();
    MMI_list_highlight_handler(item_index);
    gdi_layer_unlock_frame_buffer();
#if(UI_ENABLE_POP_UP_DESCRIPTIONS)
    gui_pop_up_description_stop_scroll();
    wgui_current_pop_up_description_index = item_index;
#endif /* (UI_ENABLE_POP_UP_DESCRIPTIONS) */ 
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory32Screen
 * DESCRIPTION
 *  Displays the Dynamic menu screen
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon displayed with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Left softkey icon
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Right softkey icon
 *  number_of_items         [IN]        Number of items in the menu
 *  list_of_items           [IN]        Array of items
 *  list_of_icons           [IN]        Array of icons
 *  flags                   [IN]        Flags (see explanation below)
 *  highlighted_item        [IN]        Default item to be highlighted (if there is no history)
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory32Screen(
        U8 *title,
        PU8 title_icon,
        U8 *left_softkey,
        PU8 left_softkey_icon,
        U8 *right_softkey,
        PU8 right_softkey_icon,
        S32 number_of_items,
        U8 **list_of_items,
        PU8 *list_of_icons,
        S32 flags,
        S32 highlighted_item,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 i, l;
    S32 x = 24;
    U8 flag = 0;
    U32 list_flag = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(flags);
    gdi_layer_lock_frame_buffer();
    entry_full_screen();

    dm_add_softkey((UI_string_type) left_softkey, left_softkey_icon, (UI_string_type) right_softkey, right_softkey_icon);

    if (list_of_icons[0] == UI_NULL_IMAGE)
    {
        list_flag = WGUI_LIST_MENU_DISABLE_SHORTCUT;
    }

    wgui_fixed_list_create_icontext_menu(
        number_of_items,
        highlighted_item,
        list_flag,
        MMI_CATEGORY32_ID,
        history_buffer);

    resize_fixed_list(MMI_content_width, UI_device_height - (MMI_title_height << 1) - MMI_button_bar_height);
    wgui_fixed_list_begin_add_icontext_one_item();
    for (i = 0; i < number_of_items; i++)
    {
        wgui_fixed_list_add_icontext_one_item(i, list_of_items[i], list_of_icons[i],NULL);
        if (list_of_icons[i] != UI_NULL_IMAGE)
        {
            flag = 1;
        }
    }
    wgui_fixed_list_end_add_icontext_one_item();
    resize_fixed_icontext_menuitems(0, get_menu_item_height());
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    if (flag)
    {
        //set_fixed_icontext_positions(MMI_MENUITEM_HEIGHT + 2, 0, 1, 0);
    }
    else
    {
        set_fixed_icontext_positions(GUI_TEXT_MENUITEM_TEXT_X, 0, 1, 0);
        //MMI_fixed_icontext_menuitem.scroll_width = MMI_fixed_icontext_menuitem.width - 2;
    }

    wgui_fixed_list_override_text_highlight_handler(category32_list_highlight_handler);
    MMI_title_string = (UI_string_type) title;
    wgui_set_animation_image(x >> 1, (MMI_title_y + MMI_title_height), (PU8) title_icon);
    if (title_icon == NULL)
    {
        x = 0;
    }

    l = gui_strlen(MMI_title_string);
    create_multiline_inputbox_set_buffer(MMI_title_string, l, l, 0);
    MMI_multiline_inputbox.flags |= (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE);  /* |UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND); */
    SetKeyHandler(multiline_inputbox_previous_line, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(multiline_inputbox_next_line, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    register_keyboard_key_handler(category32_keyboard_key_handler);
    if (history_buffer)
    {
        S32 offset;
        offset = (sizeof(list_menu_category_history) + 3) & (~3);
        set_multiline_inputbox_category_history(MMI_CATEGORY32_ID, (U8*)(history_buffer + offset));
    }
    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = ExitCategory32Screen;
    RedrawCategoryFunction = dm_redraw_category_screen;
    GetCategoryHistory = GetCategory32History;
    GetCategoryHistorySize = GetCategory32HistorySize;
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY32_ID;
    dm_data.s32flags = 0;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();

}   /* end of ShowCategory32Screen */


/*****************************************************************************
 * FUNCTION
 *  ExitCategory32Screen
 * DESCRIPTION
 *  Exits the dynamic menu screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory32Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_title_disable_menu_shortcut_display(MMI_FALSE);
#if(UI_BLINKING_CURSOR_SUPPORT)
    StopTimer(BLINKING_CURSOR);
#endif 
    ClearHighlightHandler();
    reset_softkeys();
    reset_menu_shortcut_handler();
    reset_fixed_list();
}   /* end of ExitCategory32Screen */


/* For detail description, please refer to wgui_categories.h */
void ShowCategory61Screen(U8 *message, U16 message_icon, U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 l, width, height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    dm_reset_context();
    UI_UNUSED_PARAMETER(history_buffer);

    gdi_layer_lock_frame_buffer();

    entry_full_screen();
    wgui_title_set_menu_shortcut_number(-1);
    clear_category_screen_key_handlers();
    clear_left_softkey();
    clear_right_softkey();
    MMI_message_string = (UI_string_type) message;
    MMI_message_icon = (PU8) get_image(message_icon);
    gui_measure_image(MMI_message_icon, &width, &height);
    l = gui_strlen(MMI_message_string);
    wgui_inputs_ml_create_set_buffer(MMI_message_string, l, l, 0);
    MMI_multiline_inputbox.normal_text_color = gui_color(0, 0, 0);
    MMI_multiline_inputbox.border_color = gui_color(255, 255, 255);
    MMI_multiline_inputbox.ext_flags |= GUI_MULTI_LINE_INPUT_BOX_USE_BORDER_FONT;
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW
        | UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE;
    dm_add_image(MMI_message_icon, NULL, NULL);

    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = MMI_dummy_function;
    dm_setup_category_functions(dm_redraw_category_screen, dummy_get_history, dummy_get_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY61_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}


/*****************************************************************************
 * FUNCTION
 *  cat66_update_progress_string
 * DESCRIPTION
 *  Update status of progress for category66screen
 *  [IMPORTANT] Please notice that this function will not redo the layout.
 *  [IMPORTANT] The updated string length can't longer than length of the first string.
 *  [IMPORTANT] Otherwise the updated string will be trunacated.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void cat66_update_progress_string(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 l = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    gdi_layer_push_clip();
    gdi_layer_set_clip(
        MMI_multiline_inputbox.x + 2,
        MMI_multiline_inputbox.y,
        MMI_multiline_inputbox.x + MMI_multiline_inputbox.width - 2,
        MMI_multiline_inputbox.y + MMI_multiline_inputbox.height - 1);
#ifdef __GDI_MEMORY_PROFILE_2__
#if  defined(DM_NEW_POPUPBG_METHOD)
    wgui_popup_draw_region_with_background_color(
        MMI_multiline_inputbox.x + 2,
        MMI_multiline_inputbox.y,
        MMI_multiline_inputbox.x + MMI_multiline_inputbox.width - 2,
        MMI_multiline_inputbox.y + MMI_multiline_inputbox.height - 1);
#else   /* __MMI_MAINLCD_320X480__ */
    gdi_draw_solid_rect(
        MMI_multiline_inputbox.x + 2,
        MMI_multiline_inputbox.y,
        MMI_multiline_inputbox.x + MMI_multiline_inputbox.width - 2,
        MMI_multiline_inputbox.y + MMI_multiline_inputbox.height - 1,
        GDI_COLOR_TRANSPARENT);
#endif  /* __MMI_MAINLCD_320X480__*/
#else /* __GDI_MEMORY_PROFILE_2__ */
#ifdef __MMI_MAINLCD_240X320__
    gui_fill_rectangle(
        MMI_multiline_inputbox.x + 2,
        MMI_multiline_inputbox.y,
        MMI_multiline_inputbox.x + MMI_multiline_inputbox.width - 2,
        MMI_multiline_inputbox.y + MMI_multiline_inputbox.height - 1,
        wgui_pop_up_dialog_background.c);
#else /* __MMI_MAINLCD_240X320__ */ 
    gui_fill_rectangle(
        MMI_multiline_inputbox.x + 2,
        MMI_multiline_inputbox.y,
        MMI_multiline_inputbox.x + MMI_multiline_inputbox.width - 2,
        MMI_multiline_inputbox.y + MMI_multiline_inputbox.height - 1,
        UI_COLOR_WHITE);
#endif /* __MMI_MAINLCD_240X320__ */ 
#endif /* __GDI_MEMORY_PROFILE_2__ */

    l = gui_strlen(MMI_message_string);
    
    gui_create_multi_line_input_box_set_buffer(
        &MMI_multiline_inputbox,
        MMI_multiline_inputbox.x,
        MMI_multiline_inputbox.y,
        MMI_multiline_inputbox.width,
        MMI_multiline_inputbox.height,
        (UI_string_type) MMI_message_string,
        l * 2,
        (l + 1) * 2,
        0);
    MMI_multiline_inputbox.text_x = 0;
    MMI_multiline_inputbox.normal_text_color = *current_MMI_theme->popup_text_color;
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW
        | UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE;
    MMI_multiline_inputbox.ext_flags |= GUI_MULTI_LINE_INPUT_BOX_TRUNCATE_CONTENT;
    
	show_multiline_inputbox_no_draw();
    show_multiline_inputbox();
    gdi_layer_pop_clip();
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(
        MMI_multiline_inputbox.x,
        MMI_multiline_inputbox.y,
        MMI_multiline_inputbox.x + MMI_multiline_inputbox.width - 1,
        MMI_multiline_inputbox.y + MMI_multiline_inputbox.height - 1);
}   /* end of cat66_update_progress_string */

/* 101205 irda Calvin Start */


/*****************************************************************************
 * FUNCTION
 *  ShowCategory66Screen
 * DESCRIPTION
 *  Displays the category66 screen
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  message                 [IN]        Notification message
 *  message_icon            [IN]        Message icon
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory66Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U8 *message,
        U16 message_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 l = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    dm_reset_context();
    if (((title == 0) && (title_icon == 0)) || ((title == CAT66_AREA_NONE) && (title_icon == CAT66_AREA_NONE)))
    {
        ShowCategory165Screen(
            left_softkey,
            left_softkey_icon,
            right_softkey,
            right_softkey_icon,
            (UI_string_type) message,
            message_icon,
            history_buffer);
    }
    else
    {
    UI_UNUSED_PARAMETER(history_buffer);

    gdi_layer_lock_frame_buffer();

    wgui_title_set_menu_shortcut_number(-1);
    clear_category_screen_key_handlers();
    clear_left_softkey();
    clear_right_softkey();
    dm_data.s32flags = 0;

    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    register_default_hide_softkeys();

    if ((left_softkey == 0) && (left_softkey_icon == 0) && (right_softkey == 0) && (right_softkey_icon == 0))
    {
        dm_data.s32flags |= DM_NO_SOFTKEY;
    }
    else
    {
        dm_data.s32flags &= ~DM_NO_SOFTKEY;
        register_left_softkey_handler();
        register_right_softkey_handler();
    }
        
    MMI_title_string = (UI_string_type) get_string(title);
    MMI_title_icon = (PU8) get_image(title_icon);
    MMI_message_string = (UI_string_type) message;
    l = gui_strlen(MMI_message_string);
    create_multiline_inputbox_set_buffer(MMI_message_string, l, l, 0);
    MMI_multiline_inputbox.text_x = 0;
	  MMI_multiline_inputbox.normal_text_color = *current_MMI_theme->popup_text_color;
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW
        | UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE;
    MMI_multiline_inputbox.ext_flags |= GUI_MULTI_LINE_INPUT_BOX_TRUNCATE_CONTENT;
        
    if (message_icon)
    {
        dm_add_image(get_image(message_icon), NULL, NULL);
    }
#if defined(__MMI_MAINLCD_320X480__)
#ifdef __MMI_SCREEN_ROTATE__
	if(!mmi_frm_is_screen_width_height_swapped())
#endif
	{
		register_hide_softkey(wgui_popup_hide_lsk, MMI_LEFT_SOFTKEY);
		register_hide_softkey(wgui_popup_hide_rsk, MMI_RIGHT_SOFTKEY);
		wgui_popup_set_softkey_theme();
		wgui_popup_set_softkey_flag();
		disable_softkey_background();
	}
#endif
    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = ExitCategory66Screen;
    dm_setup_category_functions(dm_redraw_category_screen, dm_get_category_history, dm_get_category_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY66_ID;
#if defined(__MMI_MAINLCD_320X480__)
    if((left_softkey == 0) && (left_softkey_icon == 0) && (right_softkey == 0) && (right_softkey_icon == 0))
    {
        dm_data.s32CatId = MMI_CATEGORY66_N0_SOFTKEY_ID;
		dm_data.s32flags |= DM_NO_SOFTKEY;
    }
#ifdef __MMI_SCREEN_ROTATE__
	if(mmi_frm_is_screen_width_height_swapped())
	{
		dm_data.s32flags |= DM_NO_STATUS_BAR | DM_NO_TITLE;
	}
#endif
#endif
    dm_data.s32flags |= DM_CLEAR_SCREEN_BACKGROUND;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
    }

}   /* end of ShowCategory66Screen */


/*****************************************************************************
 * FUNCTION
 *  ExitCategory66Screen
 * DESCRIPTION
 *  Exits the category66 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory66Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_hide_animations();
    wgui_category_screen_no_buttons = 0;
    category_screen_layout_flags = 0;
#if defined(__MMI_MAINLCD_320X480__)
#ifdef __MMI_SCREEN_ROTATE__
	if(!mmi_frm_is_screen_width_height_swapped())
#endif
	{
		wgui_popup_reset_softkey_flag();
		wgui_popup_reset_softkey_theme();
		enable_softkey_background();
	}
#endif
}   /* end of ExitCategory66Screen */


/* filled colr scheme for category111 */
UI_filled_area PIN_inputbox_BG_filler = 
{
    UI_FILLED_AREA_TYPE_COLOR | UI_FILLED_AREA_SINGLE_BORDER | UI_FILLED_AREA_SHADOW,
    UI_NULL_IMAGE,
    NULL,
    {255, 222, 255, 100},
    {0, 0, 0, 0},
    {255, 0, 0, 100},
    {255, 0, 0, 100},
    0
};

/* theme of single input box of enter pin screen */

UI_single_line_input_box_theme PIN_singleline_inputbox_theme = { &PIN_inputbox_BG_filler,
    &PIN_inputbox_BG_filler,
    &PIN_inputbox_BG_filler,
    {0, 0, 0, 100},
    {128, 128, 128, 100},
    {0, 0, 0, 100},
    {255, 255, 255, 100},
    {51, 88, 171, 100},
    {255, 0, 0, 100},
    &UI_DEFAULT_FONT,
    1,
    UI_SINGLE_LINE_INPUT_BOX_CENTER_Y,
    '*'
};


/*****************************************************************************
 * FUNCTION
 *  wgui_hide_multitap
 * DESCRIPTION
 *  Hide function for multitap
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_hide_multitap(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    color c;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    c.r = 255;
    c.g = 255;
    c.b = 255;
    c.alpha = 100;
    gui_reset_clip();
    gui_fill_rectangle(
        MMI_multitap_x,
        MMI_multitap_y,
        MMI_multitap_x + MMI_multitap_width + 1,
        MMI_multitap_y + MMI_multitap_height + 1,
        c);
}   /* end of wgui_hide_multitap */


/*****************************************************************************
 * FUNCTION
 *  SetCategory69RightSoftkeyFunction
 * DESCRIPTION
 *  set category69 screen right softkey callback function
 * PARAMETERS
 *  f       [IN]        Callback function
 *  k       [IN]        Key event type
 * RETURNS
 *  void
 *****************************************************************************/
void SetCategory69RightSoftkeyFunction(void (*f) (void), MMI_key_event_type k)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(k);
    wgui_singleline_inputbox_RSK_function = f;
}


#if defined(__MMI_TOUCH_SCREEN__)
/*****************************************************************************
 * FUNCTION
 *  cat69_virtual_keypad_callback
 * DESCRIPTION
 *  virtual keypad callback in category69 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat069_virtual_keypad_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	mmi_imc_redraw_screen_by_state();
}
#endif /* defined(__MMI_TOUCH_SCREEN__) */


/*****************************************************************************
 * FUNCTION
 *  ExitCategory69Screen
 * DESCRIPTION
 *  Exit category69 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory69Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_switch_title_with_status_bar = 0;
    reset_softkeys();
    reset_multiline_inputbox();
    wgui_close_singleline_inputbox();
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory69Screen
 * DESCRIPTION
 *  show cateogyry69 screen
 * PARAMETERS
 *  title                   [IN]        Title
 *  title_icon              [IN]        Title icon
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Left softkey icon
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Right softkey icon
 *  message                 [IN]        Message to show
 *  input_type              [IN]        Input method, only support IMM_INPUT_TYPE_NUMERIC
 *  buffer                  [OUT]       Buffer for input box
 *  buffer_size             [IN]        Buffer size for input box
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory69Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U16 message,
        U32 input_type,
        U8 *buffer,
        S32 buffer_size,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 len;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    MMI_ASSERT(input_type == IMM_INPUT_TYPE_NUMERIC); /* only support IMM_INPUT_TYPE_NUMERIC */

    dm_add_softkey(
        (UI_string_type)GetString(left_softkey), 
        (PU8)GetImage(left_softkey_icon),       
        (UI_string_type)GetString(right_softkey),
        (PU8)GetImage(right_softkey_icon));
    
    SetupCategoryKeyHandlers();

    /* title */
    wgui_title_set_menu_shortcut_number(-1);
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    if (title == 0)
    {
        dm_data.s32flags = DM_NO_TITLE;
    }
    else
    {
        dm_data.s32flags = 0;
        MMI_title_string = get_string(title);
        MMI_title_icon = get_image(title_icon);
    }

    /* multiline inputbox (show message) */
    MMI_message_string = (UI_string_type)GetString(message);
    len = gui_strlen(MMI_message_string);
    create_multiline_inputbox_set_buffer(MMI_message_string, len, len, 0);
	MMI_multiline_inputbox.normal_text_color = *current_MMI_theme->list_normal_text_color;
    MMI_multiline_inputbox.flags |=
        (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY |
         UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND | UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR);
    mmi_imc_set_fixed_input_box();

    /* singleline inputbox */
    wgui_inputs_sl_setup(
        0,  /* will set later */
        0,  /* will set later */
        0,  /* will set later */
        0,  /* will set later */
        buffer,
        buffer_size,
        MMI_CATEGORY69_ID,
        get_string(right_softkey),
        get_image(right_softkey_icon),
        input_type,
        history_buffer,
        0);
    gui_set_single_line_input_box_theme(&MMI_singleline_inputbox, &PIN_singleline_inputbox_theme);

    gdi_layer_unlock_frame_buffer();

    /* set category function & draw manager data */
    ExitCategoryFunction = ExitCategory69Screen;
    dm_setup_category_functions(dm_redraw_category_screen, dm_get_category_history, dm_get_category_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY69_ID;
    dm_data.s32flags |= DM_CLEAR_SCREEN_BACKGROUND;
#if defined(__MMI_TOUCH_SCREEN__)
    dm_data.s32flags |= DM_SHOW_VKPAD;
    dm_register_vkpad_callback(wgui_cat069_virtual_keypad_callback);
#endif /* defined(__MMI_TOUCH_SCREEN__) */
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}


/* total size of input buffer */
extern S32 wgui_singleline_inputbox_buffer_size;
/* for infor-bar logo */
static PU8 g_wgui_cat2001_info_bar_icon;
/* for counter based on GB2312 */
static U8 g_wgui_cat2001_buf_used_size;
/* for input method to tell category the height of virtual keyboard */
void (*g_wgui_cat2001_resize_and_draw_func) (S32);
/* for application use key_up_arrow and key_down_arrow */
void (*g_wgui_cat2001_set_special_key_func)(void) = NULL;
/* Singleline inputbox filler */
static UI_filled_area g_wgui_cat2001_inputbox_BG_filler = 
{
    UI_FILLED_AREA_TYPE_COLOR,
    UI_NULL_IMAGE,
    NULL,
    {255, 255, 255, 100},
    {0, 0, 0, 0},
    {255, 255, 255, 100},
    {255, 255, 255, 100},
    0
};
static UI_single_line_input_box_theme g_wgui_cat2001_singleline_inputbox_theme = { 
    &g_wgui_cat2001_inputbox_BG_filler,
    &g_wgui_cat2001_inputbox_BG_filler,
    &g_wgui_cat2001_inputbox_BG_filler,
    {0, 0, 0, 100},
    {128, 128, 128, 100},
    {0, 0, 0, 100},
    {255, 255, 255, 100},
    {51, 88, 171, 100},
    {255, 0, 0, 100},
    &UI_DEFAULT_FONT,
    1,
    UI_SINGLE_LINE_INPUT_BOX_CENTER_Y,
    '*'
};


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_redraw_counter
 * DESCRIPTION
 *  Show the counter of the info-bar 
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat2001_redraw_counter(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if !defined(__MMI_TOUCH_SCREEN__)
    stFontAttribute *f = &MMI_small_font;
#else /* !defined(__MMI_TOUCH_SCREEN__) */ 
    stFontAttribute *f = &MMI_medium_font;
#endif /* !defined(__MMI_TOUCH_SCREEN__) */ 
    S32 w, h;
    UI_character_type str[32];
    color c;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer(); 
    
    gui_reset_text_clip();

    gui_sprintf(str, "%d/%d", g_wgui_cat2001_buf_used_size, (wgui_singleline_inputbox_buffer_size - 1));
    c = *current_MMI_theme->remaining_length_text_color;
    gui_set_font(f);
    gui_set_text_color(c);
    
    gui_measure_string(str, &w, &h);

    if(r2lMMIFlag)
    {
        gui_move_text_cursor(
            UI_device_width - 4, 
            MMI_singleline_inputbox.y - ((WGUI_CAT2001_INFO_BAR_HEIGHT + h)>>1));
    }
    else
    {
    gui_move_text_cursor(
        UI_device_width - w - 4, 
        MMI_singleline_inputbox.y - ((WGUI_CAT2001_INFO_BAR_HEIGHT + h)>>1));
    }

    gui_print_text(str);

    gdi_layer_unlock_frame_buffer();
    gui_BLT_double_buffer(0, MMI_singleline_inputbox.y - WGUI_CAT2001_INFO_BAR_HEIGHT, UI_device_width - 1, MMI_singleline_inputbox.y);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_redraw_information_bar
 * DESCRIPTION
 *  Show information bar 
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat2001_redraw_information_bar(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle cat2001_active_layer;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer(); 

    /* draw the background of the info-bar and singleline inputbox */  
    gui_fill_rectangle(
		0, 
		MMI_singleline_inputbox.y - WGUI_CAT2001_INFO_BAR_HEIGHT, 
		UI_device_width - 1, 
		MMI_singleline_inputbox.y - 1,
		WGUI_CAT2001_BG_COLOR);

    /* show the inputbox border */
    gdi_draw_rect(
        MMI_singleline_inputbox.x - 1,
        MMI_singleline_inputbox.y - 1,
        MMI_singleline_inputbox.x + MMI_singleline_inputbox.width,
        MMI_singleline_inputbox.y + MMI_singleline_inputbox.height,
        WGUI_CAT2001_BORDER_COLOR);

    /* show the info-bar border */
    gdi_draw_line(
		0, 
		MMI_singleline_inputbox.y - WGUI_CAT2001_INFO_BAR_HEIGHT - 1, 
		UI_device_width - 1, 
		MMI_singleline_inputbox.y - WGUI_CAT2001_INFO_BAR_HEIGHT - 1,
		WGUI_CAT2001_BORDER_COLOR);

    /* show the IME icon */
    mmi_imc_draw_input_mode_infor(
        UI_device_width - mmi_imc_get_ime_infor_width() - WGUI_CAT2001_COUNTER_MAX_WIDTH, 
        MMI_singleline_inputbox.y - ((WGUI_CAT2001_INFO_BAR_HEIGHT + WGUI_CAT2001_INPUT_MODE_ICON_MAX_HEIGHT)>>1) - 1, 
        UI_device_width - WGUI_CAT2001_COUNTER_MAX_WIDTH,
        MMI_singleline_inputbox.y - ((WGUI_CAT2001_INFO_BAR_HEIGHT - WGUI_CAT2001_INPUT_MODE_ICON_MAX_HEIGHT)>>1) - 1);

    /* show the logo of info-bar */
    gdi_layer_get_active(&cat2001_active_layer);
    gdi_push_and_set_alpha_blending_source_layer(cat2001_active_layer);
    gui_show_image(2, MMI_singleline_inputbox.y - WGUI_CAT2001_INFO_BAR_HEIGHT + 1, g_wgui_cat2001_info_bar_icon);
    gdi_pop_and_restore_alpha_blending_source_layer();

    /* show the counter */
#ifndef __MMI_MAINLCD_128X160__
    wgui_cat2001_redraw_counter();
#endif

    gdi_layer_unlock_frame_buffer();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_resize_and_draw
 * DESCRIPTION
 *  1. Move singleline inputbox based on IME.
 *  2. Redraw the singleline inputbox, and information bar.
 * PARAMETERS
 *  virtual_keyboard_h            [IN]          Height of virtual keyboard
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat2001_resize_and_draw(S32 virtual_keyboard_h)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 singleline_y;
    S32 gap;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();    

#ifdef __MMI_VIRTUAL_KEYBOARD__
    gap = (virtual_keyboard_h <= 2) ? 2 : 0 /* border */;
#else
    gap = 2;
#endif
    
    /* set singleline inputbox position */
    singleline_y = UI_device_height - MMI_BUTTON_BAR_HEIGHT - virtual_keyboard_h - gap - MMI_SINGLELINE_INPUTBOX_HEIGHT - 1;
    move_singleline_inputbox((UI_device_width - MMI_SINGLELINE_INPUTBOX_WIDTH) >> 1, singleline_y); 

    /* clear the background */  
    gdi_draw_solid_rect(
        0, 
        MMI_content_y, 
        UI_device_width - 1, 
        MMI_singleline_inputbox.y - WGUI_CAT2001_INFO_BAR_HEIGHT, 
        GDI_COLOR_TRANSPARENT);

    /* draw the background of the singleline inputbox */  
    if (gap == 0)
    {
        gui_fill_rectangle(
            0, 
            MMI_singleline_inputbox.y, 
            UI_device_width - 1, 
            UI_device_height - MMI_BUTTON_BAR_HEIGHT - virtual_keyboard_h,
            WGUI_CAT2001_BG_COLOR);
    }
    else
    {
        gui_fill_rectangle(
            0, 
            MMI_singleline_inputbox.y, 
            UI_device_width - 1, 
            MMI_singleline_inputbox.y + MMI_SINGLELINE_INPUTBOX_HEIGHT + gap,
            WGUI_CAT2001_BG_COLOR);
    }

    /* show the singleline inputbox */
    show_singleline_inputbox();

    /* show the info-bar */
    wgui_cat2001_redraw_information_bar();
    
    gdi_layer_unlock_frame_buffer();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_draw_virtual_keypad_background
 * DESCRIPTION
 *  Draw the virtual keypad area by IME.
 * PARAMETERS
 *  x1      [IN]        start X
 *  y1      [IN]        start Y
 *  x2      [IN]        end X
 *  y2      [IN]        end Y
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat2001_draw_virtual_keypad_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gdi_layer_set_clip(x1, y1, x2, y2);
    gui_fill_rectangle(x1, y1, x2, y2, WGUI_CAT2001_BG_COLOR);
    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_draw_ctrl_area
 * DESCRIPTION
 *  For IME redraw.
 * PARAMETERS
 *  coordinate   [IN]  Unused.
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat2001_draw_ctrl_area(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_imc_redraw_screen_by_state();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_initialize_counter
 * DESCRIPTION
 *  Function to take only buffer upto limit
 * PARAMETERS
 *  buffer      [IN/OUT]        To change the string buffer to the passed size
 * RETURNS
 *  S32         The used buffer size.
 *****************************************************************************/
static S32 wgui_cat2001_initialize_counter(U8 *buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i = 0;
    U8 char_len;
    U16 ucs2_char;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat2001_buf_used_size = 0;
    ucs2_char = (buffer[i]) | ((buffer[i + 1] << 8));
    char_len = wgui_inputs_ucs2_to_gb_len(ucs2_char);
    while (ucs2_char && (g_wgui_cat2001_buf_used_size + char_len <= (wgui_singleline_inputbox_buffer_size - 1)))
    {
        g_wgui_cat2001_buf_used_size += char_len;
        i += ENCODING_LENGTH;
        ucs2_char = (buffer[i]) | ((buffer[i + 1] << 8));
        char_len = wgui_inputs_ucs2_to_gb_len(ucs2_char);
    }
    buffer[i] = 0;
    buffer[i + 1] = 0;

    return i;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_text_change_event_callback
 * DESCRIPTION
 *  Function to call info bar fillers
 * PARAMETERS
 *  event       [IN]        Action performed on insert, delete character or delete all
 *  C           [IN]        Character to insert or delete
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL wgui_cat2001_text_change_event_callback(gui_multi_line_input_box_change_event_enum event, U16 C)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (event)
    {
        case GUI_MULTI_LINE_INPUT_BOX_INSERT_CHAR:
            if (g_wgui_cat2001_buf_used_size + wgui_inputs_ucs2_to_gb_len(C) > (wgui_singleline_inputbox_buffer_size - 1))
            {
                result = MMI_FALSE;
            }
            else
            {
                g_wgui_cat2001_buf_used_size += wgui_inputs_ucs2_to_gb_len(C);
            }
            break;
        case GUI_MULTI_LINE_INPUT_BOX_DELETE_CHAR:
            g_wgui_cat2001_buf_used_size -= wgui_inputs_ucs2_to_gb_len(C);
            break;
        case GUI_MULTI_LINE_INPUT_BOX_DELETEALL:
            g_wgui_cat2001_buf_used_size = 0;
            break;
        case GUI_MULTI_LINE_INPUT_BOX_INSERT_STRING:
            if ((g_wgui_cat2001_buf_used_size + C) > (wgui_singleline_inputbox_buffer_size - 1))
            {
                result = MMI_FALSE;
            }
            break;
    }
    
    /* redraw infor-bar */
    wgui_cat2001_redraw_information_bar();
    
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_set_special_key_function
 * DESCRIPTION
 *  set category2001 screen special key callback function
 * PARAMETERS
 *  f       [IN]        Callback function
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat2001_set_special_key_function(void (*f) (void))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat2001_set_special_key_func = f;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_execute_special_key_function
 * DESCRIPTION
 *  execute category2001 screen special key callback function
 * PARAMETERS
 *  f       [IN]        Callback function
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat2001_reset_special_key(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat2001_set_special_key_func != NULL)
    {
        g_wgui_cat2001_set_special_key_func();
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_set_rsk_function
 * DESCRIPTION
 *  set category2001 screen right softkey callback function
 * PARAMETERS
 *  f       [IN]        Callback function
 *  k       [IN]        Key event type
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat2001_set_rsk_function(void (*f) (void), MMI_key_event_type k)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(k);
    wgui_singleline_inputbox_RSK_function = f;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_get_history_size
 * DESCRIPTION
 *  Get category2001 history size.
 * PARAMETERS
 *  void
 * RETURNS
 *  the size of history buffer
 *****************************************************************************/
static S32 wgui_cat2001_get_history_size(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (sizeof(singleline_inputbox_category_history));
}  


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_get_history
 * DESCRIPTION
 *  Get category2001 history.
 * PARAMETERS
 *  history_buffer      [IN]        History buffer
 * RETURNS
 *  hitsory buffer
 *****************************************************************************/
static U8 *wgui_cat2001_get_history(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    get_singleline_inputbox_category_history((U16) MMI_CAT2001_ID, history_buffer);
    return (history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_get_inputbox_coordinate
 * DESCRIPTION
 *  get the Y-axis of the single line inputbox, only for category2001.
 * PARAMETERS
 *  inputbox       [IN] coordinates of single line inputbox.
 * RETURNS
 *  void.
 *****************************************************************************/
void wgui_cat2001_get_inputbox_coordinate(wgui_cat_inputbox_coordinate_struct *inputbox)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inputbox->x = MMI_singleline_inputbox.x;
    inputbox->y = MMI_singleline_inputbox.y;
    inputbox->width = MMI_singleline_inputbox.width;
    inputbox->height = MMI_singleline_inputbox.height;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_exit
 * DESCRIPTION
 *  Exit category2001 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat2001_exit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    reset_small_screen();
#endif

    wgui_inputs_sl_close();
    g_wgui_cat2001_resize_and_draw_func = NULL;

    /* darken Inputbox area */
#ifdef __MMI_VIRTUAL_KEYBOARD__
    gdi_draw_darken_rect(
        0, 
        MMI_singleline_inputbox.y - WGUI_CAT2001_INFO_BAR_HEIGHT - 1, 
        UI_device_width - 1, 
        MMI_virtual_keyboard.y - 2,
        WGUI_CAT2001_DARKEN_PERCENT);
#else
    gdi_draw_darken_rect(
        0, 
        MMI_singleline_inputbox.y - WGUI_CAT2001_INFO_BAR_HEIGHT - 1, 
        UI_device_width - 1, 
        UI_device_height - MMI_SOFTKEY_HEIGHT - 1,
        WGUI_CAT2001_DARKEN_PERCENT);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat2001_show
 * DESCRIPTION
 *  This category is a small screen, and show a singleline inputbox at the bottom.
 * PARAMETERS
 *  info_bar_icon           [IN]        Logo of infomation bar.
 *  left_softkey            [IN]        Left softkey string.
 *  left_softkey_icon       [IN]        Left softkey icon.
 *  right_softkey           [IN]        Right softkey string.
 *  right_softkey_icon      [IN]        Right softkey icon.
 *  input_type              [IN]        Allowable input type for this inputbox.
 *                                      Please refer to mmi_input_type_enum(ImeGprot.h) for detail.
 *  buffer                  [OUT]       Buffer for input box
 *  buffer_size             [IN]        Buffer size for input box
 *  history_buffer          [IN]        History buffer
 *  required_input_mode_set [IN]        Allowable input mode for this inputbox.
 *                                      Please refer to mmi_input_mode_enum(ImeGprot.h) for detail.
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat2001_show(
        PU8 info_bar_icon,
        UI_string_type left_softkey,
        PU8 left_softkey_icon,
        UI_string_type right_softkey,
        PU8 right_softkey_icon,
        U32 input_type,
        U8 *buffer,
        S32 buffer_size,
        U8 *history_buffer,
        mmi_imm_input_mode_enum *required_input_mode_set,
        U32 category_flags)
{
/*----------------------------------------------------------------*/
/* Local Variables                                                */
/*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    color c = {0, 0, 0, 100};
    S32 used_buf_size;
    mmi_imm_input_mode_enum input_mode;

/*----------------------------------------------------------------*/
/* Code Body                                                      */
/*----------------------------------------------------------------*/
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    set_small_screen();
    gui_add_cleanup_hook(disable_resized_small_screen);
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 
    
#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_lock_double_buffer();
#endif 

    dm_add_softkey(left_softkey, left_softkey_icon, right_softkey, right_softkey_icon);
#ifndef __MMI_MAINLCD_320X480__
    wgui_softkey_set_is_in_popup(MMI_TRUE);
#endif 
    
    /* initialize category2001 global variable */
    g_wgui_cat2001_resize_and_draw_func = wgui_cat2001_resize_and_draw;
    g_wgui_cat2001_info_bar_icon = info_bar_icon;

    /* discard gui buffer */
    if ((history_buffer != NULL) && (category_flags & WGUI_CAT2001_HIGHLIGHT_TEXT))
    {
        input_mode = (((singleline_inputbox_category_history*)history_buffer)->ime_history).input_mode;
        mmi_imm_set_app_desired_input_mode(input_mode);
        history_buffer = NULL;
    }

    mmi_imc_disable_csk();

    /* singleline inputbox */
    wgui_inputs_sl_setup(
        MMI_singleline_inputbox_x,
        MMI_singleline_inputbox_y,
        MMI_singleline_inputbox_width,
        MMI_singleline_inputbox_height,
        buffer,
        buffer_size,
        MMI_CAT2001_ID,
        right_softkey,
        right_softkey_icon,
        input_type,
        (U8*) (history_buffer),
        MMI_FALSE);

	/* Set highlight */
    if ((history_buffer == NULL) || (category_flags & WGUI_CAT2001_HIGHLIGHT_TEXT))
    {
	    MMI_singleline_inputbox.flags |= UI_SINGLE_LINE_INPUT_BOX_WORD_HIGHLIGHT | UI_SINGLE_LINE_INPUT_BOX_AUTO_CLEAR_HIGHLIGHT_MODE;
    }
	MMI_singleline_inputbox.highlight_start_position = buffer;
	MMI_singleline_inputbox.highlight_end_position = buffer + buffer_size;
    MMI_singleline_inputbox.text_x = 1;

    gui_set_single_line_input_box_theme(&MMI_singleline_inputbox, &g_wgui_cat2001_singleline_inputbox_theme);
    mmi_imc_set_backgroud_filler(wgui_cat2001_draw_virtual_keypad_background);

    /* call the function while the text change (insert/ delete/ delete all) */
    wgui_inputs_sl_register_change_event_handler(wgui_cat2001_text_change_event_callback);

    /* set the highlight text */
    used_buf_size = wgui_cat2001_initialize_counter(buffer);
    wgui_singleline_inputbox_buffer_size = buffer_size >> 1;
    
    /* set flags for singleline editor */
    MMI_current_input_ext_type |= INPUT_TYPE_EXT_NO_SHOW_NEW_LINE_SYMBOL;

#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_unlock_double_buffer();
#endif 
    
    ExitCategoryFunction = wgui_cat2001_exit;
    dm_data.s32flags = DM_SET_NEW_LAYER_ACTIVE;

    dm_setup_category_functions(dm_redraw_category_screen, wgui_cat2001_get_history, wgui_cat2001_get_history_size);
    dm_register_category_controlled_callback(wgui_cat2001_draw_ctrl_area);
    dm_add_rectangle(c, DM_RECTANGLE_FILL_GRAYSCALE);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CAT2001_ID;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}


#ifdef __MMI_MENSTRUAL__
/* Only used in cat72(Menstrual) */
static UI_filled_area greygui_pop_up_dialog_background = 
{
    UI_FILLED_AREA_TYPE_COLOR | UI_FILLED_AREA_SINGLE_BORDER,
    UI_NULL_IMAGE,
    NULL,
    {192, 192, 192, 100},
    {0, 0, 0, 0},
    {0, 0, 0, 100},
    {50, 50, 50, 100},
    0
};

/* Only used in cat72(Menstrual) */
static UI_filled_area purplegui_pop_up_dialog_background = 
{
    UI_FILLED_AREA_TYPE_COLOR | UI_FILLED_AREA_SINGLE_BORDER,
    UI_NULL_IMAGE,
    NULL,
    {149, 43, 255, 100},
    {0, 0, 0, 0},
    {0, 0, 0, 100},
    {50, 50, 50, 100},
    0
};

/* Only used in cat72(Menstrual) */
static UI_filled_area whitegui_pop_up_dialog_background = 
{
    UI_FILLED_AREA_TYPE_COLOR | UI_FILLED_AREA_SINGLE_BORDER,
    UI_NULL_IMAGE,
    NULL,
    {255, 255, 255, 100},
    {0, 0, 0, 0},
    {0, 0, 0, 100},
    {50, 50, 50, 100},
    0
};


/*****************************************************************************
 * FUNCTION
 *  RedrawCategory72Screen
 * DESCRIPTION
 *  Redraws the category 72 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void RedrawCategory72Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x2 = 0, w = 0, h = 0;
    S8 ascii_percent[50];
    S8 uni_percent[100];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(ascii_percent, 0, 50);

    gdi_layer_reset_clip();

    if (wgui_is_wallpaper_on_bottom() == MMI_TRUE)
    {
        gdi_draw_solid_rect(
            0,
            (MMI_title_y + MMI_title_height),
            UI_device_width,
            (UI_device_height - MMI_button_bar_height - 1),
            GDI_COLOR_TRANSPARENT);
    }
    else
    {
        gui_draw_filled_area(
            0,
            (MMI_title_y + MMI_title_height),
            UI_device_width,
            (UI_device_height - MMI_button_bar_height - 1),
            &greygui_pop_up_dialog_background);
    }

    gui_draw_filled_area(
        wgui_image_clip_x1,
        wgui_image_clip_y1,
        wgui_image_clip_x2,
        wgui_image_clip_y2,
        &whitegui_pop_up_dialog_background);

    x2 = wgui_image_clip_x1 + no_of_pixel;

    gui_draw_filled_area(
        wgui_image_clip_x1,
        wgui_image_clip_y1,
        x2,
        wgui_image_clip_y2,
        &purplegui_pop_up_dialog_background);

    sprintf((PS8) ascii_percent, "%d", (S16) no_of_pixel);
    strcat((PS8) ascii_percent, (PS8) "%");
    /* gui_set_text_color(UI_COLOR_BLACK); */

    memset(uni_percent, 0, 100);
    mmi_asc_to_ucs2((PS8) uni_percent, (PS8) ascii_percent);

    gui_set_font(&MMI_medium_font);
    gui_measure_string((UI_string_type) uni_percent, &w, &h);

    if (r2lMMIFlag)
    {
        gui_move_text_cursor(((UI_device_width >> 1) - 10) + w, (wgui_image_clip_y2 + 5));
    }
    else
    {
        gui_move_text_cursor(((UI_device_width >> 1) - 10), (wgui_image_clip_y2 + 5));
    }

    gui_print_text((UI_string_type) uni_percent);

    show_multiline_inputbox();

}


/*****************************************************************************
 * FUNCTION
 *  DrawCate72CategoryControlArea
 * DESCRIPTION
 *  Draws the category72 category control area
 * PARAMETERS
 *  coordinate      [IN/OUT]        Coordinates of category controlled area.
 * RETURNS
 *  void
 *****************************************************************************/
static void DrawCate72CategoryControlArea(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    UI_UNUSED_PARAMETER(coordinate);
    RedrawCategory72Screen();
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategory72Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U8 *message,
        S32 percentage_value,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 l, fh;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);
    gdi_layer_lock_frame_buffer();

    wgui_title_set_menu_shortcut_number(-1);
    dm_add_softkey(
        get_string(left_softkey), 
        get_image(left_softkey_icon), 
        get_string(right_softkey), 
        get_image(right_softkey_icon));

    dm_add_title(get_string(title), get_image(title_icon));

    MMI_message_string = (UI_string_type) message;
    l = gui_strlen(MMI_message_string);
    wgui_inputs_ml_create_set_buffer(MMI_message_string, l, l, 0);
    MMI_multiline_inputbox.flags |=
        (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY |
         UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND | UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR);
    wgui_inputs_ml_move(0, (MMI_title_y + MMI_title_height) + 2);
    wgui_inputs_ml_resize(MMI_multiline_inputbox.width, MMI_content_height);
    wgui_inputs_ml_show_no_draw();
    gui_set_font(MMI_multiline_inputbox.text_font);
    fh = wgui_inputs_ml_get_line_height();
    wgui_inputs_ml_resize(
        MMI_multiline_inputbox.width,
        (MMI_multiline_inputbox.n_lines * fh) + MULTILINE_INPUTBOX_HEIGHT_PAD + MMI_multiline_inputbox.text_y);

    wgui_image_clip_x1 = ((UI_device_width >> 1) - 50);
    wgui_image_clip_y1 = (U16) (MMI_multiline_inputbox.y + MMI_multiline_inputbox.height);
    wgui_image_clip_x2 = ((UI_device_width >> 1) + 50);
    wgui_image_clip_y2 = (wgui_image_clip_y1 + 20);

    no_of_pixel = percentage_value;

    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = MMI_dummy_function;
    dm_setup_category_functions(dm_redraw_category_screen, dm_get_category_history, dm_get_category_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY72_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    dm_setup_data(&dm_data);
    dm_register_category_controlled_callback(DrawCate72CategoryControlArea);
    dm_redraw_category_screen();
}
#endif /* __MMI_MENSTRUAL__ */ 


static MMI_BOOL g_wgui_cat79_need_scroll_title = MMI_TRUE;
/*****************************************************************************
* FUNCTION
*  wgui_cat074_change_text
* DESCRIPTION
*  Change the content of string used in category74.
* PARAMETERS
*  new_string      [IN]        New content of string
* RETURNS
*  void
*****************************************************************************/
void wgui_cat074_change_text(U8 *new_string, S32 buffer_size, MMI_BOOL is_reset_y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeCategory79MessageString(new_string, buffer_size, is_reset_y, MMI_TRUE, MMI_FALSE);
} 


/*****************************************************************************
* FUNCTION
*  ChangeCategory74MessageString
* DESCRIPTION
*  Change the content of string used in category74.
* PARAMETERS
*  new_string      [IN]        New content of string
* RETURNS
*  void
*****************************************************************************/
void ChangeCategory74MessageString(U8 *new_string, S32 buffer_size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_cat074_change_text(new_string, buffer_size, MMI_TRUE);
} 


/*****************************************************************************
* FUNCTION
*  wgui_cat79_get_visible_count_bg
* DESCRIPTION
*  typesetting without display.
* PARAMETERS
*  new_string      [IN]        New content of string
*  buffer_size     [IN]        string buffer size
*  scroll_flag     [IN]        Need scroll-bar or not
*  start           [OUT]       The first character in visibel area
*  end             [OUT]       The last character in visibel area
* RETURNS
*  void
*****************************************************************************/
void wgui_cat79_get_visible_count_bg(
        U8 *new_string, 
        S32 buffer_size, 
        MMI_BOOL scroll_flag,
        S32 *start, 
        S32 *end)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    multi_line_input_box cat74_inputbox;
    dm_coordinates gui_multiline_get_coordinates;
    S32 l;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    l = gui_strlen((UI_string_type) new_string);

    dm_get_control_coordinates_from_category(
        -1,
        MMI_CATEGORY74_ID,
        DM_MULTILINE_INPUTBOX1,
        -1,
        &gui_multiline_get_coordinates);
    
    gui_create_multi_line_input_box_set_buffer(
        &cat74_inputbox,
        gui_multiline_get_coordinates.s16X,
        gui_multiline_get_coordinates.s16Y,
        gui_multiline_get_coordinates.s16Width,
        gui_multiline_get_coordinates.s16Height,
        (UI_string_type) new_string,
        buffer_size * 2,
        (l + 1) * 2,
        0);

    if (scroll_flag == MMI_FALSE)
    {
        cat74_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR;
        cat74_inputbox.ext_flags |= GUI_MULTI_LINE_INPUT_BOX_ONLY_VISIBLE_LINE;
    }
    cat74_inputbox.flags |= (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE);

    cat74_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_DRAW;
    gui_show_multi_line_input_box(&cat74_inputbox);
    cat74_inputbox.flags &= ~UI_MULTI_LINE_INPUT_BOX_DISABLE_DRAW;

    *start = cat74_inputbox.visible_start;
    *end = cat74_inputbox.visible_end;
    return; 
}


/*****************************************************************************
* FUNCTION
*  ChangeCategory79MessageString
* DESCRIPTION
*  Change the content of string used in category74.
* PARAMETERS
*  new_string      [IN]        New content of string
*  buffer_size     [IN]        string buffer size
*  is_reset_y      [IN]        whether to keep the position of scroll-bar
* RETURNS
*  void
*****************************************************************************/
void ChangeCategory79MessageString(U8 *new_string, S32 buffer_size, MMI_BOOL is_reset_y, MMI_BOOL need_scrollbar, MMI_BOOL is_r2l_display)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 l;
    S32 old_text_offset;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    
#ifdef __MMI_TOUCH_SCREEN__
    gui_multi_line_input_box_scroll_timer_hdlr();
#endif

    l = gui_strlen((UI_string_type) new_string);
    old_text_offset = MMI_multiline_inputbox.text_offset_y;
    
    gui_create_multi_line_input_box_set_buffer(
        &MMI_multiline_inputbox,
        MMI_multiline_inputbox.x,
        MMI_multiline_inputbox.y,
        MMI_multiline_inputbox.width,
        MMI_multiline_inputbox.height,
        (UI_string_type) new_string,
        buffer_size * 2,
        (l + 1) * 2,
        0);
    
    if (is_reset_y == MMI_FALSE)
    {
        MMI_multiline_inputbox.text_offset_y = old_text_offset;
    }
    
    if (need_scrollbar == MMI_FALSE)
    {
        MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR;
        MMI_multiline_inputbox.ext_flags |= GUI_MULTI_LINE_INPUT_BOX_ONLY_VISIBLE_LINE;
    }

    MMI_multiline_inputbox.override_direction = is_r2l_display ? 2 : 1;
    MMI_multiline_inputbox.flags |= (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE);
#ifdef __MMI_WALLPAPER_ON_BOTTOM__ 
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_TRANSPARENT_BACKGROUND;
#endif
    wgui_show_inputbox();
    gdi_layer_unlock_frame_buffer();
    
    gdi_layer_blt_previous(0, 0, MAIN_LCD_DEVICE_WIDTH, MAIN_LCD_DEVICE_HEIGHT);
} 


/*****************************************************************************
 * FUNCTION
*  ChangeCategory79Title
* DESCRIPTION
*  Change the content of string used in category74.
* PARAMETERS
*  new_string      [IN]        New content of string
*  buffer_size     [IN]        string buffer size
*  is_reset_y      [IN]        whether to keep the position of scroll-bar
* RETURNS
*  void
*****************************************************************************/
void ChangeCategory79Title(UI_string_type title, U16 title_icon)
{
    wgui_title_change(title_icon, 0, (U8*) title, WGUI_TITLE_CHANGE_ICON|WGUI_TITLE_CHANGE_TEXT);
    wgui_title_show(GUI_TITLE_PART_ALL);
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory74Screen
 * DESCRIPTION
 *  Displays the category74 screen
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the Left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  buffer                  [IN]        Buffer the input box should use
 *  buffer_size             [IN]        Size of the buffer
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory74Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U8 *buffer,
        S32 buffer_length,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* the title should not scroll in category74 */
    g_wgui_cat79_need_scroll_title = MMI_FALSE;
    ShowCategory79Screen(
        get_string(title),
        get_image(title_icon),
        get_string(left_softkey),
        get_image(left_softkey_icon),
        get_string(right_softkey),
        get_image(right_softkey_icon),
        MMI_TRUE,
        MMI_FALSE,
        buffer,
        buffer_length,
        history_buffer);
}   /* end of ShowCategory79Screen */


/*****************************************************************************
 * FUNCTION
 *  ShowCategory79Screen
 * DESCRIPTION
 *  Displays the category79 screen, 
 *  category79 is a text viewer screen, and the text-scroll can be disable by "need_scrollbar"
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the Left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  need_scrollbar          [IN]        Text-scroll is allowed or not 
 *  buffer                  [IN]        Buffer the input box should use
 *  buffer_size             [IN]        Size of the buffer
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory79Screen(
        UI_string_type title,
        PU8 title_icon,
        UI_string_type left_softkey,
        PU8 left_softkey_icon,
        UI_string_type right_softkey,
        PU8 right_softkey_icon,
        MMI_BOOL need_scrollbar,
        MMI_BOOL is_r2l_display,
        UI_buffer_type buffer,
        S32 buffer_length,
        UI_buffer_type history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 l;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    wgui_title_set_menu_shortcut_number(-1);
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    dm_add_softkey(left_softkey, left_softkey_icon, right_softkey, right_softkey_icon);

    dm_add_title(title, title_icon);

    l = gui_strlen((UI_string_type) buffer);
    create_multiline_inputbox_set_buffer((UI_string_type) buffer, buffer_length, l, 0);

    if (need_scrollbar)
    {
    register_multiline_inputbox_viewer_keys();
    }
    else
    {
        MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR;
        MMI_multiline_inputbox.ext_flags |= GUI_MULTI_LINE_INPUT_BOX_ONLY_VISIBLE_LINE;
    }

    MMI_multiline_inputbox.override_direction = (U8)is_r2l_display ? 2 : 1;
    MMI_multiline_inputbox.flags |= (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE);
#ifdef __MMI_WALLPAPER_ON_BOTTOM__ 
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_TRANSPARENT_BACKGROUND;
    dm_get_scr_bg_opacity(&idle_scr_bg_opacity);
    dm_set_scr_bg_opacity((U8)(current_MMI_theme->bg_opacity_low));
#endif 

    set_multiline_inputbox_category_history(MMI_CATEGORY74_ID, history_buffer);
    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = ExitCategory74Screen;
    dm_setup_category_functions(dm_redraw_category_screen, dm_get_category_history, dm_get_category_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY74_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    if (g_wgui_cat79_need_scroll_title == MMI_TRUE)
    {
        dm_data.s32flags |= DM_SCROLL_TITLE;
    }
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}   /* end of ShowCategory74Screen */


/*****************************************************************************
 * FUNCTION
 *  ExitCategory74Screen
 * DESCRIPTION
 *  Exits the category74 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory74Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    reset_softkeys();
    reset_multiline_inputbox();
#ifdef __MMI_WALLPAPER_ON_BOTTOM__ 
    dm_set_scr_bg_opacity(idle_scr_bg_opacity);
#endif 
    g_wgui_cat79_need_scroll_title = MMI_TRUE;
}   /* end of ExitCategory74Screen */

#ifdef __MMI_EBOOK_READER__
#ifdef __MMI_TOUCH_SCREEN__
S32 MMI_content_height_prev;
S32 MMI_content_y_prev;
#endif /* __MMI_TOUCH_SCREEN__ */ 


/*****************************************************************************
 * FUNCTION
 *  ShowCategory75Screen
 * DESCRIPTION
 *  Displays the category75 screen(normal ebook viewer)
 * PARAMETERS
 *  name                    [IN]        Title string
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the Left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  buffer                  [IN]        Buffer the input box should use
 *  buffer_size             [IN]        Size of the buffer
 *  history_buffer          [IN]        History buffer
 *  stop_scroll_callback    [IN]        Stop scroll callback function
 *  page_info_app           [IN]        Info of page
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory75Screen(
        U16 *name,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U8 *buffer,
        S32 buffer_size,
        U8 *history_buffer,
        void (*stop_scroll_callback)(void),
        gui_page_info_app **page_info_app)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 l;
    gui_page_info_app *page_info_d = *page_info_app;
    dm_coordinates gui_multiline_get_coordinates;
    S32 shortcut_width;
#if defined(__MMI_TOUCH_SCREEN__)
    const gui_virtual_keyboard_pen_enum disable_backspace_list[] = {GUI_VKBD_PEN_BAKSPACE, GUI_VKBD_PEN_NONE};
#endif /* defined(__MMI_TOUCH_SCREEN__) */ 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Show shortcut when fullscreen backgournd */
    wgui_title_set_no_icon_shct(MMI_TRUE);
#ifdef __MMI_TOUCH_SCREEN__
    wgui_paging_set_full_screen_flag(FALSE);
#endif 
    dm_get_control_coordinates_from_category(
        -1,
        MMI_CATEGORY74_ID,
        DM_MULTILINE_INPUTBOX1,
        -1,
        &gui_multiline_get_coordinates);
/* 061507 128x160 touch Start */
#ifdef __MMI_TOUCH_SCREEN__
    //gui_multiline_get_coordinates.s16Height = gui_multiline_get_coordinates.s16Height - MMI_title_y - 4;
#endif 
    //wgui_dm_set_multiline_data(&gui_multiline_get_coordinates);
    gui_lock_double_buffer();
    MMI_multiline_inputbox.jump_to_offset_flag = 0;
    wgui_title_set_menu_shortcut_number(-1);
    shortcut_width = set_menu_item_count(100)+7;
    resize_menu_shortcut_handler(shortcut_width, MMI_title_height);
    wgui_title_disable_menu_shortcut_display(MMI_FALSE);
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    SetupCategoryKeyHandlers();

    MMI_title_string = (UI_string_type) name;
    MMI_title_icon = (PU8) get_image(title_icon);

    //l = gui_strlen((UI_string_type) buffer);
    //create_multiline_inputbox_set_buffer((UI_string_type) buffer, buffer_size, l, 0);
#ifdef __MMI_TOUCH_SCREEN__
    if (page_info_d->key_callback != NULL)
    {
        mmi_imm_set_events(MMI_FALSE, disable_backspace_list);
        mmi_imm_set_required_mode_list(IMM_INPUT_TYPE_NUMERIC, NULL, IMM_INPUT_MODE_123); //Need to be modified
        g_mmi_editor_hanler.input_box_type = MMI_EDITOR_MULTILINE_INPUT_BOX;
        g_mmi_editor_hanler.input_box_sub_type = MMI_EDITOR_PAGING_IN_MULTLINE_INPUT_BOX;
        g_mmi_editor_hanler.input_box_handler = &MMI_multiline_inputbox;
        mmi_imc_disable_handwriting();
        mmi_imc_disable_key_input();
        mmi_imc_connect((void *)&g_mmi_editor_hanler, mmi_input_box_msg_call_back_multiline);
        gui_multiline_get_coordinates.s16Height = gui_multiline_get_coordinates.s16Height - mmi_imc_get_vk_area_height();
    }
#endif /* __MMI_TOUCH_SCREEN__ */ 

    g_mmi_editor_hanler.input_box_sub_type = MMI_EDITOR_PAGING_IN_MULTLINE_INPUT_BOX;

    wgui_dm_set_multiline_data(&gui_multiline_get_coordinates);
    l = gui_strlen((UI_string_type) buffer);
    create_multiline_inputbox_set_buffer((UI_string_type) buffer, buffer_size, l, 0);
/* 061507 128x160 touch End */

    wgui_paging_multiline_inputbox_set_stop_scroll_callback((void*)stop_scroll_callback);
    wgui_paging_multiline_set_page(page_info_d->start_id, page_info_d->end_id);
    wgui_paging_multiline_set_font(page_info_d->font_size, page_info_d->font_style);

    register_multiline_inputbox_viewer_keys();
    MMI_multiline_inputbox.flags |= (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE);  /* |UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND); */

    if (page_info_d->highlight_string == 1)
    {
        MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_WORD_HIGHLIGHT;
        wgui_paging_highlight_search_string(page_info_d->jump_offset_from_app, page_info_d->search_str_len);
    }
#ifdef __MMI_WALLPAPER_ON_BOTTOM__ 
    dm_get_scr_bg_opacity(&idle_scr_bg_opacity);
    dm_set_scr_bg_opacity((U8)(current_MMI_theme->bg_opacity_low));
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_TRANSPARENT_BACKGROUND;
#endif 
    MMI_multiline_inputbox.ext_flags |= GUI_MULTI_LINE_INPUT_BOX_VIEW_PAGING_MODE;
    MMI_multiline_inputbox.page_offset = page_info_d->text_offset;
    if (!page_info_d->fixed_view_flag)
        MMI_multiline_inputbox.jump_offset_from_app = page_info_d->jump_offset_from_app;
    else
        MMI_multiline_inputbox.jump_offset_from_app = 0;
    MMI_multiline_inputbox.search_flag_is_on = page_info_d->search_flag_is_on;
    MMI_multiline_inputbox.size_of_total_data = page_info_d->doc_size;
    MMI_multiline_inputbox.override_direction = page_info_d->override_direction ? 2 : 1;
    show_multiline_inputbox_no_draw();

    wgui_paging_set_scrollbar_range(page_info_d->doc_size);
    /* PMT MMSVIEWER */
    wgui_paging_multiline_set_get_page_callback(page_info_d->get_page_cb);                    

    set_multiline_inputbox_category_history(MMI_CATEGORY74_ID, history_buffer);

    ExitCategoryFunction = ExitCategory75Screen;
    wgui_paging_multiline_set_scroll_info(&page_info_d);
    wgui_paging_set_show_percentage_flag();
    if(old_font_size != page_info_d->font_size || old_font_style != page_info_d->font_style)
        wgui_paging_multiline_clear_last_percentage();

    if (old_font_size == page_info_d->font_size && old_font_style == page_info_d->font_style)
    {
        if (page_info_d->text_offset != 0 || page_info_d->fixed_view_flag)
        {
            if (MMI_multiline_inputbox.text_offset_y != page_info_d->last_text_offset_y)
            {
                MMI_multiline_inputbox.text_offset_y = page_info_d->last_text_offset_y;
            }
        } 
    }

    if (page_info_d->text_offset)
    {
        wgui_paging_multiline_set_percentage(page_info_d->start_id, page_info_d->text_offset);
		
        if (MMI_multiline_inputbox.edit_height >= MMI_multiline_inputbox.text_height)
        {
            wgui_paging_multiline_set_percentage(page_info_d->start_id, 0);
        }
    }
    else
    {
        show_multiline_inputbox_no_draw();
        if (MMI_multiline_inputbox.search_flag_is_on)
        {
            show_multiline_inputbox_no_draw();
            if (!page_info_d->fixed_view_flag)
                wgui_paging_multiline_set_percentage(page_info_d->start_id, (S16)MMI_multiline_inputbox.text_offset);
            else
                wgui_paging_multiline_inputbox_set_percentage_scale(page_info_d->last_showed_percentage);
        }
        else
        {
            wgui_paging_multiline_set_percentage(page_info_d->start_id, page_info_d->jump_offset_from_app);
        }
    }
    if (page_info_d->jump_to_end == 0)
    {
        show_multiline_inputbox_no_draw();
        wgui_paging_jump_to_end();
        wgui_paging_multiline_inputbox_set_percentage_scale(COMPLETE_PERCENTAGE_SCALE);
    }

    gui_unlock_double_buffer();

    old_font_size = page_info_d->font_size;
    old_font_style = page_info_d->font_style;

#ifdef __MMI_TOUCH_SCREEN__
    dm_register_category_controlled_callback(RedrawCategoryControlledArea75Screen);
    wgui_register_category_screen_control_area_pen_handlers(wgui_paging_pen_down_hdlr, MMI_PEN_EVENT_DOWN);
    wgui_register_category_screen_control_area_pen_handlers(wgui_paging_pen_up_hdlr, MMI_PEN_EVENT_UP);
    wgui_register_category_screen_control_area_pen_handlers(wgui_paging_pen_move_hdlr, MMI_PEN_EVENT_MOVE);
#endif /* __MMI_TOUCH_SCREEN__ */ 
    dm_setup_category_functions(dm_redraw_category_screen, dm_get_category_history, dm_get_category_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
#ifdef __MMI_TOUCH_SCREEN__
    dm_data.s32CatId = MMI_CATEGORY75_ID;
#else 
    dm_data.s32CatId = MMI_CATEGORY74_ID;
#endif 
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
#ifdef __MMI_TOUCH_SCREEN__
    if (page_info_d->key_callback != NULL)
    {
        dm_data.s32flags |= DM_SHOW_VKPAD;
        dm_register_vkpad_callback(wgui_paging_virtual_keypad_callback);
    }
#endif /* __MMI_TOUCH_SCREEN__ */ 
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();

#ifdef __MMI_TOUCH_SCREEN__
    mmi_pen_reset();
#endif
    MMI_multiline_inputbox.page_offset = MMI_multiline_inputbox.jump_offset_from_app = 0;

    /* wgui_paging_multiline_set_scroll_info(&page_info_d); */
    if (page_info_d->scroll_flag == WGUI_PAGING_AUTO_SCROLL_ON && page_info_d->scroll_speed != 0)
    {
        wgui_paging_start_text_scroll();
    }
    else
    {
        wgui_paging_stop_text_scroll();
    }
    MMI_multiline_inputbox.flags &= ~UI_MULTI_LINE_INPUT_BOX_WORD_HIGHLIGHT;
    if (page_info_d->scroll_type == WGUI_PAGING_SCROLL_LINE_BY_LINE)
    {
        SetKeyHandler(wgui_paging_multiline_inputbox_previous_line_in_paging, KEY_UP_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(wgui_paging_multiline_inputbox_next_line_in_paging_scroll, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(wgui_paging_multiline_inputbox_previous_line_in_paging, KEY_VOL_UP, KEY_EVENT_DOWN);
        SetKeyHandler(wgui_paging_multiline_inputbox_next_line_in_paging_scroll, KEY_VOL_DOWN, KEY_EVENT_DOWN);

    }
    else
    {
        SetKeyHandler(wgui_paging_multiline_inputbox_previous_page, KEY_UP_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(wgui_paging_multiline_inputbox_next_page, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(wgui_paging_multiline_inputbox_previous_page, KEY_VOL_UP, KEY_EVENT_DOWN);
        SetKeyHandler(wgui_paging_multiline_inputbox_next_page, KEY_VOL_DOWN, KEY_EVENT_DOWN);
    }
}   /* end of ShowCategory75Screen */

#ifdef __MMI_TOUCH_SCREEN__


/*****************************************************************************
 * FUNCTION
 *  RedrawCategoryControlledArea75Screen
 * DESCRIPTION
 *  redraw function for category 75 in touch screen
 * PARAMETERS
 *  coordinate      [IN]     Area to redraw
 * RETURNS
 *  void
 *****************************************************************************/
void RedrawCategoryControlledArea75Screen(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    redraw_multiline_inputbox();
}
#endif /* __MMI_TOUCH_SCREEN__ */ 


/*****************************************************************************
 * FUNCTION
 *  ExitCategory75Screen
 * DESCRIPTION
 *  Exits the category75 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory75Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    reset_softkeys();
    reset_multiline_inputbox();
#ifdef __MMI_WALLPAPER_ON_BOTTOM__ 
    dm_set_scr_bg_opacity(idle_scr_bg_opacity);
#endif
    MMI_multiline_inputbox.previous_shared_bytes = 0;
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    wgui_paging_reset_show_percentage_flag();
    wgui_paging_stop_text_scroll();
    wgui_paging_multiline_inputbox_set_stop_scroll_callback(NULL);
#ifdef __MMI_TOUCH_SCREEN__
    mmi_imc_disconnect();
#endif 
    MMI_multiline_inputbox.ext_flags &= ~GUI_MULTI_LINE_INPUT_BOX_VIEW_PAGING_MODE;
}   /* end of ExitCategory75Screen */

#if defined(__MMI_MAINLCD_240X320__) || defined(__MMI_MAINLCD_240X400__)
    #define CAT375_INFO_BAR_HEIGHT 22
#elif defined(__MMI_MAINLCD_320X240__)
    #define CAT375_INFO_BAR_HEIGHT 22
#elif defined(__MMI_MAINLCD_320X480__)
    #define CAT375_INFO_BAR_HEIGHT 31    
#else /* defined(__MMI_MAINLCD_240X320__) */
    #define CAT375_INFO_BAR_HEIGHT 18
#endif 

MMI_BOOL g_wgui_category375_is_fullscreen;
static MMI_BOOL g_wgui_redraw_enable = 0;

/*****************************************************************************
 * FUNCTION
 *  RedrawCategory375Counter
 * DESCRIPTION
 *  Display the counter for category375
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void RedrawCategory375Counter(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2, x, y, w, h;
    UI_character_type str[32];
    color c = {255, 255, 255, 0};
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  
    gui_push_clip();

    x1 = MMI_multiline_inputbox.x;
    y1 = MMI_multiline_inputbox.y + MMI_multiline_inputbox.height;
    x2 = x1 + MMI_multiline_inputbox.width - 1;
    y2 = y1 + CAT375_INFO_BAR_HEIGHT -1;
    
    gui_set_clip(x1, y1, x2, y2);   
    gdi_draw_rect(x1, y1, x2, y2, GDI_COLOR_BLACK);
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_GRAY);
    wgui_inputs_ml_linebase_get_percentage(str);

    gui_set_font(&MMI_medium_font);
    gui_measure_string(str, &w, &h);
    y = y1 + (CAT375_INFO_BAR_HEIGHT - h)/2;

    if (r2lMMIFlag)
        x = x1 + w + 1;
    else
        x = x2 - w - 1;

    gui_move_text_cursor(x, y);
    gui_set_text_color(c);
    gui_set_font(&MMI_medium_font);
    gui_print_text(str);

#if(UI_DOUBLE_BUFFER_SUPPORT)
    gui_BLT_double_buffer(x1,y1,x2,y2);
#endif /* (UI_DOUBLE_BUFFER_SUPPORT) */     
    gui_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  get_category375_inputbox_coordinate
 * DESCRIPTION
 *  get the inputbox position of category375
 * PARAMETERS
 *  x             [OUT]
 *  y             [OUT]
 *  width         [OUT]
 *  height        [OUT]
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_category375_get_inputbox_and_counter_size(S32 *x, S32 *y, S32 *width, S32 *height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  
    *x = MMI_multiline_inputbox.x;
    *y = MMI_multiline_inputbox.y;
    *width = MMI_multiline_inputbox.width;
    *height = MMI_multiline_inputbox.height + CAT375_INFO_BAR_HEIGHT;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_category375_resize_inputbox_and_counter
 * DESCRIPTION
 *  get the inputbox position of category375
 * PARAMETERS
 *  x             [OUT]
 *  y             [OUT]
 *  width         [OUT]
 *  height        [OUT]
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_category375_resize_inputbox_and_counter(multi_line_input_box *b, S32 width, S32 height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  
    if(g_wgui_category375_is_fullscreen)
    {
        gui_resize_multi_line_input_box_no_draw(b, width, height);
    }
    else
    {
        gui_resize_multi_line_input_box_no_draw(b, width, height - CAT375_INFO_BAR_HEIGHT);
    }
}

/*****************************************************************************
 * FUNCTION
 *  wgui_category375_redraw_inputbox_and_counter
 * DESCRIPTION
 *  get the inputbox position of category375
 * PARAMETERS
 *  x             [OUT]
 *  y             [OUT]
 *  width         [OUT]
 *  height        [OUT]
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_category375_redraw_inputbox_and_counter(void)
{
        /*----------------------------------------------------------------*/
        /* Local Variables                                                */
        /*----------------------------------------------------------------*/
        
        /*----------------------------------------------------------------*/
        /* Code Body                                                      */
        /*----------------------------------------------------------------*/  
        gui_push_clip();
        gui_set_clip(
            MMI_multiline_inputbox.x, 
            MMI_multiline_inputbox.y, 
            MMI_multiline_inputbox.width- 1, 
            MMI_multiline_inputbox.height + CAT375_INFO_BAR_HEIGHT - 1);   
        
		if (g_wgui_redraw_enable)
			redraw_multiline_inputbox(); 
        
        if(g_wgui_category375_is_fullscreen == MMI_FALSE)
        {
            RedrawCategory375Counter(); 
        }
        
        gui_pop_clip();

}


/*****************************************************************************
 * FUNCTION
 *  wgui_category375_redraw_inputbox_and_counter
 * DESCRIPTION
 *  get the inputbox position of category375
 * PARAMETERS
 *  x             [OUT]
 *  y             [OUT]
 *  width         [OUT]
 *  height        [OUT]
 * RETURNS
 *  void
 *****************************************************************************/

void RedrawCategoryControlledArea375Screen(dm_coordinates *coordinate)
{
/*
    gui_push_clip();
    gui_set_clip(
        coordinate->s16X, 
        coordinate->s16Y, 
        coordinate->s16X + coordinate->s16Width - 1, 
        coordinate->s16Y + coordinate->s16Height - 1);   

    redraw_multiline_inputbox(); 

    if(g_wgui_category375_is_fullscreen == MMI_FALSE)
    {
        RedrawCategory375Counter(); 
    }
    
    gui_pop_clip();
    */
	g_wgui_redraw_enable = MMI_TRUE;
    mmi_imc_redraw_screen_by_state();
	g_wgui_redraw_enable = MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory375Screen
 * DESCRIPTION
 *  Exits the category75 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory375Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    reset_softkeys();
    reset_multiline_inputbox();

    wgui_inputs_ml_linebase_stop_text_scroll();
    wgui_inputs_ml_linebase_set_stop_scroll_callback(NULL);
    wgui_inputs_ml_linebase_set_percentage_callback((void*)NULL);
    mmi_imm_reset_allowed_and_disabled_list();
    
    if(g_wgui_category375_is_fullscreen)
    {
        MMI_content_height -= MMI_softkey_height;
    }

#ifdef __MMI_WALLPAPER_ON_BOTTOM__ 
        dm_set_scr_bg_opacity(idle_scr_bg_opacity);
#endif

    mmi_imc_disconnect();

    MMI_multiline_inputbox.ext_flags &= ~GUI_MULTI_LINE_INPUT_BOX_CONTENT_REQUEST_MODE;
}   /* end of ExitCategory75Screen */
/*
void gui_temp_bg_update(void)
{
    S32 n;
    
    n = MMI_multiline_inputbox.total_line_count + 10;

    if (n>100)
    {
        wgui_inputs_ml_set_total_line_count(100, 1);
    }
    else
    {
        wgui_inputs_ml_set_total_line_count(n, 1);
        gui_start_timer(1000, gui_temp_bg_update);
    }
}*/


/*****************************************************************************
 * FUNCTION
 *  ShowCategory375Screen
 * DESCRIPTION
 *  Displays the linebased category75 screen(normal ebook viewer)
 * PARAMETERS
 *  name                    [IN]        Title string
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the Left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  buffer                  [IN]        Buffer the input box should use
 *  buffer_size             [IN]        Size of the buffer
 *  history_buffer          [IN]        History buffer
 *  stop_scroll_callback    [IN]        Stop scroll callback function
 *  page_info_app           [IN]        Info of page
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory375Screen(
        U16 *name,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U8 *history_buffer,
        void (*stop_scroll_callback)(void),
        wgui_ml_line_base_info **page_info_app,
        MMI_BOOL is_fullscreen)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S16 input_type = 0;
    wgui_ml_line_base_info *page_info_d = *page_info_app;
    dm_coordinates gui_multiline_get_coordinates;
#if defined(__MMI_TOUCH_SCREEN__)
    const gui_virtual_keyboard_pen_enum disable_backspace_list[] = {GUI_VKBD_PEN_BAKSPACE, GUI_VKBD_PEN_NONE};
#endif /* defined(__MMI_TOUCH_SCREEN__) */ 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_category375_is_fullscreen = is_fullscreen;
    gui_lock_double_buffer();
    if(is_fullscreen == MMI_FALSE)
    {
        dm_add_softkey(get_string(left_softkey), get_image(left_softkey_icon), get_string(right_softkey), get_image(right_softkey_icon));
        dm_add_title(name, get_image(title_icon));

        gui_multiline_get_coordinates.s16X = MMI_COMMON_CONTENT_X;
        gui_multiline_get_coordinates.s16Y = MMI_COMMON_CONTENT_Y;
        gui_multiline_get_coordinates.s16Width = MMI_COMMON_CONTENT_WIDTH;
        gui_multiline_get_coordinates.s16Height = MMI_COMMON_CONTENT_HEIGHT - CAT375_INFO_BAR_HEIGHT;
    }
    else
    {
        gui_multiline_get_coordinates.s16X = 0;
        gui_multiline_get_coordinates.s16Y = 0;
        gui_multiline_get_coordinates.s16Width = UI_DEVICE_WIDTH;
        gui_multiline_get_coordinates.s16Height = UI_DEVICE_HEIGHT;
        MMI_content_height += MMI_softkey_height;
    }

        g_mmi_editor_hanler.input_box_type = MMI_EDITOR_MULTILINE_INPUT_BOX;
        g_mmi_editor_hanler.input_box_sub_type = MMI_EDITOR_LINE_BASED_IN_MULTLINE_INPUT_BOX;
        g_mmi_editor_hanler.input_box_handler = &MMI_multiline_inputbox;
        
#ifdef __MMI_TOUCH_SCREEN__
        mmi_imm_set_events(MMI_FALSE, disable_backspace_list);
        mmi_imc_disable_handwriting();
#endif /* __MMI_TOUCH_SCREEN__ */ 
        mmi_imc_disable_key_input();
        mmi_imm_set_required_mode_list(IMM_INPUT_TYPE_NUMERIC, NULL, IMM_INPUT_MODE_123); 
        mmi_imc_connect((void *)&g_mmi_editor_hanler, mmi_input_box_msg_call_back_multiline);
        
#ifdef __MMI_TOUCH_SCREEN__
        gui_multiline_get_coordinates.s16Height -= mmi_imc_get_vk_area_height();
#endif /* __MMI_TOUCH_SCREEN__ */

    wgui_dm_set_multiline_data(&gui_multiline_get_coordinates);

    create_multiline_inputbox_set_buffer(NULL, 0, 0, 0);
    MMI_multiline_inputbox.flags |= (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE);  /* |UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND); */
    MMI_multiline_inputbox.ext_flags |= GUI_MULTI_LINE_INPUT_BOX_CONTENT_REQUEST_MODE;

    wgui_inputs_ml_linebase_init(page_info_d);
    wgui_inputs_ml_linebase_set_stop_scroll_callback((void*)stop_scroll_callback);

#ifdef __MMI_WALLPAPER_ON_BOTTOM__ 
        dm_get_scr_bg_opacity(&idle_scr_bg_opacity);
        dm_set_scr_bg_opacity((U8)(current_MMI_theme->bg_opacity_low));
        MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_TRANSPARENT_BACKGROUND;
#endif 

    /* In fullscreen, the counter should be hided */
    if(is_fullscreen == MMI_FALSE)
    {
        wgui_inputs_ml_linebase_set_percentage_callback((void*)mmi_imc_redraw_screen_by_state);
    }
    set_multiline_inputbox_category_history(MMI_CATEGORY375_ID, history_buffer);

    /* currently, we use RtoL flag to decide the direction. The final solution should be given by application */
    /*if (r2lMMIFlag)
    {
        page_info_d->override_direction = BIDI_R;
    }
    else
    {
        page_info_d->override_direction = BIDI_L;
    }*/   

    gui_unlock_double_buffer();

    dm_setup_category_functions(dm_redraw_category_screen, dm_get_category_history, dm_get_category_history_size);
    ExitCategoryFunction = ExitCategory375Screen; 

#ifdef __MMI_TOUCH_SCREEN__
    wgui_register_category_screen_control_area_pen_handlers(wgui_inputs_ml_linebase_pen_down_hdlr, MMI_PEN_EVENT_DOWN);
    wgui_register_category_screen_control_area_pen_handlers(wgui_inputs_ml_linebase_pen_up_hdlr, MMI_PEN_EVENT_UP);
    wgui_register_category_screen_control_area_pen_handlers(wgui_inputs_ml_linebase_pen_move_hdlr, MMI_PEN_EVENT_MOVE);
#endif /* __MMI_TOUCH_SCREEN__ */ 

    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    if(is_fullscreen)
    {
        dm_data.s32CatId = MMI_CATEGORY375_ID_FULLSCREEN;
    }
    else
    {
        dm_data.s32CatId = MMI_CATEGORY375_ID;
#ifdef __MMI_MAINLCD_320X240__
        dm_data.s32flags |= DM_NO_STATUS_BAR;
#endif
    }

    dm_register_category_controlled_callback(RedrawCategoryControlledArea375Screen);

    dm_setup_data(&dm_data);

    dm_redraw_category_screen();

    if (page_info_d->scroll_flag == WGUI_PAGING_AUTO_SCROLL_ON && page_info_d->scroll_speed != 0)
    {
        wgui_inputs_ml_linebase_start_auto_scroll();
    }
    else
    {
        wgui_inputs_ml_linebase_stop_text_scroll();
    }
    
    MMI_multiline_inputbox.flags &= ~UI_MULTI_LINE_INPUT_BOX_WORD_HIGHLIGHT;

    SetKeyHandler(wgui_inputs_ml_linebase_previous_page, KEY_UP_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(wgui_inputs_ml_linebase_next_page, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(wgui_inputs_ml_linebase_previous_page, KEY_VOL_UP, KEY_EVENT_DOWN);
    SetKeyHandler(wgui_inputs_ml_linebase_next_page, KEY_VOL_DOWN, KEY_EVENT_DOWN);
    SetKeyHandler(wgui_inputs_ml_linebase_previous_line, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(wgui_inputs_ml_linebase_next_line, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
}   /* end of ShowCategory75Screen */


/*****************************************************************************
 * FUNCTION
 *  ShowCategory77Screen
 * DESCRIPTION
 *  Full screen ebook viewer
 * PARAMETERS
 *  name                    [IN]        Title string
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the Left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  buffer                  [IN]        Buffer the input box should use
 *  buffer_size             [IN]        Size of the buffer
 *  history_buffer          [IN]        History buffer
 *  stop_scroll_callback    [IN]        Stop scroll callback function 
 *  page_info_app           [IN]        Info of page
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory77Screen(
        U16 *name,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U8 *buffer,
        S32 buffer_size,
        U8 *history_buffer,
        void (*stop_scroll_callback)(void),
        gui_page_info_app **page_info_app)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 l;
    gui_page_info_app *page_info_d = *page_info_app;
    dm_coordinates gui_multiline_get_coordinates;
#if defined(__MMI_TOUCH_SCREEN__)
    const gui_virtual_keyboard_pen_enum disable_backspace_list[] = {GUI_VKBD_PEN_BAKSPACE, GUI_VKBD_PEN_NONE};
#endif /* defined(__MMI_TOUCH_SCREEN__) */ 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_TOUCH_SCREEN__
    wgui_paging_set_full_screen_flag(TRUE);
    gui_multiline_get_coordinates.s16X = 0;
    gui_multiline_get_coordinates.s16Y = 0;
    gui_multiline_get_coordinates.s16Width = MAIN_LCD_DEVICE_WIDTH;
    gui_multiline_get_coordinates.s16Height = MAIN_LCD_DEVICE_HEIGHT;
    if (page_info_d->key_callback != NULL)
    {
        gui_multiline_get_coordinates.s16Height -= (MMI_title_y + 3);
    }
    MMI_content_height_prev = MMI_content_height;
    MMI_content_y_prev = MMI_content_y;
    MMI_content_y = 0;
    MMI_content_height = MAIN_LCD_DEVICE_HEIGHT;
#else /* __MMI_TOUCH_SCREEN__ */ 
    dm_get_control_coordinates_from_category(
        -1,
        MMI_CATEGORY77_ID,
        DM_MULTILINE_INPUTBOX1,
        -1,
        &gui_multiline_get_coordinates);
#endif /* __MMI_TOUCH_SCREEN__ */ 
/* 061507 128x160 touch Start */
    //wgui_dm_set_multiline_data(&gui_multiline_get_coordinates);

    gui_lock_double_buffer();
    entry_full_screen();
    wgui_title_set_menu_shortcut_number(-1);
    wgui_title_disable_menu_shortcut_display(MMI_FALSE);

    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    SetupCategoryKeyHandlers();

    MMI_title_string = (UI_string_type) name;
    MMI_title_icon = (PU8) get_image(title_icon);

    //l = gui_strlen((UI_string_type) buffer);
    //MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR;
    //create_multiline_inputbox_set_buffer((UI_string_type) buffer, buffer_size, l, 0);
#ifdef __MMI_TOUCH_SCREEN__
    if (page_info_d->key_callback != NULL)
    {
        mmi_imm_set_events(MMI_FALSE, disable_backspace_list);
        mmi_imm_set_required_mode_list(IMM_INPUT_TYPE_NUMERIC, NULL, IMM_INPUT_MODE_123); //Need to be modified
        g_mmi_editor_hanler.input_box_type = MMI_EDITOR_MULTILINE_INPUT_BOX;
        g_mmi_editor_hanler.input_box_sub_type = MMI_EDITOR_PAGING_IN_MULTLINE_INPUT_BOX;
        g_mmi_editor_hanler.input_box_handler = &MMI_multiline_inputbox;
        mmi_imc_disable_handwriting();
        mmi_imc_disable_key_input();
        mmi_imc_connect((void *)&g_mmi_editor_hanler, mmi_input_box_msg_call_back_multiline);
        gui_multiline_get_coordinates.s16Height = MAIN_LCD_DEVICE_HEIGHT - mmi_imc_get_vk_area_height();
    }
#endif /* __MMI_TOUCH_SCREEN__ */ 

    g_mmi_editor_hanler.input_box_sub_type = MMI_EDITOR_PAGING_IN_MULTLINE_INPUT_BOX;

    wgui_dm_set_multiline_data(&gui_multiline_get_coordinates);
    l = gui_strlen((UI_string_type) buffer);
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR;
    create_multiline_inputbox_set_buffer((UI_string_type) buffer, buffer_size, l, 0);
/* 061507 128x160 touch End */

    wgui_paging_multiline_inputbox_set_stop_scroll_callback((void*)stop_scroll_callback);
    wgui_paging_multiline_set_page(page_info_d->start_id, page_info_d->end_id);
    wgui_paging_multiline_set_font(page_info_d->font_size, page_info_d->font_style);
    /* PMT MMSVIEWER */
    wgui_paging_multiline_set_get_page_callback(page_info_d->get_page_cb);                    
    register_multiline_inputbox_viewer_keys();
    MMI_multiline_inputbox.flags |= (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE); 
    MMI_multiline_inputbox.ext_flags |= GUI_MULTI_LINE_INPUT_BOX_VIEW_PAGING_MODE;
    if (page_info_d->highlight_string == 1)
    {
        MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_WORD_HIGHLIGHT;
        wgui_paging_highlight_search_string(page_info_d->jump_offset_from_app, page_info_d->search_str_len);
    }

    MMI_multiline_inputbox.page_offset = page_info_d->text_offset;
    if (!page_info_d->fixed_view_flag)
        MMI_multiline_inputbox.jump_offset_from_app = page_info_d->jump_offset_from_app;
    else
        MMI_multiline_inputbox.jump_offset_from_app = 0;
    MMI_multiline_inputbox.search_flag_is_on = page_info_d->search_flag_is_on;
    MMI_multiline_inputbox.size_of_total_data = page_info_d->doc_size;
    MMI_multiline_inputbox.override_direction = page_info_d->override_direction ? 2 : 1;
    show_multiline_inputbox_no_draw();
    wgui_paging_set_scrollbar_range(page_info_d->doc_size);
    wgui_paging_reset_show_percentage_flag();
//    if (page_info_d->jump_to_end == 0)
//    {
//        wgui_paging_jump_to_end();
//    }
    set_multiline_inputbox_category_history(MMI_CATEGORY77_ID, history_buffer);

    ExitCategoryFunction = ExitCategory77Screen;
    wgui_paging_multiline_set_scroll_info(&page_info_d);
    if(old_font_size != page_info_d->font_size || old_font_style != page_info_d->font_style)
        wgui_paging_multiline_clear_last_percentage();

    if (old_font_size == page_info_d->font_size && old_font_style == page_info_d->font_style)
    {
        if (page_info_d->text_offset != 0 || page_info_d->fixed_view_flag)
        {
            if (MMI_multiline_inputbox.text_offset_y != page_info_d->last_text_offset_y)
            {
                MMI_multiline_inputbox.text_offset_y = page_info_d->last_text_offset_y;
            }
        } 
    }

    if (page_info_d->text_offset)
    {
        wgui_paging_multiline_set_percentage(page_info_d->start_id, page_info_d->text_offset);
    }
    else
    {
        show_multiline_inputbox_no_draw();
        if (MMI_multiline_inputbox.search_flag_is_on)
        {
            show_multiline_inputbox_no_draw();
            wgui_paging_multiline_set_percentage(page_info_d->start_id, (S16)MMI_multiline_inputbox.text_offset);
        }
        else
        {
            wgui_paging_multiline_set_percentage(page_info_d->start_id, page_info_d->jump_offset_from_app);
        }
    }

    old_font_size = page_info_d->font_size;
    old_font_style = page_info_d->font_style;

    if (page_info_d->jump_to_end == 0)
    {
        wgui_paging_jump_to_end();
    }
    gui_unlock_double_buffer();

#ifdef __MMI_TOUCH_SCREEN__
    dm_register_category_controlled_callback(RedrawCategoryControlledArea75Screen);
    wgui_register_category_screen_control_area_pen_handlers(wgui_paging_pen_down_hdlr, MMI_PEN_EVENT_DOWN);
    wgui_register_category_screen_control_area_pen_handlers(wgui_paging_pen_move_hdlr, MMI_PEN_EVENT_MOVE);
    wgui_register_category_screen_control_area_pen_handlers(wgui_paging_pen_up_hdlr, MMI_PEN_EVENT_UP);
#endif /* __MMI_TOUCH_SCREEN__ */ 
    dm_setup_category_functions(dm_redraw_category_screen, dm_get_category_history, dm_get_category_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY77_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
#ifdef __MMI_TOUCH_SCREEN__
    if (page_info_d->key_callback != NULL)
    {
        dm_data.s32flags |= DM_SHOW_VKPAD;
        dm_register_vkpad_callback(wgui_paging_virtual_keypad_callback);
    }
#endif /* __MMI_TOUCH_SCREEN__ */ 
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();

#ifdef __MMI_TOUCH_SCREEN__
    mmi_pen_reset();
#endif
    MMI_multiline_inputbox.flags &= ~UI_MULTI_LINE_INPUT_BOX_WORD_HIGHLIGHT;
    if (page_info_d->scroll_type == WGUI_PAGING_SCROLL_LINE_BY_LINE)
    {
        SetKeyHandler(wgui_paging_multiline_inputbox_previous_line_in_paging, KEY_UP_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(wgui_paging_multiline_inputbox_next_line_in_paging_scroll, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(wgui_paging_multiline_inputbox_previous_line_in_paging, KEY_VOL_UP, KEY_EVENT_DOWN);
        SetKeyHandler(wgui_paging_multiline_inputbox_next_line_in_paging_scroll, KEY_VOL_DOWN, KEY_EVENT_DOWN);
    }
    else
    {
        SetKeyHandler(wgui_paging_multiline_inputbox_previous_page, KEY_UP_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(wgui_paging_multiline_inputbox_next_page, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(wgui_paging_multiline_inputbox_previous_page, KEY_VOL_UP, KEY_EVENT_DOWN);
        SetKeyHandler(wgui_paging_multiline_inputbox_next_page, KEY_VOL_DOWN, KEY_EVENT_DOWN);
    }
    if (page_info_d->scroll_flag == WGUI_PAGING_AUTO_SCROLL_ON && page_info_d->scroll_speed != 0)
    {
        wgui_paging_start_text_scroll();
    }
    else
    {
        wgui_paging_stop_text_scroll();
    }

}   /* end of ShowCategory77Screen */


/*****************************************************************************
 * FUNCTION
 *  ExitCategory77Screen
 * DESCRIPTION
 *  Exit category 77 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory77Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    reset_softkeys();
    reset_multiline_inputbox();
    leave_full_screen();
    MMI_multiline_inputbox.previous_shared_bytes = 0;
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    wgui_paging_stop_text_scroll();
    wgui_paging_reset_show_percentage_flag();
    wgui_paging_multiline_inputbox_set_stop_scroll_callback(NULL);
#ifdef __MMI_TOUCH_SCREEN__
    MMI_content_height = MMI_content_height_prev;
    MMI_content_y = MMI_content_y_prev;
    mmi_imc_disconnect();
#endif /* __MMI_TOUCH_SCREEN__ */ 
    MMI_multiline_inputbox.ext_flags &= ~GUI_MULTI_LINE_INPUT_BOX_VIEW_PAGING_MODE;
}   /* end of ExitCategory77Screen */

#endif /* __MMI_EBOOK_READER__ */ 


/*****************************************************************************
 * FUNCTION
 *  ShowCategory76Screen
 * DESCRIPTION
 *  Displays the category74 screen
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the Left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  buffer                  [IN]        Buffer the input box should use
 *  buffer_size             [IN]        Size of the buffer
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory76Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U8 *buffer,
        S32 buffer_size,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 l;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    wgui_title_set_menu_shortcut_number(-1);
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);

    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    SetupCategoryKeyHandlers();

    MMI_title_string = (UI_string_type) get_string(title);
    MMI_title_icon = (PU8) get_image(title_icon);
    l = gui_strlen((UI_string_type) buffer);
    create_multiline_inputbox_set_buffer((UI_string_type) buffer, buffer_size, l, 0);
    MMI_multiline_inputbox.flags |=
        (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE |
         UI_MULTI_LINE_INPUT_BOX_DRAW_SEPARATOR);
#ifdef __MMI_WALLPAPER_ON_BOTTOM__ 
    dm_get_scr_bg_opacity(&idle_scr_bg_opacity);
    dm_set_scr_bg_opacity((U8)(current_MMI_theme->bg_opacity_low));
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_TRANSPARENT_BACKGROUND;
#endif     
    register_multiline_inputbox_viewer_keys();

    set_multiline_inputbox_category_history(MMI_CATEGORY76_ID, history_buffer);

    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = ExitCategory74Screen;
    dm_setup_category_functions(dm_redraw_category_screen, dm_get_category_history, dm_get_category_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY76_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();

}   /* end of ShowCategory76Screen */


/*****************************************************************************
 * FUNCTION
 *  GetCategory76History
 * DESCRIPTION
 *  Gets the history buffer for category76 screen
 * PARAMETERS
 *  history_buffer      [OUT]        Is the buffer into which the history data is stored (pre-allocated)
 * RETURNS
 *  Pointer to the history buffer
 *****************************************************************************/
U8 *GetCategory76History(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    get_multiline_inputbox_category_history(MMI_CATEGORY74_ID, history_buffer);
    return (history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory78Screen
 * DESCRIPTION
 *  Displays the category78 screen
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  icon_callback           [IN]        
 *  buffer                  [IN]        Buffer the input box should use.
 *  buffer_size             [IN]        Size of the buffer.
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory78Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        multi_line_input_box_icon_hdlr icon_callback,
        U8 *buffer,
        S32 buffer_size,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 l;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    wgui_title_set_menu_shortcut_number(-1);
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    SetupCategoryKeyHandlers();

    MMI_title_string = (UI_string_type) get_string(title);
    MMI_title_icon = (PU8) get_image(title_icon);

    l = gui_strlen((UI_string_type) buffer);
    create_multiline_inputbox_set_buffer((UI_string_type) buffer, buffer_size, l, 0);
    MMI_multiline_inputbox.flags |= (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW |
                                     UI_MULTI_LINE_INPUT_BOX_RICHTEXT | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE);
#ifdef __MMI_WALLPAPER_ON_BOTTOM__ 
    dm_get_scr_bg_opacity(&idle_scr_bg_opacity);
    dm_set_scr_bg_opacity((U8)(current_MMI_theme->bg_opacity_low));
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_TRANSPARENT_BACKGROUND;
#endif 

    MMI_multiline_inputbox.icon_callback = icon_callback;
    register_multiline_inputbox_viewer_keys();
    set_multiline_inputbox_category_history(MMI_CATEGORY78_ID, history_buffer);

    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = ExitCategory78Screen;
    dm_setup_category_functions(dm_redraw_category_screen, dm_get_category_history, dm_get_category_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY78_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();

}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory78Screen
 * DESCRIPTION
 *  Exits the category78 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory78Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    reset_softkeys();
    reset_multiline_inputbox();
#ifdef __MMI_WALLPAPER_ON_BOTTOM__ 
    dm_set_scr_bg_opacity(idle_scr_bg_opacity);
#endif 
}


#if defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_)
U16 g_wgui_cat105_btn_up_id = 0;
U16 g_wgui_cat105_btn_down_id = 0;
/*****************************************************************************
 * FUNCTION
 *  wgui_cat105_set_up_button
 * DESCRIPTION
 *  set up button status
 * PARAMETERS
 *  enable     [IN]        if button is enable
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat105_set_up_button(MMI_BOOL enable)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    icontext_button* bt_info = dm_get_button(g_wgui_cat105_btn_up_id);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    if (enable == MMI_TRUE)
    {
        bt_info->flags |= UI_BUTTON_SHIFT_BUTTON1;
        bt_info->flags &= ~UI_BUTTON_NO_SHIFT_BUTTON;
        gui_icontext_button_set_icon(bt_info, get_image(WGUI_VOLUME_UP_UP_IMAGE_ID), gui_transparent_color(0, 0, 0));      
        bt_info->clicked_down_icon = get_image(WGUI_VOLUME_UP_DOWN_IMAGE_ID);
    }
    else
    {
        bt_info->flags &= ~UI_BUTTON_SHIFT_BUTTON1;
        bt_info->flags |= UI_BUTTON_NO_SHIFT_BUTTON;        
        gui_icontext_button_set_icon(bt_info, get_image(WGUI_VOLUME_UP_DISABLE_IMAGE_ID), gui_transparent_color(0, 0, 0));
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat105_set_down_button
 * DESCRIPTION
 *  set down button status
 * PARAMETERS
 *  enable     [IN]        if button is enable
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat105_set_down_button(MMI_BOOL enable)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    icontext_button* bt_info = dm_get_button(g_wgui_cat105_btn_down_id);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/      
    if (enable == MMI_TRUE)
    {
        bt_info->flags |= UI_BUTTON_SHIFT_BUTTON1;
        bt_info->flags &= ~UI_BUTTON_NO_SHIFT_BUTTON;
        gui_icontext_button_set_icon(bt_info, get_image(WGUI_VOLUME_DOWN_UP_IMAGE_ID), gui_transparent_color(0, 0, 0));
        bt_info->clicked_down_icon = get_image(WGUI_VOLUME_DOWN_DOWN_IMAGE_ID);
    }
    else
    {
        bt_info->flags &= ~UI_BUTTON_SHIFT_BUTTON1;
        bt_info->flags |= UI_BUTTON_NO_SHIFT_BUTTON;
        gui_icontext_button_set_icon(bt_info, get_image(WGUI_VOLUME_DOWN_DISABLE_IMAGE_ID), gui_transparent_color(0, 0, 0));
    }
}
#endif  /* defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_) */


#ifdef __MMI_SLIM_IMG_RES__  /* __MMI_SLIM_IMG_RES__ */
const U16 mmi_cat105_fill_x[] = {
                MMI_CAT105_FILL_X_L1,
                MMI_CAT105_FILL_X_L2,
                MMI_CAT105_FILL_X_L3,
                MMI_CAT105_FILL_X_L4,
                MMI_CAT105_FILL_X_L5,
                MMI_CAT105_FILL_X_L6,
                MMI_CAT105_FILL_X_L7};

/*****************************************************************************
 * FUNCTION
 *  wgui_cat105_ctrl_area_redraw
 * DESCRIPTION
 *  Draws the category105 category control area
 * PARAMETERS
 *  coordinate      [IN/OUT]        Coordinates of category controlled area.
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat105_ctrl_area_redraw(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(coordinate);
    /* Draw BG and FILL */    
    gui_show_image(MMI_CAT105_BG_X, MMI_CAT105_BG_Y, get_image(WGUI_VOLUME_BG));

    for (i=0; i<=volume_level_UI; i++)
    { 
        gui_show_image(mmi_cat105_fill_x[i], MMI_CAT105_FILL_Y, get_image(WGUI_VOLUME_FILL));
    }
}
#endif /* __MMI_SLIM_IMG_RES__ */

/*****************************************************************************
 * FUNCTION
 *  wgui_cat105_clear_btn_bg
 * DESCRIPTION
 *  Draws the category105 button background
 * PARAMETERS
 *  button_object      [IN]        Button pointer.
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat105_clear_btn_bg(void *button_object)
{
    button *b = (button*) button_object;

    gdi_draw_solid_rect(b->x, b->y, b->x+b->width, b->y+b->height, GDI_COLOR_TRANSPARENT);
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategory105Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        S32 *volume_level,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    icontext_button *cur_button;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    dm_reset_context();
    UI_UNUSED_PARAMETER(history_buffer);

    gdi_layer_lock_frame_buffer();

    dm_add_title((UI_string_type)get_string(title), (PU8)get_image(title_icon));
    wgui_title_set_menu_shortcut_number(-1);

    dm_add_softkey(
        (UI_string_type)get_string(left_softkey), 
        (PU8)get_image(left_softkey_icon), 
        (UI_string_type)get_string(right_softkey), 
        (PU8)get_image(right_softkey_icon));

    volume_level_UI = (*volume_level);
    if (volume_level_UI < 0)
    {
        volume_level_UI = 0;
    }
    if (volume_level_UI > 6)
    {
        volume_level_UI = 6;
    }

    dm_data.s32flags = 0;
    if ((left_softkey == 0) && (left_softkey_icon == 0) && (right_softkey == 0) && (right_softkey_icon == 0))
    {
        dm_data.s32flags |= DM_NO_SOFTKEY;
    }
    else
    {
        dm_data.s32flags &= ~DM_NO_SOFTKEY;
    }
    wgui_softkey_set_filler_disabled(MMI_TRUE);

#ifdef __MMI_SLIM_IMG_RES__ /* __MMI_SLIM_IMG_RES__ */
    dm_register_category_controlled_callback(wgui_cat105_ctrl_area_redraw);
#else /* __MMI_SLIM_IMG_RES__ */
    switch (volume_level_UI)
    {
        case 0:
            dm_add_image(get_image(WGUI_VOLUME_LEVEL1), NULL, NULL);
            break;
        case 1:
            dm_add_image(get_image(WGUI_VOLUME_LEVEL2), NULL, NULL);
            break;
        case 2:
            dm_add_image(get_image(WGUI_VOLUME_LEVEL3), NULL, NULL);
            break;
        case 3:
            dm_add_image(get_image(WGUI_VOLUME_LEVEL4), NULL, NULL);
            break;
        case 4:
            dm_add_image(get_image(WGUI_VOLUME_LEVEL5), NULL, NULL);
            break;
        case 5:
            dm_add_image(get_image(WGUI_VOLUME_LEVEL6), NULL, NULL);
            break;
        case 6:
            dm_add_image(get_image(WGUI_VOLUME_LEVEL7), NULL, NULL);
            break;
    }
#endif /* __MMI_SLIM_IMG_RES__ */

    SetKeyHandler(show_vertical_bar_previous, KEY_VOL_DOWN, KEY_EVENT_DOWN);
    SetKeyHandler(show_vertical_bar_next, KEY_VOL_UP, KEY_EVENT_DOWN);

#if defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_)
    g_wgui_cat105_btn_up_id = dm_add_button(
                                  NULL,
                                  get_image(WGUI_VOLUME_UP_UP_IMAGE_ID),
                                  get_image(WGUI_VOLUME_UP_DOWN_IMAGE_ID),
                                  wgui_cat105_clear_btn_bg);

    g_wgui_cat105_btn_down_id = dm_add_button(
                                    NULL,
                                    get_image(WGUI_VOLUME_DOWN_UP_IMAGE_ID),
                                    get_image(WGUI_VOLUME_DOWN_DOWN_IMAGE_ID),
                                    wgui_cat105_clear_btn_bg);

    /* if level reach boundary, set button as disable */
    if (volume_level_UI == 0)
    {
        wgui_cat105_set_down_button(MMI_FALSE);
    }
    else if (volume_level_UI == 6)
    {
        wgui_cat105_set_up_button(MMI_FALSE);
    }
#endif /* defined(__MMI_WALLPAPER_ON_BOTTOM__) &&  !defined(__MMI_MAINLCD_128X128_) */ 

    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = MMI_dummy_function;
    dm_setup_category_functions(dm_redraw_category_screen, dm_get_category_history, dm_get_category_history_size);

#if defined(__MMI_TOUCH_SCREEN__) && defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_)
    dm_register_button_functions(g_wgui_cat105_btn_up_id, KEY_EVENT_UP, ResetCallbackTimer);
    dm_register_button_functions(g_wgui_cat105_btn_up_id, KEY_EVENT_DOWN, ShowVerticalBarUp);
    dm_register_button_functions(g_wgui_cat105_btn_up_id, KEY_REPEAT, CallShowVerticalBarMax);
    dm_register_button_functions(g_wgui_cat105_btn_down_id, KEY_EVENT_UP, ResetCallbackTimer);
    dm_register_button_functions(g_wgui_cat105_btn_down_id, KEY_EVENT_DOWN, ShowVerticalBarDown);
    dm_register_button_functions(g_wgui_cat105_btn_down_id, KEY_REPEAT, CallShowVerticalBarMin);
#endif /* defined(__MMI_TOUCH_SCREEN__) && defined(__MMI_WALLPAPER_ON_BOTTOM__) &&  !defined(__MMI_MAINLCD_128X128_) */ 

    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY105_ID;
    dm_data.s32flags |= DM_CLEAR_SCREEN_BACKGROUND;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}


/* For detail description, please refer to wgui_categories.h */
void show_vertical_bar(S32 volume_level)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    volume_level_UI = volume_level;

    if (volume_level_UI < 0)
    {
        volume_level_UI = 0;
    }
    if (volume_level_UI > 6)
    {
        volume_level_UI = 6;
    }

    switch (volume_level_UI)
    {
        case 0:
#ifndef __MMI_SLIM_IMG_RES__ /* __MMI_SLIM_IMG_RES__ */
            dm_change_image(get_image(WGUI_VOLUME_LEVEL1), NULL, 0);
#endif /* __MMI_SLIM_IMG_RES__ */
        #if defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_)
            wgui_cat105_set_down_button(MMI_FALSE);
            wgui_cat105_set_up_button(MMI_TRUE);
        #endif /* defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_) */            
            break;
        case 1:
#ifndef __MMI_SLIM_IMG_RES__ /* __MMI_SLIM_IMG_RES__ */
            dm_change_image(get_image(WGUI_VOLUME_LEVEL2), NULL, 0);
#endif /* __MMI_SLIM_IMG_RES__ */
        #if defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_)
            wgui_cat105_set_down_button(MMI_TRUE);
            wgui_cat105_set_up_button(MMI_TRUE);
        #endif /* defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_) */            
            break;
        case 2:
#ifndef __MMI_SLIM_IMG_RES__ /* __MMI_SLIM_IMG_RES__ */
            dm_change_image(get_image(WGUI_VOLUME_LEVEL3), NULL, 0);
#endif /* __MMI_SLIM_IMG_RES__ */
        #if defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_)
            wgui_cat105_set_down_button(MMI_TRUE);
            wgui_cat105_set_up_button(MMI_TRUE);
        #endif /* defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_) */
            break;
        case 3:
#ifndef __MMI_SLIM_IMG_RES__ /* __MMI_SLIM_IMG_RES__ */
            dm_change_image(get_image(WGUI_VOLUME_LEVEL4), NULL, 0);
#endif /* __MMI_SLIM_IMG_RES__ */
        #if defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_)
            wgui_cat105_set_down_button(MMI_TRUE);
            wgui_cat105_set_up_button(MMI_TRUE);
        #endif /* defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_) */            
            break;
        case 4:
#ifndef __MMI_SLIM_IMG_RES__ /* __MMI_SLIM_IMG_RES__ */
            dm_change_image(get_image(WGUI_VOLUME_LEVEL5), NULL, 0);
#endif /* __MMI_SLIM_IMG_RES__ */
        #if defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_)
            wgui_cat105_set_down_button(MMI_TRUE);
            wgui_cat105_set_up_button(MMI_TRUE);
        #endif /* defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_) */
            break;
        case 5:
#ifndef __MMI_SLIM_IMG_RES__ /* __MMI_SLIM_IMG_RES__ */
            dm_change_image(get_image(WGUI_VOLUME_LEVEL6), NULL, 0);
#endif /* __MMI_SLIM_IMG_RES__ */
        #if defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_)
            wgui_cat105_set_down_button(MMI_TRUE);
            wgui_cat105_set_up_button(MMI_TRUE);
        #endif /* defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_) */
            break;
        case 6:
#ifndef __MMI_SLIM_IMG_RES__ /* __MMI_SLIM_IMG_RES__ */
            dm_change_image(get_image(WGUI_VOLUME_LEVEL7), NULL, 0);
#endif /* __MMI_SLIM_IMG_RES__ */
        #if defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_)
            wgui_cat105_set_down_button(MMI_TRUE);
            wgui_cat105_set_up_button(MMI_FALSE);
        #endif /* defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_) */
            break;
    }
    RedrawCategoryFunction();
}


/* For detail description, please refer to wgui_categories.h */
void show_vertical_bar_previous(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    show_vertical_bar(--volume_level_UI);
}


/* For detail description, please refer to wgui_categories.h */ 
void show_vertical_bar_next(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    show_vertical_bar(++volume_level_UI);
}


/* For detail description, please refer to wgui_categories.h */
void ExitCategory120Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_UI_STATUS_BAR_AT_BOTTOM__)
    reset_status_bar_at_bottom();
    arrange_status_icons();
#endif /* defined(__MMI_UI_STATUS_BAR_AT_BOTTOM__) */ 
    move_status_icons(0, 0, 0, UI_device_width - 1, MMI_status_bar_height - 1);  
    close_main_LCD_dt_display();
    gui_hide_animations();
    reset_softkeys();
    register_hide_status_icon_bar(1, MMI_dummy_function);
    close_status_icons();
}


/*****************************************************************************
 * FUNCTION
 *  cat_120_hide_date_time_display
 * DESCRIPTION
 *  hide function of date/time of category120
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y position
 *  x2      [IN]        End x position
 *  y2      [IN]        End y position
 * RETURNS
 *  void
 *****************************************************************************/
void cat_120_hide_date_time_display(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_filled_area *f = current_MMI_theme->network_screen_background_filler;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gdi_layer_set_clip(x1, y1, x2, y2);
    gui_draw_filled_area(0, 0, UI_device_width - 1, UI_device_height - 1, f);
    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  cat_120_hide_status_icons_bar
 * DESCRIPTION
 *  hide function of status bar
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void cat_120_hide_status_icons_bar(U8 status_bar_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_push_clip();
    get_status_icon_bar_clip(status_bar_id, &x1, &y1, &x2, &y2);
    gui_set_clip(x1, y1, x2, y2);
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_WHITE);
    gui_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  cat_120_hide_status_icons_bar0
 * DESCRIPTION
 *  hide function of horizontal status bar
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void cat_120_hide_status_icons_bar0(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cat_120_hide_status_icons_bar(0);
}


/*****************************************************************************
 * FUNCTION
 *  cat_120_hide_status_icons_bar1
 * DESCRIPTION
 *  hide function of vertical status bar
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void cat_120_hide_status_icons_bar1(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cat_120_hide_status_icons_bar(1);
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategory120Screen(
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U16 message,
        U16 message_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 l;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    dm_reset_context();
    UI_UNUSED_PARAMETER(history_buffer);
    gdi_layer_lock_frame_buffer();

    wgui_title_set_menu_shortcut_number(-1);
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    SetupCategoryKeyHandlers();

    set_main_LCD_dt_date_hide_function(cat_120_hide_date_time_display);
    set_main_LCD_dt_time_hide_function(cat_120_hide_date_time_display);
#if defined(__MMI_UI_STATUS_BAR_AT_BOTTOM__)
    set_dt_display(DT_IDLE_SCREEN_2);
    set_status_bar_at_bottom();
#else /* defined(__MMI_UI_STATUS_BAR_AT_BOTTOM__) */ 
    set_dt_display(DT_NETWORK_SEARCH);
#endif /* defined(__MMI_UI_STATUS_BAR_AT_BOTTOM__) */ 

    MMI_message_string = (UI_string_type) get_string(message);
    l = gui_strlen(MMI_message_string);
    create_multiline_inputbox_set_buffer(MMI_message_string, l, l, 0);
    MMI_multiline_inputbox.normal_text_color = gui_color(0, 0, 0);
    MMI_multiline_inputbox.flags |=
        (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY |
         UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND | UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR);
    MMI_multiline_inputbox.ext_flags |= GUI_MULTI_LINE_INPUT_BOX_TRUNCATE_CONTENT;

    dm_add_image(get_image(message_icon), NULL, NULL);
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND_COLOR | DM_SPECIFIC_HIDE_STATUS_BAR;

    register_hide_status_icon_bar(0, cat_120_hide_status_icons_bar0);
    register_hide_status_icon_bar(1, cat_120_hide_status_icons_bar1);
#ifdef __MMI_UI_STATUS_BAR_AT_BOTTOM__
    set_status_icon_bar_clip(
        0,
        0,
        UI_device_height - 1 - MMI_button_bar_height - MMI_status_bar_height,
        UI_device_width - 1,
        UI_device_height - 1 - MMI_button_bar_height - 1);
    set_status_icon_bar_clip(
        1,
        UI_device_width - MMI_IDLE_STRING_MARGIN_GAP,
        MMI_status_bar_height,
        UI_device_width - 1,
        UI_device_height - 1 - MMI_button_bar_height - MMI_status_bar_height - (STATUS_ICON_Y_GAP << 1) - 1);
    arrange_status_icons();
#else /* __MMI_UI_STATUS_BAR_AT_BOTTOM__ */ 
    move_status_icons(
        0,
        0,
        MMI_STATUS_BAR_IDLE_Y,
        UI_device_width - 1,
        MMI_status_bar_height + MMI_STATUS_BAR_IDLE_Y- 1);
    move_status_icons(
        1,
        UI_device_width - MMI_IDLE_STRING_MARGIN_GAP,
        MMI_status_bar_height + MMI_STATUS_BAR_IDLE_Y,
        UI_device_width - 1,
        UI_device_height - MMI_softkey_height - 2);
#endif /* __MMI_UI_STATUS_BAR_AT_BOTTOM__ */ 
    show_status_icon_bar(0);
    show_status_icon_bar(1);
    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = ExitCategory120Screen;
    dm_setup_category_functions(dm_redraw_category_screen, dm_get_category_history, dm_get_category_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY120_ID;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();

}

#ifdef __MMI_BMI__

/* For properly placing the strings, images and boxes, the screen is divided into blocks. */
#define NUMBER_OF_X_BLOCKS 7
#define NUMBER_OF_Y_BLOCKS 15

/* Only used in cat122(BMI) */
static UI_filled_area pinkwgui_pop_up_dialog_background = 
{
    UI_FILLED_AREA_TYPE_COLOR,
    UI_NULL_IMAGE,
    NULL,
    {255, 236, 255, 100},
    {0, 0, 0, 0},
    {0, 0, 0, 100},
    {50, 50, 50, 100},
    0
};

/* Used in cat122(BMI) */
static UI_filled_area yellowwgui_pop_up_dialog_background = 
{
    UI_FILLED_AREA_TYPE_COLOR | UI_FILLED_AREA_SINGLE_BORDER,
    UI_NULL_IMAGE,
    NULL,
    {249, 244, 171, 100},
    {0, 0, 0, 0},
    {0, 0, 0, 100},
    {50, 50, 50, 100},
    0
};

/* Only used in cat122(BMI) */
static UI_filled_area orangewgui_without_boder_pop_up_dialog_background = 
{
    UI_FILLED_AREA_TYPE_COLOR | UI_FILLED_AREA_SINGLE_BORDER,
    UI_NULL_IMAGE,
    NULL,
    {242, 174, 33, 100},
    {0, 0, 0, 0},
    {0, 0, 0, 100},
    {50, 50, 50, 100},
    0
};


/*****************************************************************************
 * FUNCTION
 *  RedrawCategory122Screen
 * DESCRIPTION
 *  Category 122 redraw
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void RedrawCategory122Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 fh, fw;
    S32 total_width = 0;
    S32 x1, y1, x2, y2;
    S32 block_size_x = MMI_content_width / NUMBER_OF_X_BLOCKS;
    S32 block_size_y = MMI_content_height / NUMBER_OF_Y_BLOCKS;
    S32 gap_x = (MMI_content_width % NUMBER_OF_X_BLOCKS) >> 1;
    S32 gap_y = (MMI_content_height % NUMBER_OF_Y_BLOCKS) >> 1;

    color c = *current_MMI_theme->title_text_color;
    color bc = *current_MMI_theme->title_text_border_color; /* calendar text */
    stFontAttribute *f = &MMI_medium_font;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_set_font(f);
    gui_set_text_color(c);
    gui_set_text_border_color(bc);

    gdi_layer_lock_frame_buffer();

    gdi_layer_push_clip();
    gdi_layer_reset_clip();

    wgui_show_transparent_animation();

    y1 = MMI_content_y + gap_y + block_size_y;
    y2 = y1 + (3 * block_size_y) - 1;


    gui_measure_string(MMI_message_string, &fw, &fh);
    total_width += fw;
    gui_measure_string((UI_string_type) disp_barstr, &fw, &fh);
    total_width += fw;
    gui_measure_image(_MMI_animated_icon, &fw, &fh);
    total_width += fw;

    x1 = _MMI_animated_icon_x;
    if (fw > 0)
    {
        if (r2lMMIFlag)
        {   
            x1 -= 10;
        }
        else
        {
            x1 += (fw + 10);
        }
    }

    gui_measure_string(MMI_message_string, &fw, &fh);
    gui_move_text_cursor(x1, y2 - fh);
    gui_print_bordered_text(MMI_message_string);


    if (r2lMMIFlag)
    {
        x1 -= (fw + 5);
    }
    else
    {
        x1 += (fw + 5);
    }

    gui_measure_string((UI_string_type) disp_barstr, &fw, &fh);
    gui_move_text_cursor(x1, y2 - fh);
    gui_print_bordered_text((UI_string_type) disp_barstr);

    x1 = MMI_content_x + gap_x + (block_size_x / 2);
    y1 = y2 + (block_size_y);
    x2 = x1 + (6 * block_size_x) - 1;
    y2 = y1 + (3 * block_size_y) - 1;

    gui_draw_filled_area(
        x1 + (2 * block_size_x) - 5,
        y1,
        x2 - (2 * block_size_x) + 5,
        y2,
        &orangewgui_without_boder_pop_up_dialog_background);

    gui_measure_string((UI_string_type) disp_valuestr, &fw, &fh);
    if (r2lMMIFlag)
    {
        gui_move_text_cursor(x1 + (3 * block_size_x) + (fw >> 1), ((y1 >> 1) + (y2 >> 1)) - (fh >> 1));
    }
    else
    {
        gui_move_text_cursor(x1 + (3 * block_size_x) - (fw >> 1), ((y1 >> 1) + (y2 >> 1)) - (fh >> 1));
    }

    gui_print_bordered_text((UI_string_type) disp_valuestr);

    x1 = MMI_content_x + gap_x + (block_size_x / 2);
    y1 = MMI_content_y + gap_y + (9 * block_size_y);
    x2 = x1 + (6 * block_size_x);
    y2 = y1 + (3 * block_size_y) - 1;

    gui_draw_filled_area(x1, y1, x2, y2, &yellowwgui_pop_up_dialog_background);
    gui_draw_vertical_line(y1, y2, x1 + (2 * block_size_x), yellowwgui_pop_up_dialog_background.border_color); /* 082606 calendar line */
    gui_draw_vertical_line(y1, y2, x1 + (4 * block_size_x), yellowwgui_pop_up_dialog_background.border_color);

    /* wgui_image_clip_x1 stores the percentage value for deciding the position
       of highlighted block. */
    x1 = x1 + (wgui_image_clip_x1 * (2 * block_size_x));
    x2 = x1 + (2 * block_size_x);
    gui_draw_filled_area(x1, y1, x2, y2, &orangewgui_without_boder_pop_up_dialog_background);

    x1 = MMI_content_x + gap_x + (block_size_x / 2);
    y1 = y1 + (4 * block_size_y);
    x2 = x1 + (6 * block_size_x) - 1;
    y2 = y1 + block_size_y;

    gui_measure_string((UI_string_type) left_value, &fw, &fh);
    if (r2lMMIFlag)
    {
        gui_move_text_cursor(x1 + (2 * block_size_x) + (fw >> 1), y1);
    }
    else
    {
        gui_move_text_cursor(x1 + (2 * block_size_x) - (fw >> 1), y1);
    }

    gui_print_bordered_text((UI_string_type) left_value);

    gui_measure_string((UI_string_type) right_value, &fw, &fh);
    if (r2lMMIFlag)
    {
        gui_move_text_cursor(x1 + (4 * block_size_x) + (fw >> 1), y1);
    }
    else
    {
        gui_move_text_cursor(x1 + (4 * block_size_x) - (fw >> 1), y1);
    }

    gui_print_bordered_text((UI_string_type) right_value);

    gdi_layer_pop_clip();
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  DrawCate122CategoryControlArea
 * DESCRIPTION
 *  Draws the category122 category control area
 * PARAMETERS
 *  coordinate      [IN/OUT]        Coordinates of category controlled area.
 * RETURNS
 *  void
 *****************************************************************************/
static void DrawCate122CategoryControlArea(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(coordinate);
    RedrawCategory122Screen();
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategory122Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U16 message,
        S32 percentage_value,
        U8 *history_buffer,
        S8 *disp_val,
        U8 *bar_status,
        U16 side_icon,
        U8 *left_limit,
        U8 *right_limit)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 fw, fh;
    S32 total_width = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);

    wgui_title_set_menu_shortcut_number(-1);

    dm_add_softkey(
        get_string(left_softkey), 
        get_image(left_softkey_icon), 
        get_string(right_softkey), 
        get_image(right_softkey_icon));

    dm_add_title(get_string(title),get_image(title_icon));

    MMI_message_string = get_string(message);

    disp_valuestr = (PU8) disp_val;
    disp_barstr = (PU8) bar_status;

    /* 
     * store the percentage value in Global variable, so that is can be used
     * in the redraw category. 
     */
    wgui_image_clip_x1 = percentage_value;

    left_value = (PU8) left_limit;
    right_value = (PU8) right_limit;

    gui_measure_string(MMI_message_string, &fw, &fh);
    total_width += fw;
    gui_measure_string((UI_string_type) disp_barstr, &fw, &fh);
    total_width += fw;
    gui_measure_image((PU8) get_image(side_icon), &fw, &fh);
    total_width += fw;

    /* add gaps between image and strings */
    if (fw > 0)
    {
        total_width += (10 + 5);
    }
    else
    {
        total_width += 5;
    }
    if (r2lMMIFlag)
    {   
        wgui_set_animation_y(
            (UI_device_width >> 1) + (total_width >> 1) - (fw >> 1),
            MMI_content_y + ((MMI_content_height % NUMBER_OF_Y_BLOCKS) >> 1) + (4 * (MMI_content_height / NUMBER_OF_Y_BLOCKS)) - 1 - fh,
            side_icon);

    }
    else
    {
        wgui_set_animation_y(
            (UI_device_width >> 1) - (total_width >> 1) + (fw >> 1),
            MMI_content_y + ((MMI_content_height % NUMBER_OF_Y_BLOCKS) >> 1) + (4 * (MMI_content_height / NUMBER_OF_Y_BLOCKS)) - 1 - fh,
            side_icon);

    }

    ExitCategoryFunction = UI_dummy_function;
    dm_setup_category_functions(dm_redraw_category_screen, dummy_get_history, dummy_get_history_size);
    dm_register_category_controlled_callback(DrawCate122CategoryControlArea);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY122_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}
#endif /* __MMI_BMI__ */ 


/*****************************************************************************
 * FUNCTION
 *  SetCategory111RightSoftkeyFunction
 * DESCRIPTION
 *  Register RSK function handler of category111 screen
 * PARAMETERS
 *  f       [IN]        Callback function
 *  k       [IN]        Key event type
 * RETURNS
 *  void
 *****************************************************************************/
void SetCategory111RightSoftkeyFunction(void (*f) (void), MMI_key_event_type k)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(k);
    wgui_singleline_inputbox_RSK_function = f;
}


#ifdef UI_SMALL_PIN_EDITOR_SCREEN
    
typedef struct _wgui_cat112_cntx_struct
{
    U8* multiline_message;
    U8* singleline_buffer;
    U8* history_buffer;
    PU8 rsk_icon;
    UI_string_type rsk_label;
    U32 input_type;
    S32 singleline_buffer_size;    
} wgui_cat112_cntx_struct;
    
static wgui_cat112_cntx_struct* g_wgui_cat112_cntx_ptr = NULL;


#if defined(__MMI_TOUCH_SCREEN__)
/*****************************************************************************
 * FUNCTION
 *  wgui_cat112_virtual_keypad_callback
 * DESCRIPTION
 *  virtual keypad callback for category112
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat112_virtual_keypad_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_imc_redraw_screen_by_state();
}
#endif /* defined(__MMI_TOUCH_SCREEN__) */ 



/*****************************************************************************
 * FUNCTION
 *  cat112_draw_scroll_text_cb
 * DESCRIPTION
 *  draw scrolling text background
 * PARAMETERS
 *  x1      [IN]        start X
 *  y1      [IN]        start Y
 *  x2      [IN]        end X
 *  y2      [IN]        end Y
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat112_draw_scroll_text_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if defined(DM_NEW_POPUPBG_METHOD)
    dm_coordinates popup_clip = {0};
#endif /* defined(DM_NEW_POPUPBG_METHOD) */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(DM_NEW_POPUPBG_METHOD)
    popup_clip.s16X = (S16)x1;
    popup_clip.s16Y = (S16)y1;
    popup_clip.s16Width = (S16)(x2 - x1 + 1);
    popup_clip.s16Height = (S16)(y2 - y1 + 1);
    dm_popupbg_set_clip((dm_coordinates*)&popup_clip);
    dm_redraw_popup_background();
#else /* defined(DM_NEW_POPUPBG_METHOD) */
    gdi_layer_push_clip();
    gdi_layer_set_clip(x1, y1, x2, y2);
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
    gdi_layer_pop_clip();
#endif /* defined(DM_NEW_POPUPBG_METHOD) */
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat112_hide_lsk_cb
 * DESCRIPTION
 *  hide function of left softkey
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat112_hide_lsk_cb(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	wgui_cat112_draw_scroll_text_background(
        MMI_softkeys[MMI_LEFT_SOFTKEY].x,
        MMI_softkeys[MMI_LEFT_SOFTKEY].y,
        MMI_softkeys[MMI_LEFT_SOFTKEY].x + MMI_softkeys[MMI_LEFT_SOFTKEY].width - 1,
        MMI_softkeys[MMI_LEFT_SOFTKEY].y + MMI_softkeys[MMI_LEFT_SOFTKEY].height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat112_hide_rsk_cb
 * DESCRIPTION
 *  hide function of right softkey
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat112_hide_rsk_cb(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	wgui_cat112_draw_scroll_text_background(
        MMI_softkeys[MMI_RIGHT_SOFTKEY].x,
        MMI_softkeys[MMI_RIGHT_SOFTKEY].y,
        MMI_softkeys[MMI_RIGHT_SOFTKEY].x + MMI_softkeys[MMI_RIGHT_SOFTKEY].width - 1,
        MMI_softkeys[MMI_RIGHT_SOFTKEY].y + MMI_softkeys[MMI_RIGHT_SOFTKEY].height - 1);
}


#if defined(__MMI_WGUI_CSK_ENABLE__)
/*****************************************************************************
 * FUNCTION
 *  wgui_cat112_hide_csk_cb
 * DESCRIPTION
 *  hide function of center softkey
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat112_hide_csk_cb(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	wgui_cat112_draw_scroll_text_background(
        MMI_softkeys[MMI_CENTER_SOFTKEY].x,
        MMI_softkeys[MMI_CENTER_SOFTKEY].y,
        MMI_softkeys[MMI_CENTER_SOFTKEY].x + MMI_softkeys[MMI_CENTER_SOFTKEY].width - 1,
        MMI_softkeys[MMI_CENTER_SOFTKEY].y + MMI_softkeys[MMI_CENTER_SOFTKEY].height - 1);
}
#endif /* defined(__MMI_WGUI_CSK_ENABLE__) */


/*****************************************************************************
 * FUNCTION
 *  wgui_cat112_control_area_callback
 * DESCRIPTION
 *  control area callback for category112
 *  1. draw multiline
 *  2. draw sinlgeline
 * PARAMETERS
 *  coordinate    [IN]   control area coordinate
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat112_control_area_callback(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/        
    S32 len, total_height, left_space, y_space, multiline_h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* multiline inputbox */
    multiline_h = Get_CharDisplayHeightOfAllLangAndType(MMI_medium_font.size) * 3; /* multiline height: max two lines */
    total_height = multiline_h + MMI_SINGLELINE_INPUTBOX_HEIGHT;
	if (coordinate->s16Height < total_height)
	{
		/* adjust multline inputbox height */
		multiline_h = coordinate->s16Height - MMI_SINGLELINE_INPUTBOX_HEIGHT - 1;
		y_space = 0;
	}
	else
	{
		left_space = coordinate->s16Height - total_height;
		y_space = left_space / 3;
	}

    len = gui_strlen((UI_string_type) g_wgui_cat112_cntx_ptr->multiline_message);
    wgui_inputs_ml_create_set_buffer((UI_string_type) g_wgui_cat112_cntx_ptr->multiline_message, len, len, 0);
    MMI_multiline_inputbox.normal_text_color = *(current_MMI_theme->popup_text_color);
    MMI_multiline_inputbox.flags |=
        UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND | 
        UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE;
    wgui_inputs_ml_move(coordinate->s16X, coordinate->s16Y + y_space);
    wgui_inputs_ml_resize(coordinate->s16Width, multiline_h);
    wgui_inputs_ml_show();

    /* singleline inputbox */
    mmi_imc_set_fixed_input_box();
    wgui_inputs_sl_setup(
              coordinate->s16X,
              MMI_multiline_inputbox.y + MMI_multiline_inputbox.height + y_space,
              coordinate->s16Width,
              MMI_SINGLELINE_INPUTBOX_HEIGHT,
              g_wgui_cat112_cntx_ptr->singleline_buffer,
              g_wgui_cat112_cntx_ptr->singleline_buffer_size,
              MMI_CATEGORY112_ID,
              g_wgui_cat112_cntx_ptr->rsk_label,
              g_wgui_cat112_cntx_ptr->rsk_icon,
              g_wgui_cat112_cntx_ptr->input_type,
              g_wgui_cat112_cntx_ptr->history_buffer,
              0);
    gui_set_single_line_input_box_theme(&MMI_singleline_inputbox, &PIN_singleline_inputbox_theme);
#if defined(__MMI_MAINLCD_320X480__)
	mmi_imc_set_backgroud_filler(wgui_cat112_draw_scroll_text_background);
#endif /* defined(__MMI_MAINLCD_320X480__) */
    wgui_inputs_sl_show();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat112_get_history_size
 * DESCRIPTION
 *  get history size for category112
 * PARAMETERS
 *  void
 * RETURNS
 *  S32
 *****************************************************************************/
S32 wgui_cat112_get_history_size(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (sizeof(singleline_inputbox_category_history));
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat112_get_history
 * DESCRIPTION
 *  get history for category112
 * PARAMETERS
 *  history_buffer    [IN]   histroy buffer
 * RETURNS
 *  U8*
 *****************************************************************************/
U8* wgui_cat112_get_history(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inputs_sl_get_category_history(MMI_CATEGORY112_ID, history_buffer);
    return (history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory112Screen
 * DESCRIPTION
 *  Exits category 112 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory112Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    reset_small_screen();
#endif 
#if !defined(__MMI_MAINLCD_320X480__)
    wgui_softkey_set_is_in_popup(MMI_FALSE);
#endif
    show_status_icon_bar(0);
    reset_multiline_inputbox();
    wgui_inputs_sl_set_show_flag(0);
    wgui_inputs_sl_close();
    reset_softkeys(); /* because wgui_close_singleline_inputbox() will use softkey, reset_softkey must be after it */
    entry_full_screen();    

    /* free parameter */
    if(g_wgui_cat112_cntx_ptr != NULL)
    {
        OslMfree(g_wgui_cat112_cntx_ptr);
		g_wgui_cat112_cntx_ptr = NULL;
    }    
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory112Screen
 * DESCRIPTION
 *  Displays the category112 screen - main used for enter pin screen
 * PARAMETERS
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Left softkey icon
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Right softkey icon
 *  message                 [IN]        Message (only support max two lines)
 *  input_type              [IN]        Input type. Only numeric passward is allowed
 *  buffer                  [IN]        Input buffer
 *  buffer_size             [IN]        Size of the buffer
 *  message2                [IN]        Second message (scrolling)
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory112Screen(
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U8 *message,
        U32 input_type,
        U8 *buffer,
        S32 buffer_size,
        U8 *message2,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    /* Currently, only numeric password is allowed. */
    /* Becasue the layout is restricted by virtual keypad */
    MMI_ASSERT(input_type == IMM_INPUT_TYPE_NUMERIC_PASSWORD);

    /* pre-process memory */
    if(g_wgui_cat112_cntx_ptr != NULL)
    {
        OslMfree(g_wgui_cat112_cntx_ptr);
		g_wgui_cat112_cntx_ptr = NULL;
    }    

    /* allocate memory */
    g_wgui_cat112_cntx_ptr = (wgui_cat112_cntx_struct*)OslMalloc(sizeof(wgui_cat112_cntx_struct));
    MMI_ASSERT(g_wgui_cat112_cntx_ptr != NULL);
    memset(g_wgui_cat112_cntx_ptr, 0, sizeof(wgui_cat112_cntx_struct));
    
    gdi_layer_lock_frame_buffer();

#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    set_small_screen();
    gui_add_cleanup_hook(disable_resized_small_screen);
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 

    /* set softkey */
    dm_add_softkey(
        (UI_string_type)GetString(left_softkey), (PU8)GetImage(left_softkey_icon),
        (UI_string_type)GetString(right_softkey), (PU8)GetImage(right_softkey_icon));
    
    /* multiline data */
    g_wgui_cat112_cntx_ptr->multiline_message = message;

    /* singleline data */
    g_wgui_cat112_cntx_ptr->singleline_buffer = buffer;
    g_wgui_cat112_cntx_ptr->singleline_buffer_size = buffer_size;
    g_wgui_cat112_cntx_ptr->rsk_label = get_string(right_softkey);
    g_wgui_cat112_cntx_ptr->rsk_icon = get_image(right_softkey_icon);
    g_wgui_cat112_cntx_ptr->input_type = input_type;
    g_wgui_cat112_cntx_ptr->history_buffer = history_buffer;

    /* set scrolling text */
    dm_add_scroll_text(
          (UI_string_type) message2, 
          NULL, 
          wgui_cat112_draw_scroll_text_background, 
          *(current_MMI_theme->popup_text_color),
          *(current_MMI_theme->popup_text_color));

#if defined(__MMI_MAINLCD_320X480__)
	register_hide_softkey(wgui_cat112_hide_lsk_cb, MMI_LEFT_SOFTKEY);
	register_hide_softkey(wgui_cat112_hide_rsk_cb, MMI_RIGHT_SOFTKEY);
#if defined(__MMI_WGUI_CSK_ENABLE__)
    register_hide_softkey(wgui_cat112_hide_csk_cb, MMI_CENTER_SOFTKEY);
#endif /* defined(__MMI_WGUI_CSK_ENABLE__) */
#endif /* defined(__MMI_MAINLCD_320X480__) */

    dm_register_category_controlled_callback(wgui_cat112_control_area_callback);

    gdi_layer_unlock_frame_buffer();

#if !defined(__MMI_MAINLCD_320X480__)
    wgui_softkey_set_is_in_popup(MMI_TRUE);
#endif 
    ExitCategoryFunction = ExitCategory112Screen;
    dm_setup_category_functions(dm_redraw_category_screen, wgui_cat112_get_history, wgui_cat112_get_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY112_ID;
    dm_data.s32flags = DM_SHOW_VKPAD | DM_SET_NEW_LAYER_ACTIVE;
    dm_setup_data(&dm_data);
#if defined(__MMI_TOUCH_SCREEN__)
    dm_register_vkpad_callback(wgui_cat112_virtual_keypad_callback);
#endif
    dm_redraw_category_screen();
}
#endif /* UI_SMALL_PIN_EDITOR_SCREEN */ 


S32 Cat111CountDownValue;
FuncPtr Cat111TimerExpireCallBack = UI_dummy_function;
UI_filled_area pin_editor_background_filler;

/*****************************************************************************
 * FUNCTION
 *  SetCat111TimerExpireFunc
 * DESCRIPTION
 *  Set cat 111 countdown callback function
 * PARAMETERS
 *  f       [IN]        Countdown callback function
 * RETURNS
 *  void
 *****************************************************************************/
void SetCat111TimerExpireFunc(FuncPtr f)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    Cat111TimerExpireCallBack = f;
}


/*****************************************************************************
 * FUNCTION
 *  Cat111CountDownCallBack
 * DESCRIPTION
 *  cat 111 countdown callback function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void Cat111CountDownCallBack(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 buf[6];
    S32 count_y;
    S32 sw, sh;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (Cat111CountDownValue == 0)
    {
        StopTimer(POPUP_TIMER);
        if (Cat111TimerExpireCallBack != NULL)
        {
            Cat111TimerExpireCallBack();
        }
        Cat111TimerExpireCallBack = UI_dummy_function;
    }
    else
    {
        gui_itoa(Cat111CountDownValue, (UI_string_type) buf, 10);
        gui_set_font(&MMI_medium_font);
        gui_set_text_color(*current_MMI_theme->list_normal_text_color);

        gui_measure_string((UI_string_type) buf, &sw, &sh);
        count_y = UI_device_height - MMI_button_bar_height - sh - 1;
#ifdef __MMI_TOUCH_SCREEN__
#ifdef __MMI_MAINLCD_320X240__
        count_y = MMI_COMMON_CONTENT_Y - (MMI_TITLE_HEIGHT >> 1) + (MMI_MENUITEM_HEIGHT * 3) + (CAT111_GAP * 3) + 6 /* editor border */;
#else
        count_y = MMI_COMMON_CONTENT_Y - (MMI_TITLE_HEIGHT >> 1) + (MMI_MENUITEM_HEIGHT << 2) + (CAT111_GAP * 3) + 6 /* editor border */;
#endif
#endif

        gdi_layer_push_clip();
        
#ifndef __MMI_WALLPAPER_ON_BOTTOM__
        gui_draw_filled_area(0, count_y, UI_device_width - 1, count_y + sh - 1, &pin_editor_background_filler);
#else
        gdi_draw_solid_rect(0, count_y, UI_device_width - 1, count_y + sh - 1, GDI_COLOR_TRANSPARENT);
#endif

        gui_move_text_cursor((UI_device_width - sw) >> 1, count_y);
        gui_print_text((UI_string_type) buf);
        gdi_layer_pop_clip();
        gui_BLT_double_buffer(0, count_y, UI_device_width - 1, count_y + sh - 1);
        
        Cat111CountDownValue--;
        StartTimer(POPUP_TIMER, 1000, Cat111CountDownCallBack);
    }
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory111Screen
 * DESCRIPTION
 *  Show category 111 screen, full screen PIN editor
 * PARAMETERS
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Left softkey icon
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Right softkey icon
 *  message                 [IN]        Message (max support two lines)
 *  input_type              [IN]        Input type. Only numeric or alpha-numeric passward is allowed
 *  buffer                  [IN]        Buffer the input box
 *  buffer_size             [IN]        Size of the buffer
 *  message2                [IN]        Second message below inputbox (scrolling text)
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory111Screen(
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U16 message,
        U32 input_type,
        U8 *buffer,
        S32 buffer_size,
        U8 *message2,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ShowCategory111Screen_ext(
        left_softkey,
        left_softkey_icon,
        right_softkey,
        right_softkey_icon,
        (U8*) get_string(message),
        input_type,
        buffer,
        buffer_size,
        message2,
        0,
        history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  Cat111ScrolTextBg
 * DESCRIPTION
 *  scrol text background
 * PARAMETERS
 *  x1      [IN]        Start x
 *  y1      [IN]        Start y
 *  x2      [IN]        End x
 *  y2      [IN]        End y
 * RETURNS
 *  void
 *****************************************************************************/
void Cat111ScrolTextBg(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __MMI_WALLPAPER_ON_BOTTOM__
    gui_draw_filled_area(x1, y1, x2, y2, &pin_editor_background_filler);
#else
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory111Screen_ext
 * DESCRIPTION
 *  Extension of category 111. Can support duration.
 * PARAMETERS
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the Left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  message                 [IN]        Message (two line)
 *  input_type              [IN]        Input type. Currently only numeric or alpha-numeric passward is allowed
 *  buffer                  [IN]        Buffer the input box
 *  buffer_size             [IN]        Size of the buffer
 *  message2                [IN]        Second message (scrolling)
 *  duration                [IN]        Auto close duration, only for numeric password
 *  history_buffer          [IN]        History buffe
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory111Screen_ext(
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U8 *message,
        U32 input_type,
        U8 *buffer,
        S32 buffer_size,
        U8 *message2,
        S32 duration,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef UI_SMALL_PIN_EDITOR_SCREEN
    if (whether_no_small_screen())
    {
        ShowCategory112Screen(
            left_softkey,
            left_softkey_icon,
            right_softkey,
            right_softkey_icon,
            message,
            input_type,
            buffer,
            buffer_size,
            message2,
            history_buffer);
    }
    else
#endif /* UI_SMALL_PIN_EDITOR_SCREEN */ 
    {
        dm_data_struct dm_data;
        S32 h, len;

        gdi_layer_lock_frame_buffer();

        if (duration != 0)
        {
            /* Currently, only numeric password is allowed for duration. */
            /* Becasue the layout is restricted by virtual keypad */
            MMI_ASSERT(input_type == IMM_INPUT_TYPE_NUMERIC_PASSWORD);
        }

        /* set softkey */
        dm_add_softkey(
            (UI_string_type)GetString(left_softkey), (PU8)GetImage(left_softkey_icon),
            (UI_string_type)GetString(right_softkey), (PU8)GetImage(right_softkey_icon));

#ifndef __MMI_WALLPAPER_ON_BOTTOM__
        pin_editor_background_filler = *current_MMI_theme->PIN_screen_background_filler;
        pin_editor_background_filler.flags = UI_FILLED_AREA_TYPE_COLOR;
        dm_add_back_fill_area(&pin_editor_background_filler);
#endif

        /* set two line message */
        len = gui_strlen((UI_string_type) message);
        create_multiline_inputbox_set_buffer((UI_string_type) message, len, len, 0);
        MMI_multiline_inputbox.normal_text_color = *current_MMI_theme->list_normal_text_color;
        MMI_multiline_inputbox.flags |=
            (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND |
             UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE);
        MMI_multiline_inputbox.ext_flags |= GUI_MULTI_LINE_INPUT_BOX_TRUNCATE_CONTENT;
#if defined(__MMI_MAINLCD_320X240__)
        MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_WRAPPING_BY_WORD;
#endif
        show_multiline_inputbox_no_draw();

        mmi_imc_set_fixed_input_box();
        /* set input_box */
        h = MMI_MENUITEM_HEIGHT;
        wgui_setup_singleline_inputbox(
            CAT111_MARGIN,
            MMI_multiline_inputbox.y + MMI_multiline_inputbox.height + 1 /* gap */, /* according to the multi-line input-box above */
            UI_device_width - (CAT111_MARGIN << 1),
            h,
            buffer,
            buffer_size,
            MMI_CATEGORY111_ID,
            get_string(right_softkey),
            get_image(right_softkey_icon),
            input_type,
            history_buffer,
            0);
        gui_set_single_line_input_box_theme(&MMI_singleline_inputbox, &PIN_singleline_inputbox_theme);
        
        /* set scrolling text */
        dm_add_scroll_text((UI_string_type) message2, NULL, Cat111ScrolTextBg, *current_MMI_theme->list_normal_text_color, *current_MMI_theme->list_normal_text_color);

        gdi_layer_unlock_frame_buffer();

        ExitCategoryFunction = ExitCategory111Screen;
        dm_setup_category_functions(dm_redraw_category_screen, dm_get_category_history, dm_get_category_history_size);
        dm_data.s32ScrId = (S32) GetActiveScreenId();
        dm_data.s32CatId = MMI_CATEGORY111_ID;
        dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND | DM_NO_TITLE | DM_SHOW_VKPAD;
        dm_setup_data(&dm_data);
        {
            extern void cat257_virtual_keypad_callback(void);
            dm_register_vkpad_callback(cat257_virtual_keypad_callback);
        }
        dm_redraw_category_screen();
    
        Cat111CountDownValue = duration;
        if (Cat111CountDownValue != 0)
        {
            Cat111CountDownCallBack();
        }
    }
}   /* end of ShowCategory111Screen */


/*****************************************************************************
 * FUNCTION
 *  ExitCategory111Screen
 * DESCRIPTION
 *  Exits category 184 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory111Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    reset_multiline_inputbox();
    Cat111TimerExpireCallBack = UI_dummy_function;
    reset_softkeys();
    clear_left_softkey();
    clear_right_softkey();
    close_status_icons();
    wgui_close_singleline_inputbox();
#ifdef UI_SMALL_LIST_SCREEN
    restore_small_screen();
#endif 
}


#if defined(__MMI_CAT113_SUPPORT__)
static U8 g_wgui_cat113_number_of_icons = 0;
static PU8 *g_wgui_cat113_list_of_icons = NULL;
static U8 g_wgui_cat113_backup_scr_bg_opacity = 0;


/*****************************************************************************
 * FUNCTION
 *  RedrawCate113IconArray
 * DESCRIPTION
 *  Redraw category 113 icon array.
 *  This icon arry will be center alignment.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void RedrawCate113IconArray(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x, y, w, h, i, x_offset, y_offset, number_of_visible_icons, accumulated_width;
    S32 gap = 5;
    S32 img_w, img_h, max_h;
    GDI_RESULT ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    x = MMI_COMMON_CONTENT_X;
    y = CAT113_START_Y + MMI_MENUITEM_HEIGHT * 3;
    w = MMI_COMMON_CONTENT_WIDTH;
    h = MMI_MENUITEM_HEIGHT;
    number_of_visible_icons = 0;

    /* calculate visible icons */
    accumulated_width = max_h = 0;
    for (i = 0 ; i < g_wgui_cat113_number_of_icons ; i++)
    {
        ret = gdi_image_get_dimension(g_wgui_cat113_list_of_icons[i], &img_w, &img_h);
        if (ret >= 0)
        {
            img_w += gap;
            if ((accumulated_width + img_w) <= w)
            {
                accumulated_width += img_w;
                number_of_visible_icons++;

                max_h = (img_h > max_h) ? (img_h) : (max_h);
            }
            else
            {
                break;
            }
        }
    }
    max_h = (max_h > h) ? (h) : (max_h);

    x_offset = ((w - accumulated_width) >> 1);
    y_offset = ((h - max_h) >> 1);

    gdi_layer_push_clip();
    gdi_layer_set_clip(x, y, (x + w - 1), (y + h - 1));

    /* clear background */
    gdi_draw_solid_rect(x, y, (x + w - 1), (y + h - 1), GDI_COLOR_TRANSPARENT);

    /* display visible icons */
    accumulated_width = 0;
    for (i = 0 ; i < number_of_visible_icons ; i++)
    {
        ret = gdi_image_get_dimension(g_wgui_cat113_list_of_icons[i], &img_w, &img_h);
        if (ret >= 0)
        {
            img_w += gap;
            gdi_image_draw(x + x_offset + accumulated_width, y + y_offset, g_wgui_cat113_list_of_icons[i]);
            accumulated_width += img_w;
        }
    }

    gdi_layer_pop_clip();
}


/* For detail description, please refer to wgui_categories.h */
void UpdateCate113IconArray(U8 number_of_icons, PU8 *list_of_icons)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat113_number_of_icons = number_of_icons;
    g_wgui_cat113_list_of_icons = list_of_icons;
    RedrawCate113IconArray();
    gdi_lcd_repaint_all();
}


/*****************************************************************************
 * FUNCTION
 *  DrawCate113CategoryControlArea
 * DESCRIPTION
 *  Cateogry 113 control area redraw callback
 * PARAMETERS
 *  coordinate      [IN]     Area to redraw
 * RETURNS
 *  void
 *****************************************************************************/
static void DrawCate113CategoryControlArea(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(coordinate);
    RedrawCate113IconArray();
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory113Screen
 * DESCRIPTION
 *  Exit category 113
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void ExitCategory113Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat113_number_of_icons = 0;
    g_wgui_cat113_list_of_icons = NULL;
#ifdef __MMI_WALLPAPER_ON_BOTTOM__
    dm_set_scr_bg_opacity(g_wgui_cat113_backup_scr_bg_opacity);
#endif /* __MMI_WALLPAPER_ON_BOTTOM__ */ 
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategory113Screen(
        UI_string_type title,
        PU8 title_icon,
        UI_string_type left_softkey,
        PU8 left_softkey_icon,
        UI_string_type right_softkey,
        PU8 right_softkey_icon,
        UI_string_type message1,
        UI_string_type message2,
        UI_string_type message3,
        U8 number_of_icons,
        PU8 *list_of_icons,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);

    gdi_layer_lock_frame_buffer();

    /* set title */
    dm_add_title(title, title_icon);

    /* set softkey */
    dm_add_softkey(left_softkey, left_softkey_icon, right_softkey, right_softkey_icon);

    /* set messages */
    dm_add_string(message1, &MMI_medium_font,
        current_multi_line_input_box_theme->normal_text_color, UI_COLOR_BLACK, NULL);
    dm_add_string(message2, &MMI_medium_font,
        current_multi_line_input_box_theme->normal_text_color, UI_COLOR_BLACK, NULL);
    dm_add_string(message3, &MMI_medium_font,
        current_multi_line_input_box_theme->normal_text_color, UI_COLOR_BLACK, NULL);

    /* set icon array */
    g_wgui_cat113_number_of_icons = number_of_icons;
    g_wgui_cat113_list_of_icons = list_of_icons;

    /* set opacity */
#ifdef __MMI_WALLPAPER_ON_BOTTOM__
    dm_get_scr_bg_opacity(&g_wgui_cat113_backup_scr_bg_opacity);
    dm_set_scr_bg_opacity((U8)(current_MMI_theme->bg_opacity_low));
#endif 

    gdi_layer_unlock_frame_buffer();

    /* Setup category/draw manager data */
    ExitCategoryFunction = ExitCategory113Screen;
    dm_setup_category_functions(dm_redraw_category_screen, dummy_get_history, dummy_get_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY113_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    dm_setup_data(&dm_data);
    dm_register_category_controlled_callback(DrawCate113CategoryControlArea);
    dm_redraw_category_screen();
}
#endif /* defined(__MMI_CAT113_SUPPORT__) */


#ifdef __MMI_ENGINEER_MODE__
/*****************************************************************************
 * FUNCTION
 *  ExitCategory204Screen
 * DESCRIPTION
 *  Exits the category204 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void ExitCategory204Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inputs_sl_reset();
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategory204Screen(
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U16 NotificationStringId,
        U16 value,
        U16 imageId,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    UI_string_type text[5];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);
    UI_UNUSED_PARAMETER(imageId);
    gdi_layer_lock_frame_buffer();
    
    dm_add_softkey(get_string(left_softkey), get_image(left_softkey_icon), get_string(right_softkey), get_image(right_softkey_icon));

    MMI_title_string = (UI_string_type) get_string(NotificationStringId);

    gui_itoa(value, (UI_string_type) text, 10);
    wgui_inputs_sl_create_set_buffer(
        (UI_string_type) text,
        gui_strlen((UI_string_type) text) + 1,
        gui_strlen((UI_string_type) text),
        gui_strlen((UI_string_type) text));
    wgui_inputs_sl_set_mask(0);
    MMI_singleline_inputbox.normal_text_color = gui_color(0, 0, 0);
    MMI_singleline_inputbox.flags |=
        (UI_SINGLE_LINE_INPUT_BOX_DISABLE_BACKGROUND | UI_SINGLE_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW |
         UI_SINGLE_LINE_INPUT_BOX_CENTER_JUSTIFY);

    gdi_layer_unlock_frame_buffer();
    ExitCategoryFunction = ExitCategory204Screen;
    dm_setup_category_functions(dm_redraw_category_screen, dm_get_category_history, dm_get_category_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY204_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory205Screen
 * DESCRIPTION
 *  Displays the category205 screen
 * PARAMETERS
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the Left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  message                 [IN]        String to be displayed.
 *  message_icon            [IN]        Id of image to be displayed.
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory205Screen(
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        UI_string_type message,
        U16 message_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 l;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    dm_reset_context();

    UI_UNUSED_PARAMETER(history_buffer);

    gdi_layer_lock_frame_buffer();
    wgui_title_set_menu_shortcut_number(-1);

    dm_add_softkey(
        (UI_string_type)GetString(left_softkey), 
        (PU8)GetImage(left_softkey_icon),       
        (UI_string_type)GetString(right_softkey),
        (PU8)GetImage(right_softkey_icon));

    MMI_message_string = (UI_string_type) message;
    l = gui_strlen(MMI_message_string);
    wgui_inputs_ml_create_set_buffer(MMI_message_string, l, l, 0);
    MMI_multiline_inputbox.flags |=
        (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY |
         UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND | UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR);
    gui_set_font(MMI_multiline_inputbox.text_font);

    dm_add_image(get_image(message_icon), NULL, NULL);

    register_hide_status_icon_bar(0, MMI_dummy_function);
    register_hide_status_icon_bar(1, MMI_dummy_function);

    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = MMI_dummy_function;
    dm_setup_category_functions(dm_redraw_category_screen, dm_get_category_history, dm_get_category_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY205_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}
#endif /* __MMI_ENGINEER_MODE__ */ 


#if defined(__MMI_CAT116_SUPPORT__)

void(*g_wgui_cat116_resize_and_draw_func) (S32); /* for input method to tell category the height of virtual keyboard */

#if defined (__MMI_WALLPAPER_ON_BOTTOM__)
static U8 g_wgui_cat116_editor_scr_bg_opacity;
#endif /* defined (__MMI_WALLPAPER_ON_BOTTOM__) */


/*****************************************************************************
 * FUNCTION
 *  wgui_cat116_set_right_softkey_function
 * DESCRIPTION
 *  set category116 right softkey function
 * PARAMETERS
 *  f       [IN]        
 *  k       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat116_set_right_softkey_function(void (*f) (void), MMI_key_event_type k)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(k);
    wgui_singleline_inputbox_RSK_function = f;
}


#if defined(__MMI_TOUCH_SCREEN__)
/*****************************************************************************
 * FUNCTION
 *  wgui_cat116_get_hw_area
 * DESCRIPTION
 *  Get hand writing area 
 * PARAMETERS
 *  x       [IN/OUT]   X coordinate of hand writing area
 *  y       [IN/OUT]   Y coordinate of hand writing area
 *  w       [IN/OUT]   Width of hand writing area
 *  h       [IN/OUT]   Height of  hand writing area
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat116_get_hw_area(S32 *x, S32 *y, S32 *w, S32 *h)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *x = CAT116_CONTENT_X;
    *y = CAT116_CONTENT_Y;
    *w = CAT116_CONTENT_W - current_MMI_theme->scrollbar_size;
    *h = MMI_singleline_inputbox.y + MMI_singleline_inputbox.height - CAT116_CONTENT_Y;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat116_virtual_keypad_callback
 * DESCRIPTION
 *  Callback function of virtual keyboard
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat116_virtual_keypad_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_imc_redraw_screen_by_state();
}
#endif /* defined(__MMI_TOUCH_SCREEN__) */ 


/*****************************************************************************
 * FUNCTION
 *  wgui_cat116_resize_and_draw
 * DESCRIPTION
 *  1. resize multiline inputbox 
 *  2. arrange multiline inputbox, information bar, and singleline inputbox
 * PARAMETERS
 *  virtual_keyboard_h            [IN]          Height of virtual keyboard
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat116_resize_and_draw(S32 virtual_keyboard_h)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 multiline_h, singleline_y;
    S32 gap;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();    

    gap = (virtual_keyboard_h <= 2) ? 2 : 0 /* border */;
    
    /* set singleline inputbox position */
    singleline_y = UI_device_height - MMI_BUTTON_BAR_HEIGHT - virtual_keyboard_h - gap - MMI_SINGLELINE_INPUTBOX_HEIGHT - 1;
    move_singleline_inputbox(CAT116_CONTENT_X, singleline_y); 

    /* set information bar position */
    wgui_setup_input_information( 
            MMI_singleline_inputbox.x,
            MMI_singleline_inputbox.y - wgui_inputbox_information_bar_height,
            MMI_singleline_inputbox.width,
            wgui_inputbox_information_bar_height);

    /* set multiline inputbox position and resize it */
    multiline_h = wgui_inputbox_information_bar_y - CAT116_CONTENT_Y + 1;
    resize_multiline_inputbox(CAT116_CONTENT_W, multiline_h);
    move_multiline_inputbox(CAT116_CONTENT_X, CAT116_CONTENT_Y);    

    /* clear background and show multiline inputbox, singleline inputbox, and information bar */  
    gdi_draw_solid_rect(
		0, 
		CAT116_CONTENT_Y, 
		UI_device_width - 1, 
		UI_device_height - MMI_BUTTON_BAR_HEIGHT - virtual_keyboard_h - 1,
		GDI_COLOR_TRANSPARENT);
    show_multiline_inputbox();
    show_singleline_inputbox();
    wgui_redraw_singleline_input_information_bar();
    
    gdi_layer_unlock_frame_buffer();
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory116Screen
 * DESCRIPTION
 *  Exit Orange call plan screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory116Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    reset_multiline_inputbox();
    wgui_close_singleline_inputbox();
#ifdef __MMI_WALLPAPER_ON_BOTTOM__
    dm_set_scr_bg_opacity(g_wgui_cat116_editor_scr_bg_opacity);
#endif /* __MMI_WALLPAPER_ON_BOTTOM__ */
    g_wgui_cat116_resize_and_draw_func = NULL;
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory116HistorySize
 * DESCRIPTION
 *  Gets the history buffer size of category 116
 * PARAMETERS
 *  void
 * RETURNS
 *  size in U8s of the history buffer
 *****************************************************************************/
S32 GetCategory116HistorySize(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (((sizeof(singleline_inputbox_category_history) + 3) / 4) * 4 + sizeof(multiline_inputbox_category_history));
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory200History
 * DESCRIPTION
 *  Gets the history buffer of category116
 * PARAMETERS
 *  history_buffer      [OUT]        Is the buffer into which the history data is stored
 * RETURNS
 *  return history buffer
 *****************************************************************************/
U8 *GetCategory116History(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 s;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	get_singleline_inputbox_category_history(MMI_CATEGORY116_ID, history_buffer);
    s = sizeof(singleline_inputbox_category_history);
    s = (s + 3) / 4;
    s *= 4;
    get_multiline_inputbox_category_history(MMI_CATEGORY116_ID, (U8*) (history_buffer + s));
    return (history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory116Screen
 * DESCRIPTION
 *  Display Orange call plan screen
 * PARAMETERS
 *  left_softkey                [IN]        Left softkey label
 *  left_softkey_icon           [IN]        Icon for the Left softkey
 *  right_softkey               [IN]        Right softkey label
 *  right_softkey_icon          [IN]        Icon for the right softkey
 *  message                     [IN]        Message shown in multiline inputbox
 *  input_buffer                [IN]        Singleline inputbox input buffer
 *  input_buffer_size           [IN]        Input buffer size (Orange call plan max is 183)
 *  input_type                  [IN]        Input method
 *  history_buffer              [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory116Screen(
        UI_string_type left_softkey,
        PU8 left_softkey_icon,
        UI_string_type right_softkey,
        PU8 right_softkey_icon,
        UI_string_type message,
        UI_buffer_type input_buffer,
        S32 input_buffer_size,
        U32 input_type,
        UI_buffer_type history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 msg_length, singleline_history_size;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    /* softkey */
    dm_add_softkey(left_softkey, left_softkey_icon, right_softkey, right_softkey_icon);
    SetupCategoryKeyHandlers();

    g_wgui_cat116_resize_and_draw_func = wgui_cat116_resize_and_draw;

    /* multiline inputbox */
    msg_length = gui_strlen(message);
    create_multiline_inputbox_set_buffer(message, msg_length, msg_length, 0);
    if (history_buffer != NULL)
    {
        singleline_history_size = sizeof(singleline_inputbox_category_history);
        singleline_history_size = (singleline_history_size + 3) / 4;
        singleline_history_size *= 4;
        set_multiline_inputbox_category_history(MMI_CATEGORY116_ID, (U8*) (history_buffer + singleline_history_size));
    }
    else
    {
        set_multiline_inputbox_category_history(MMI_CATEGORY116_ID, NULL);
    }
    MMI_multiline_inputbox.flags |=
        (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW |
         UI_MULTI_LINE_INPUT_BOX_VIEW_MODE |
         UI_MULTI_LINE_INPUT_BOX_TRANSPARENT_BACKGROUND |
         UI_MULTI_LINE_INPUT_BOX_AUTO_DISABLE_SCROLLBAR);
    MMI_multiline_inputbox.ext_flags |= GUI_MULTI_LINE_INPUT_BOX_FIXED_Y_OFFSET;

    /* set flags for singleline editor */
    MMI_current_input_ext_type |= INPUT_TYPE_EXT_NO_SHOW_NEW_LINE_SYMBOL;

    register_multiline_inputbox_viewer_keys();

	/* singleline inputbox */
    wgui_setup_singleline_inputbox(
			CAT116_SINGLELINE_INPUTBOX_X, 
			CAT116_SINGLELINE_INPUTBOX_Y, 
			CAT116_SINGLELINE_INPUTBOX_W, 
			CAT116_SINGLELINE_INPUTBOX_H, 
			input_buffer, 
			input_buffer_size, 
			MMI_CATEGORY116_ID, 
			right_softkey, 
			right_softkey_icon, 
			input_type, 
			history_buffer,
			1); 
    
    /* information bar */
    wgui_setup_input_information(
                   MMI_singleline_inputbox.x,
                   MMI_singleline_inputbox.y - wgui_inputbox_information_bar_height,
                   MMI_singleline_inputbox.width,
                   wgui_inputbox_information_bar_height);

#ifdef __MMI_WALLPAPER_ON_BOTTOM__
    wgui_set_wallpaper_on_bottom(MMI_TRUE);
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_TRANSPARENT_BACKGROUND;
    dm_get_scr_bg_opacity(&g_wgui_cat116_editor_scr_bg_opacity);
    dm_set_scr_bg_opacity((U8)(current_MMI_theme->bg_opacity_low));
#endif 
        
    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = ExitCategory116Screen;
    dm_setup_category_functions(dm_redraw_category_screen, GetCategory116History, GetCategory116HistorySize);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY116_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND | DM_SET_AS_ABM_LAYER | DM_SINGLE_LINE_INPUT_BOX_WITH_INFORMATION_BAR;
#if defined(__MMI_TOUCH_SCREEN__)
    dm_data.s32flags |= DM_SHOW_VKPAD;
    dm_register_vkpad_callback(wgui_cat116_virtual_keypad_callback);
#endif /* defined(__MMI_TOUCH_SCREEN__) */
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();

    MMI_multiline_inputbox.ext_flags &= ~GUI_MULTI_LINE_INPUT_BOX_FIXED_Y_OFFSET;
}
#endif /* defined(__MMI_CAT116_SUPPORT__) */


/*****************************************************************************
 * FUNCTION
 *  category88_handle_down_key
 * DESCRIPTION
 *  handle key down of category88
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void category88_handle_down_key(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    wgui_hide_slide_control_focus();
    if (MMI_current_slide_control == &MMI_slide_control[dm_get_slide_control_count() - 1])
    {
        MMI_current_slide_control = &MMI_slide_control[0];
    }
    else
    {
        MMI_current_slide_control++;
    }
    wgui_slide_control_set_focus(MMI_current_slide_control);
    wgui_show_slide_control_focus();

    gdi_layer_unlock_frame_buffer();
    gdi_lcd_repaint_all();
}


/*****************************************************************************
 * FUNCTION
 *  category88_handle_up_key
 * DESCRIPTION
 *  handle key up of category88
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void category88_handle_up_key(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    wgui_hide_slide_control_focus();
    if (MMI_current_slide_control == &MMI_slide_control[0])
    {
        MMI_current_slide_control = &MMI_slide_control[dm_get_slide_control_count() - 1];
    }
    else
    {
        MMI_current_slide_control--;
    }
    wgui_slide_control_set_focus(MMI_current_slide_control);
    wgui_show_slide_control_focus();

    gdi_layer_unlock_frame_buffer();
    gdi_lcd_repaint_all();
}


/*****************************************************************************
 * FUNCTION
 *  category88_keyboard_key_handler
 * DESCRIPTION
 *  keyboard handler of category88(Only for Win32 environment)
 * PARAMETERS
 *  vkey_code       [IN]        Key code to identify the key
 *  key_state       [IN]        The state of key
 * RETURNS
 *  void
 *****************************************************************************/
static void category88_keyboard_key_handler(S32 vkey_code, S32 key_state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(vkey_code);
    UI_UNUSED_PARAMETER(key_state);
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory88Screen
 * DESCRIPTION
 *  Exits the Double Slide control screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void ExitCategory88Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_message_string = NULL;
    MMI_message_string2 = NULL;
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategory88Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U16 bg_image_id,
        U16 n_items,
        U8 **string_list,
        S32 *lower_limit,
        S32 *upper_limit,
        S32 **current_value,
        void (**cb_func) (S32 value),
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 idx = 0;
    dm_data_struct dm_data;
    U8 h_flag;
    color c = gui_color(0, 0, 0);
    color wc = gui_color(255, 255, 255);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(n_items <= MMI_MAX_SLIDE_CONTROL);

    dm_reset_context();
    UI_UNUSED_PARAMETER(history_buffer);

    MMI_ASSERT(lower_limit != NULL);
    MMI_ASSERT(upper_limit != NULL);
    MMI_ASSERT(current_value != NULL);

    gdi_layer_lock_frame_buffer();

    wgui_title_set_menu_shortcut_number(-1);

    dm_add_title(get_string(title), get_image(title_icon));
    dm_add_softkey(get_string(left_softkey), get_image(left_softkey_icon), get_string(right_softkey), get_image(right_softkey_icon));

    h_flag = set_slide_control_category_history((U16) (MMI_CATEGORY88_1ITEM_ID + n_items - 1), (U8*) history_buffer);
    if (h_flag)
    {
        /* the number of slide controls should be the same as the number kept in history */
        MMI_ASSERT(h_flag == n_items);

        for (idx = 0; idx < n_items; idx++)
        {
            *current_value[idx] = *MMI_slide_control_value[idx];
        }
    }
    else
    {
        for (idx = 0; idx < n_items; idx++)
        {
            MMI_slide_control_value[idx] = (current_value[idx]);
        }

        MMI_current_slide_control = &MMI_slide_control[0];
        MMI_current_slide_control_value = (S32*) MMI_slide_control_value[0];            
    }

    /* Avoid NULL pointer in global context */
    MMI_ASSERT(MMI_current_slide_control && MMI_current_slide_control_value);

    for (idx = 0; idx < n_items; idx++)
    {
        if (string_list)
        {
            dm_add_string((UI_string_type) string_list[idx], &MMI_default_font, c, wc, NULL);
            if (cb_func != NULL)
            {
                dm_add_slide_control(
                    lower_limit[idx],
                    upper_limit[idx],
                    *current_value[idx],
                    cb_func[idx],
                    string_list[idx]);
            }
            else
            {
                dm_add_slide_control(lower_limit[idx], upper_limit[idx], *current_value[idx], NULL, string_list[idx]);
            }
        }
        else
        {
            if (cb_func != NULL)
            {
                dm_add_slide_control(lower_limit[idx], upper_limit[idx], *current_value[idx], cb_func[idx], NULL);
            }
            else
            {
                dm_add_slide_control(lower_limit[idx], upper_limit[idx], *current_value[idx], NULL, NULL);
            }

        }
    }

    SetKeyHandler(wgui_slide_control_previous, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(wgui_slide_control_next, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(category88_handle_up_key, KEY_VOL_UP, KEY_EVENT_DOWN);
    SetKeyHandler(category88_handle_down_key, KEY_VOL_DOWN, KEY_EVENT_DOWN);
    SetKeyHandler(category88_handle_up_key, KEY_UP_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(category88_handle_down_key, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
    register_keyboard_key_handler(category88_keyboard_key_handler);

    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = ExitCategory88Screen;
    dm_setup_category_functions(dm_redraw_category_screen, dm_get_category_history, dm_get_category_history_size);
    dm_data.s32CatId = MMI_CATEGORY88_1ITEM_ID + n_items - 1;
    dm_data.s32ScrId = GetActiveScreenId();
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategory87Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        S32 l_limit,
        S32 u_limit,
        S32 *current_value,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    S32 lower_limit[1], upper_limit[1];
    S32 *curr_value[1];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    lower_limit[0] = l_limit;
    upper_limit[0] = u_limit;
    curr_value[0] = current_value;
    ShowCategory88Screen(
        title,
        title_icon,
        left_softkey,
        left_softkey_icon,
        right_softkey,
        right_softkey_icon,
        0,
        1,
        NULL,
        lower_limit,
        upper_limit,
        curr_value,
        NULL,
        history_buffer);
}   /* end of ShowCategory87Screen */


#ifdef __MMI_CALORIE__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __MMI_CALORIE__ */ 


/*****************************************************************************
 * FUNCTION
 *  ShowCategory119Screen
 * DESCRIPTION
 *  Displays the category119 screen
 * PARAMETERS
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Left softkey icon
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Right softkey icon
 *  message                 [?]         
 *  message_icon            [IN]        
 *  history_buffer          [IN]        History buffer
 *  icon(?)                 [IN]        Message Icon
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory119Screen(
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U8 *message,
        U16 message_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 l;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);
    gdi_layer_lock_frame_buffer();
    wgui_title_set_menu_shortcut_number(-1);
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    SetupCategoryKeyHandlers();
    MMI_message_string = (UI_string_type) message;
    l = gui_strlen(MMI_message_string);
    create_multiline_inputbox_set_buffer(MMI_message_string, l, l, 0);
    MMI_multiline_inputbox.flags |=
        (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY |
         UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND | UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR);

    dm_add_image(get_image(message_icon), NULL, NULL);

    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = ExitCategory119Screen;
    dm_setup_category_functions(dm_redraw_category_screen, dm_get_category_history, dm_get_category_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY119_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();

}   /* end of ShowCategory119Screen */


/*****************************************************************************
 * FUNCTION
 *  ExitCategory119Screen
 * DESCRIPTION
 *  Exits the category119 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory119Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_hide_animations();
}   /* end of ExitCategory119Screen */


/*****************************************************************************
 * FUNCTION
 *  cat129_clear_icon_bg
 * DESCRIPTION
 *  Clear button background function
 * PARAMETERS
 *  button      [IN]        Button pointer
 * RETURNS
 *  void
 *****************************************************************************/
void cat129_clear_icon_bg(void *button)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    icontext_button *b = (icontext_button*) button;
    S32 x1 = b->x;
    S32 y1 = b->y;
    S32 x2 = b->x + b->width - 1;
    S32 y2 = b->y + b->height - 1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();

    gdi_layer_set_clip(x1, y1, x2 + 1, y2 + 1);
    gdi_draw_solid_rect(MMI_title_x, MMI_title_y, MMI_title_x + MMI_title_width - 1, MMI_title_y + MMI_title_height - 1, GDI_COLOR_TRANSPARENT);    /* 061705 Calvin added */
    if (title_bg_id != 0)
    {
        gdi_image_draw_id(MMI_title_x, MMI_title_y, title_bg_id);
    }
    else
    {
        gui_draw_filled_area(
            MMI_title_x,
            MMI_title_y,
            MMI_title_x + MMI_title_width - 1,
            MMI_title_y + MMI_title_height - 1,
            current_UI_theme->window_title_theme->active_filler);
    }
    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  cat129_get_image_handle
 * DESCRIPTION
 *  get the animation handle for cat 129
 * PARAMETERS
 *  void
 * RETURNS
 *  gdi_handle
 *****************************************************************************/
gdi_handle cat129_get_image_handle(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return dm_get_image_handle(0);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat129_animation_pre_callback
 * DESCRIPTION
 *  set the animation pre callback handle for cat 129
 * PARAMETERS
 *  result    [IN]    GDI result
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat129_animation_pre_callback(GDI_RESULT result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    UpdateStatusIcons();
    gdi_layer_unlock_frame_buffer();
}
#if !defined(__GDI_MEMORY_PROFILE_2__)
/*****************************************************************************
 * FUNCTION
 *  wgui_cat129_draw_ctrl_area1
 * DESCRIPTION
 *  draw the category control area 1 for category 129
 * PARAMETERS
 *  coordinate  [IN]    coordinate
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat129_draw_ctrl_area1(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 img_w = 1, img_h = 1;
    S32 x = 0, y = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gdi_layer_set_clip(MMI_content_x, MMI_content_y, MMI_content_x + MMI_content_width - 1, MMI_content_y + MMI_content_height - 1);

    /* clear */
    gdi_draw_solid_rect(0, 0, UI_device_width - 1, UI_device_height - 1, GDI_COLOR_WHITE);

    /* draw image */
    gui_measure_image(MMI_message_icon, &img_w, &img_h);
    if (img_w < UI_device_width)
    {
        x = ((UI_device_width - img_w) >> 1);
    }
    if (img_h < UI_device_height)
    {
        y = ((UI_device_height - img_h) >> 1);
    }
    gdi_image_draw_animation(x, y, (S8*)MMI_message_icon, &animation_handle);
    gdi_anim_set_draw_before_callback(wgui_cat129_animation_pre_callback);

    gdi_layer_pop_clip();
}
#endif /* !defined(__GDI_MEMORY_PROFILE_2__) */


/*****************************************************************************
 * FUNCTION
 *  wgui_cat130_draw_ctrl_area1
 * DESCRIPTION
 *  Draws the category130 category control area
 * PARAMETERS
 *  coordinate      [IN/OUT]        Coordinates of category controlled area.
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat130_draw_ctrl_area1(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_clear(GDI_COLOR_WHITE);
    gui_draw_filled_area(0, 0, UI_device_width, UI_device_height, current_MMI_theme->idle_bkg_filler);
}

/*****************************************************************************
 * FUNCTION
 *  wgui_cat129_exit
 * DESCRIPTION
 *  Exits the category129 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat129_exit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_hide_animations();

    title_bg_id = 0;
    wgui_reset_touch_title_bar_buttons();
}

static void ShowCategory129ScreenInternal(
        UI_string_type title,
        PU8 title_icon,
        UI_string_type left_softkey,
        PU8 left_softkey_icon,
        UI_string_type right_softkey,
        PU8 right_softkey_icon,
        U16 message_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
#if defined(__MMI_TOUCH_SCREEN__)
    U16 btn_prev_item_id = 0, btn_next_item_id = 0;
#endif /* defined(__MMI_TOUCH_SCREEN__) */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);

    gdi_layer_lock_frame_buffer();
    dm_add_title(title, title_icon);
    dm_add_softkey(left_softkey, left_softkey_icon, right_softkey, right_softkey_icon);
    wgui_softkey_set_filler_disabled(MMI_TRUE);
    if(message_icon != 0)
    {
#if defined(__GDI_MEMORY_PROFILE_2__)
        /* use new layer instead of scr_bg layer to draw wallpaper */
        dm_add_image(get_image(message_icon), NULL, NULL);
#if defined(GUI_COMMON_SHOW_STATUS_ICON)
        dm_set_image_blt_before_callback(0, wgui_cat129_animation_pre_callback);
#endif
        wgui_set_wallpaper_on_bottom(MMI_TRUE);
#else /* defined(__GDI_MEMORY_PROFILE_2__) */
        MMI_message_icon = (PU8)get_image(message_icon);
#endif /* defined(__GDI_MEMORY_PROFILE_2__) */
    }
    else
    {
         wgui_set_wallpaper_on_bottom(MMI_TRUE);
    }
    gdi_layer_get_base_handle(&wgui_base_layer);
    wgui_status_icon_set_display_layer(wgui_base_layer);

    /* check if the title bar buttons are enabled for the particular screen. */
    if (wgui_is_touch_title_bar_buttons())
    {
#if defined(__MMI_TOUCH_SCREEN__)
        btn_prev_item_id = 
#endif /* defined(__MMI_TOUCH_SCREEN__) */
                    dm_add_button(
                            NULL,
                            get_image(LEFT_RED_ARROW),
                            get_image(LEFT_RED_ARROW),
                            cat129_clear_icon_bg);

#if defined(__MMI_TOUCH_SCREEN__)
        btn_next_item_id = 
#endif /* defined(__MMI_TOUCH_SCREEN__) */
                    dm_add_button(
                            NULL,
                            get_image(RIGHT_RED_ARROW),
                            get_image(RIGHT_RED_ARROW),
                            cat129_clear_icon_bg);
        title_bg_id = IMAGE_VIEW_TITLEBAR_BG;   /* for showing different title bar. */
    }
    gdi_layer_unlock_frame_buffer();
#if defined(__MMI_TOUCH_SCREEN__)
    if (wgui_is_touch_title_bar_buttons())
    {
        /* register the handler for pen event down istead of pen event up */
        dm_register_button_functions(btn_prev_item_id, KEY_EVENT_UP, gMMI_touch_title_button1_down_handler);
        dm_register_button_functions(btn_next_item_id, KEY_EVENT_UP, gMMI_touch_title_button2_down_handler);
    }
#endif /* defined(__MMI_TOUCH_SCREEN__) */ 
    dm_setup_category_functions(dm_redraw_category_screen, dummy_get_history, dummy_get_history_size);
    if(message_icon != 0)
    {
        dm_data.s32CatId = MMI_CATEGORY129_ID;
#if !defined(__GDI_MEMORY_PROFILE_2__)
        dm_register_category_controlled_callback(wgui_cat129_draw_ctrl_area1);
#endif /* !defined(__GDI_MEMORY_PROFILE_2__) */
    }
    else
    {
        dm_data.s32CatId = MMI_CATEGORY130_ID;
        dm_register_category_controlled_callback(wgui_cat130_draw_ctrl_area1);
    }
    ExitCategoryFunction = wgui_cat129_exit;
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND |DM_SET_AS_ABM_LAYER;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();

}


/* For detail description, please refer to wgui_categories.h */
void ShowCategory129Screen(
        U8 *title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U16 message_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ShowCategory129ScreenInternal(
            (UI_string_type) title,
            get_image(title_icon),
            get_string(left_softkey),
            get_image(left_softkey_icon),
            get_string(right_softkey),
            get_image(right_softkey_icon),
            message_icon,
            history_buffer);

}

/*****************************************************************************
 * FUNCTION
 *  ShowCategory130Screen
 * DESCRIPTION
 *  Displays the category130 screen,show system theme wallpaper
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon displayed with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Left softkey icon
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Right softkey icon
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory130Screen(
        U8 *title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ShowCategory129ScreenInternal(
            (UI_string_type) title,
            get_image(title_icon),
            get_string(left_softkey),
            get_image(left_softkey_icon),
            get_string(right_softkey),
            get_image(right_softkey_icon),
            0,
            history_buffer);
}

static MMI_BOOL g_wgui_cat132_is_fullscreen = MMI_FALSE;


/* For detail description, please refer to wgui_categories.h */
static void wgui_cat132_exit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat132_is_fullscreen = MMI_FALSE;
}


/* For detail description, please refer to wgui_categories.h */
void wgui_cat132_enable_fullscreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat132_is_fullscreen = MMI_TRUE;
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategory132Screen(
        U8 *title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U16 message_icon,
        U8 *history_buffer)
{
    
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);
    
    gdi_layer_lock_frame_buffer();

    /* Title */
    wgui_title_set_menu_shortcut_number(-1);
    dm_add_title((UI_string_type)title, get_image(title_icon));

    if (!g_wgui_cat132_is_fullscreen)
    {
        dm_add_softkey(get_string(left_softkey), get_image(left_softkey_icon), get_string(right_softkey), get_image(right_softkey_icon));
    }

    dm_add_image(get_image(message_icon), NULL, NULL);
    
    gdi_layer_unlock_frame_buffer();
    
    ExitCategoryFunction = wgui_cat132_exit;
    
    dm_setup_category_functions(dm_redraw_category_screen, dummy_get_history, dummy_get_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = (g_wgui_cat132_is_fullscreen) ? (MMI_CATEGORY132_FULLSCREEN_ID) : (MMI_CATEGORY132_ID);
#if defined(__MMI_SCREEN_ROTATE__)
    dm_data.s32CatId = (mmi_frm_is_screen_width_height_swapped()) ? (MMI_CATEGORY132_ROTATE_ID) : (dm_data.s32CatId);
#endif /* defined(__MMI_SCREEN_ROTATE__) */
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND_COLOR;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}   /* end of ShowCategory132Screen */


/* structure usedto store one big line in to two lines */

typedef struct _split_lines
{
    U8 str_line1[126];
    U8 str_line2[126];
    U8 no_of_lines;
} SPILTLINES;

SPILTLINES *split_buffer = NULL;


/*****************************************************************************
 * FUNCTION
 *  ExitCategory141Screen
 * DESCRIPTION
 *  Exits the Message Received screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void ExitCategory141Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_switch_title_with_status_bar)
    {
        wgui_switch_title_with_status_bar = 0;
    }
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategory141Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U8 *message,
        U16 message_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 l;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);

    gdi_layer_lock_frame_buffer();

    wgui_title_set_menu_shortcut_number(-1);
    dm_add_softkey(
        get_string(left_softkey), 
        get_image(left_softkey_icon), 
        get_string(right_softkey), 
        get_image(right_softkey_icon));

    gui_set_font(&MMI_medium_font);
    if (title == 0)
    {
        wgui_switch_title_with_status_bar = 1;
        ShowStatusIconsTitle();
    }
    else
    {
        dm_add_title(get_string(title), get_image(title_icon));
        wgui_switch_title_with_status_bar = 0;
    }
    l = gui_strlen((UI_string_type) message);
    wgui_inputs_ml_create_set_buffer((UI_string_type) message, l, l, 0);
    MMI_multiline_inputbox.normal_text_color = gui_color(0, 0, 0);
    MMI_multiline_inputbox.flags |=
        UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND | UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY |
        UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE |
        UI_MULTI_LINE_INPUT_BOX_AUTO_DISABLE_SCROLLBAR | UI_MULTI_LINE_INPUT_BOX_USE_ENCODING_BASED_LENGTH;

    dm_add_image(get_image(message_icon), NULL, NULL);

    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = ExitCategory141Screen;
    dm_setup_category_functions(dm_redraw_category_screen, dm_get_category_history, dm_get_category_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND_COLOR | DM_SET_NEW_LAYER_ACTIVE;

    if (wgui_switch_title_with_status_bar == 1)
    {
        dm_data.s32CatId = MMI_CATEGORY141_STATUS_ICON_ID;
    }
    else
    {
        dm_data.s32CatId = MMI_CATEGORY141_ID;
    }
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}


/*****************************************************************************
 * FUNCTION
 *  category_142_redraw_highlighted_item
 * DESCRIPTION
 *  Redraw the highlighted item(selected image) of category 142.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void category_142_redraw_highlighted_item(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 index, img_width, img_height;
    PU8 img;
    color c;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (animation_handle != GDI_ERROR_HANDLE)
    {
        gdi_image_stop_animation(animation_handle);
    }
    if (category_142_image_list != NULL)
    {
        if (category_142_image_list_index != NULL)
        {
            index = *category_142_image_list_index;
        }
        else
        {
            index = 0;
        }

        if (!wgui_switch_title_with_status_bar && (category_142_list_of_titles != NULL))
        {
            MMI_title_string = (UI_string_type) category_142_list_of_titles[index];
            draw_title();
        }
        c = gui_color(255, 255, 255);
        gdi_layer_push_clip();

        if (r2lMMIFlag)
        {
            gdi_layer_set_clip(
                current_MMI_theme->scrollbar_size,
                (MMI_title_y + MMI_title_height),
                UI_device_width - 1,
                UI_device_height - MMI_button_bar_height - 1);
        }
        else
        {
            gdi_layer_set_clip(
                0,
                (MMI_title_y + MMI_title_height),
                UI_device_width - current_MMI_theme->scrollbar_size - 1,
                UI_device_height - MMI_button_bar_height - 1);
        }

        gui_fill_rectangle(
            0,
            (MMI_title_y + MMI_title_height),
            UI_device_width - 1,
            UI_device_height - MMI_button_bar_height - 1,
            c);
        if (category_142_image_list[index])
        {
            img = get_image(category_142_image_list[index]);
        }
        else
        {
            img = category_142_image_file_name_list[index];
        }
        gui_measure_image(img, &img_width, &img_height);
        if (r2lMMIFlag)
        {
            if (gdi_image_draw_animation((UI_device_width - img_width + current_MMI_theme->scrollbar_size) >> 1, (UI_device_height - img_height) >> 1, (U8*) img, &animation_handle) < 0)      /* 033105 Calvin modified */
            {
                animation_handle = GDI_ERROR_HANDLE;
            }
        }
        else
        {
            if (gdi_image_draw_animation((UI_device_width - img_width) >> 1, (UI_device_height - img_height) >> 1, (U8*) img, &animation_handle) < 0)  /* 033105 Calvin modified */
            {
                animation_handle = GDI_ERROR_HANDLE;
            }
        }
        gdi_layer_pop_clip();

        /* Uncomment below line for auto-disable scrollbar    */
        if(category_142_image_list_n_items > 1)
        {
            gui_set_vertical_scrollbar_range(&category142_vbar, category_142_image_list_n_items);
            gui_set_vertical_scrollbar_scale(&category142_vbar, 1);
            gui_set_vertical_scrollbar_value(&category142_vbar, index);

            if (r2lMMIFlag)
            {
                /* move vertical scrollbar to the left side */
                gui_move_vertical_scrollbar(
                        &category142_vbar, 
                        0, 
                        category142_vbar.y);
            }

            gui_show_vertical_scrollbar(&category142_vbar);
        }
    }
    gdi_layer_blt_previous(
        0,
        (MMI_title_y + MMI_title_height),
        UI_device_width - 1,
        UI_device_height - MMI_button_bar_height);
}


/*****************************************************************************
 * FUNCTION
 *  category_142_highlight_handler
 * DESCRIPTION
 *  hightlight handler of category 142
 * PARAMETERS
 *  index       [IN]        The index of highlighted item
 * RETURNS
 *  void
 *****************************************************************************/
static void category_142_highlight_handler(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_title_set_menu_shortcut_number(index + 1);
    if (!wgui_title_get_menu_shortcut_handler_display())
    {
        gui_redraw_menu_shortcut();
    }
    MMI_list_highlight_handler(index);
}


/*****************************************************************************
 * FUNCTION
 *  category_142_goto_item
 * DESCRIPTION
 *  go to specific item of category 142
 * PARAMETERS
 *  index       [IN]        The index of item to go
 * RETURNS
 *  void
 *****************************************************************************/
static void category_142_goto_item(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (category_142_image_list_index != NULL)
    {
        if (index < 0)
        {
            return; /* index=0; */
        }
        if (index > (category_142_image_list_n_items - 1))
        {
            return; /* index=category_142_image_list_n_items-1;  */
        }
        *category_142_image_list_index = index;
    }
    category_142_highlight_handler(index);
    category_142_redraw_highlighted_item();
}


/*****************************************************************************
 * FUNCTION
 *  category_142_goto_previous_item
 * DESCRIPTION
 *  go to previous item of category142
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void category_142_goto_previous_item(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 index = *category_142_image_list_index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    index--;
    if (index < 0)
    {
        index = category_142_image_list_n_items - 1;
    }
    *category_142_image_list_index = index;
    category_142_redraw_highlighted_item();
    category_142_highlight_handler(index);
}


/*****************************************************************************
 * FUNCTION
 *  category_142_goto_next_item
 * DESCRIPTION
 *  go to next item of category142
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void category_142_goto_next_item(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 index = *category_142_image_list_index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    index++;
    if (index > (category_142_image_list_n_items - 1))
    {
        index = 0;
    }
    *category_142_image_list_index = index;
    category_142_redraw_highlighted_item();
    category_142_highlight_handler(index);
}


/*****************************************************************************
 * FUNCTION
 *  category_142_key_handler
 * DESCRIPTION
 *  handle key handlers of catefory 142
 * PARAMETERS
 *  vkey_code       [IN]        To identify the key
 *  key_state       [IN]        The state of the key
 * RETURNS
 *  void
 *****************************************************************************/
static void category_142_key_handler(S32 vkey_code, S32 key_state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(vkey_code);
    UI_UNUSED_PARAMETER(key_state);
}


#ifdef __MMI_TOUCH_SCREEN__
/*****************************************************************************
 * FUNCTION
 *  category_142_pen_down_hdlr
 * DESCRIPTION
 *  pen down handler of category 142
 * PARAMETERS
 *  pos     [IN]        Pen down position
 * RETURNS
 *  
 *****************************************************************************/
static MMI_BOOL category_142_pen_down_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_scrollbar_pen_enum scrollbar_event;
    gui_pen_event_param_struct scrollbar_param;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (PEN_CHECK_BOUND
        (pos.x, pos.y, category142_vbar.x, category142_vbar.y, category142_vbar.width, category142_vbar.height))
    {
        gui_vertical_scrollbar_translate_pen_event(
            &category142_vbar,
            MMI_PEN_EVENT_DOWN,
            pos.x,
            pos.y,
            &scrollbar_event,
            &scrollbar_param);
        if (scrollbar_event == GUI_SCROLLBAR_PEN_JUMP_TO_I)
        {
            category_142_goto_item((S32) scrollbar_param._u.i);
        }
        return MMI_TRUE;
    }
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  category_142_pen_move_hdlr
 * DESCRIPTION
 *  pen move handler of category 142
 * PARAMETERS
 *  pos     [IN]        Pen down position
 * RETURNS
 *  
 *****************************************************************************/
static MMI_BOOL category_142_pen_move_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_scrollbar_pen_enum scrollbar_event;
    gui_pen_event_param_struct scrollbar_param;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (PEN_CHECK_BOUND
        (pos.x, pos.y, category142_vbar.x, category142_vbar.y, category142_vbar.width, category142_vbar.height))
    {
        gui_vertical_scrollbar_translate_pen_event(
            &category142_vbar,
            MMI_PEN_EVENT_MOVE,
            pos.x,
            pos.y,
            &scrollbar_event,
            &scrollbar_param);
        if (scrollbar_event == GUI_SCROLLBAR_PEN_JUMP_TO_I)
        {
            category_142_goto_item((S32) scrollbar_param._u.i);
        }
        return MMI_TRUE;
    }
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  category_142_pen_repeat_hdlr
 * DESCRIPTION
 *  pen repeat handler of category 142
 * PARAMETERS
 *  pos     [IN]        Pen repeat position
 * RETURNS
 *  
 *****************************************************************************/
static MMI_BOOL category_142_pen_repeat_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_scrollbar_pen_enum scrollbar_event;
    gui_pen_event_param_struct scrollbar_param;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (PEN_CHECK_BOUND
        (pos.x, pos.y, category142_vbar.x, category142_vbar.y, category142_vbar.width, category142_vbar.height))
    {
        gui_vertical_scrollbar_translate_pen_event(
            &category142_vbar,
            MMI_PEN_EVENT_REPEAT,
            pos.x,
            pos.y,
            &scrollbar_event,
            &scrollbar_param);
        if (scrollbar_event == GUI_SCROLLBAR_PEN_JUMP_TO_I)
        {
            category_142_goto_item((S32) scrollbar_param._u.i);
        }
        return MMI_TRUE;
    }
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  category_142_pen_up_hdlr
 * DESCRIPTION
 *  pen up handler category 142
 * PARAMETERS
 *  pos     [IN]        Pen up position
 * RETURNS
 *  
 *****************************************************************************/
static MMI_BOOL category_142_pen_up_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_scrollbar_pen_enum scrollbar_event;
    gui_pen_event_param_struct scrollbar_param;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (PEN_CHECK_BOUND
        (pos.x, pos.y, category142_vbar.x, category142_vbar.y, category142_vbar.width, category142_vbar.height))
    {
        gui_vertical_scrollbar_translate_pen_event(
            &category142_vbar,
            MMI_PEN_EVENT_UP,
            pos.x,
            pos.y,
            &scrollbar_event,
            &scrollbar_param);
        return MMI_TRUE;
    }
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  category_142_pen_abort_hdlr
 * DESCRIPTION
 *  pen abort handler of category 142
 * PARAMETERS
 *  pos     [IN]        Pen abort position
 * RETURNS
 *  
 *****************************************************************************/
static MMI_BOOL category_142_pen_abort_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_scrollbar_pen_enum scrollbar_event;
    gui_pen_event_param_struct scrollbar_param;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (PEN_CHECK_BOUND
        (pos.x, pos.y, category142_vbar.x, category142_vbar.y, category142_vbar.width, category142_vbar.height))
    {
        gui_vertical_scrollbar_translate_pen_event(
            &category142_vbar,
            MMI_PEN_EVENT_ABORT,
            pos.x,
            pos.y,
            &scrollbar_event,
            &scrollbar_param);
        return MMI_TRUE;
    }
    return MMI_FALSE;
}
#endif /* __MMI_TOUCH_SCREEN__ */ 


/*****************************************************************************
 * FUNCTION
 *  DrawCate142CategoryControlArea
 * DESCRIPTION
 *  redraw category 142 control area
 * PARAMETERS
 *  coordinate      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
static void DrawCate142CategoryControlArea(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(coordinate);
    category_142_redraw_highlighted_item();
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory142History
 * DESCRIPTION
 *  Gets the history buffer for the picture list screen
 * PARAMETERS
 *  history_buffer      [OUT]        Buffer to store history
 * RETURNS
 *  U8*                  pointer to the history buffer
 *****************************************************************************/
static U8 *GetCategory142History(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    get_object_list_category_history(MMI_CATEGORY142_ID, history_buffer, category_142_image_list_index);
    return (history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory142Screen
 * DESCRIPTION
 *  Exits the picture list screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void ExitCategory142Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_switch_title_with_status_bar)
    {
        wgui_switch_title_with_status_bar = 0;
    }
    category_142_image_list = NULL;
    category_142_image_file_name_list = NULL;
    category_142_image_list_index = NULL;
    category_142_image_list_n_items = 0;
    category_142_list_of_titles = NULL;
    animation_handle = GDI_ERROR_HANDLE;
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategory142Screen(
        U8 *title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U8 **list_of_titles,
        U16 *list_of_images,
        U8 **file_list_of_images,
        S32 n_items,
        S32 *index,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    U8 h_flag;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);
    gui_setup_common_layout();
    gdi_layer_lock_frame_buffer();

    wgui_title_set_menu_shortcut_number(-1);

    dm_add_softkey(
        get_string(left_softkey), 
        get_image(left_softkey_icon), 
        get_string(right_softkey), 
        get_image(right_softkey_icon));

    if (title == NULL)
    {
        wgui_switch_title_with_status_bar = 1;
        ShowStatusIconsTitle();
    }
    else
    {
        MMI_title_icon = get_image(title_icon);
        wgui_switch_title_with_status_bar = 0;
    }

    wgui_title_set_menu_shortcut_number(*index + 1);
    category_142_image_list_index = index;
    h_flag = set_object_list_category_history(MMI_CATEGORY142_ID, history_buffer, category_142_image_list_index);
    if (h_flag)
    {
        *index = *category_142_image_list_index;
    }

    category_142_list_of_titles = list_of_titles;
    MMI_title_string = (UI_string_type) title;
    category_142_image_list = list_of_images;
    category_142_image_file_name_list = file_list_of_images;
    category_142_image_list_n_items = n_items;

    gui_create_vertical_scrollbar(
        &category142_vbar,
        UI_device_width - current_MMI_theme->scrollbar_size,
        (MMI_title_y + MMI_title_height),
        current_MMI_theme->scrollbar_size,
        MMI_content_height);
  
    /* register shortcut handler */
    if (n_items > 1)
    {
        S32 shortcut_width;

        wgui_title_disable_menu_shortcut_display(MMI_FALSE);
        register_fixed_list_shortcut_handler();
        shortcut_width = set_menu_item_count(n_items) + 7;
        resize_menu_shortcut_handler(shortcut_width, MMI_title_height);
        move_menu_shortcut_handler(UI_device_width - MMI_menu_shortcut_box.width, MMI_title_y);
        register_hide_menu_shortcut(gui_redraw_menu_shortcut);
        register_keyboard_key_handler(category_142_key_handler);
        register_menu_shortcut_keys();
        register_menu_shortcut_handler(category_142_goto_item);
        SetKeyHandler(category_142_goto_previous_item, KEY_UP_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(category_142_goto_next_item, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(category_142_goto_previous_item, KEY_VOL_UP, KEY_EVENT_DOWN);
        SetKeyHandler(category_142_goto_next_item, KEY_VOL_DOWN, KEY_EVENT_DOWN);
#ifdef __MMI_TOUCH_SCREEN__
        wgui_register_category_screen_control_area_pen_handlers(category_142_pen_down_hdlr, MMI_PEN_EVENT_DOWN);
        wgui_register_category_screen_control_area_pen_handlers(category_142_pen_move_hdlr, MMI_PEN_EVENT_MOVE);
        wgui_register_category_screen_control_area_pen_handlers(category_142_pen_repeat_hdlr, MMI_PEN_EVENT_REPEAT);
        wgui_register_category_screen_control_area_pen_handlers(category_142_pen_up_hdlr, MMI_PEN_EVENT_UP);
        wgui_register_category_screen_control_area_pen_handlers(category_142_pen_abort_hdlr, MMI_PEN_EVENT_ABORT);
#endif /* __MMI_TOUCH_SCREEN__ */ 
    }
    else
    {
        wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    }

    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = ExitCategory142Screen;

    dm_setup_category_functions(dm_redraw_category_screen, GetCategory142History, dm_get_category_history_size);
    dm_register_category_controlled_callback(DrawCate142CategoryControlArea);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    if (wgui_switch_title_with_status_bar == 1)
    {
        dm_data.s32CatId = MMI_CATEGORY142_STATUS_ICON_ID;
    }
    else
    {
        dm_data.s32CatId = MMI_CATEGORY142_ID;
    }
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}


extern void gui_fixed_icontext_list_menuitem_scroll_handler(void);


/*****************************************************************************
 * FUNCTION
 *  ExitCategory152Screen
 * DESCRIPTION
 *  Exit category152 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory152Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    reset_softkeys();
}   /* end of ExitCategory152Screen */


/*****************************************************************************
 * FUNCTION
 *  ShowCategory152Screen
 * DESCRIPTION
 *  Displays the category screen 152
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon displayed with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Left softkey icon
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Right softkey icon
 *  message                 [IN]        Message
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory152Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U8 *message,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 l;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);

    gdi_layer_lock_frame_buffer();

    wgui_title_set_menu_shortcut_number(-1);
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    SetupCategoryKeyHandlers();

    MMI_title_string = (UI_string_type) get_string(title);
    MMI_title_icon = (PU8) get_image(title_icon);
    MMI_message_string = (UI_string_type) (message);
    l = gui_strlen(MMI_message_string);
    create_multiline_inputbox_set_buffer(MMI_message_string, l, l, 0);
    MMI_multiline_inputbox.flags |=
        (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND |
         UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR);
#ifdef __MMI_WALLPAPER_ON_BOTTOM__
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_TRANSPARENT_BACKGROUND;
#endif 

    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND | DM_LEFT_ALIGN_TITLE;

    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = ExitCategory152Screen;
    dm_setup_category_functions(dm_redraw_category_screen, dummy_get_history, dummy_get_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY152_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();

}   /* end of ShowCategory152Screen */


static scrolling_text scroll_text_cat154;
#if defined(__MMI_MAINLCD_240X400__) || defined(__MMI_MAINLCD_320X480__)
#define WGUI_CAT154_TEXT_GAP 2
#else
#define WGUI_CAT154_TEXT_GAP 1
#endif
/*****************************************************************************
 * FUNCTION
 *  wgui_cat154_scrolling_timer
 * DESCRIPTION
 *  category 154 scrolling timer handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat154_scrolling_timer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_handle_scrolling_text(&scroll_text_cat154);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat154_scrolling_text_draw_background
 * DESCRIPTION
 *  Draw category 154 scrolling text draw background
 * PARAMETERS
 *  x1      [IN]        Start x posityion
 *  y1      [IN]        Start y position
 *  x2      [IN]        End x position
 *  y2      [IN]        End y position
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat154_scrolling_text_draw_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat154_draw_controlarea
 * DESCRIPTION
 *  redraw 154 control area
 * PARAMETERS
 *  coordinate      [IN]     Area to redraw     
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat154_draw_controlarea(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 w1, h1, w2, h2, x;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_reset_clip();

    gui_set_font(current_UI_theme->multi_line_input_box_theme->text_font);
    gui_measure_string(MMI_message_string, &w1, &h1);
    gui_measure_string(MMI_message_string2, &w2, &h2);
    gui_set_text_color(UI_COLOR_BLACK);
    if (Category154Align)
    {
        x = WGUI_CAT154_TEXT_GAP;
    }
    else
    {
        x = (UI_device_width >> 1) - (w1 >> 1);
        if (x < WGUI_CAT154_TEXT_GAP)
        {
            x = WGUI_CAT154_TEXT_GAP;
        }
    }

    if (r2lMMIFlag)
    {
        if(w1 > (UI_device_width - 2*WGUI_CAT154_TEXT_GAP))
        {
            x = UI_device_width - WGUI_CAT154_TEXT_GAP;
        }
        else
        {
            x += w1;
        }
    }

    if(w1 > (UI_device_width - 2*WGUI_CAT154_TEXT_GAP))
    {
        gui_create_scrolling_text(
            &scroll_text_cat154,
            x,
            category_154_message1_y,
            (UI_device_width - 2*WGUI_CAT154_TEXT_GAP),
            h1,
            MMI_message_string,
            wgui_cat154_scrolling_timer,
            wgui_cat154_scrolling_text_draw_background,
            gui_color(0, 0, 0),
            gui_color(255, 255, 255));
        gui_show_scrolling_text(&scroll_text_cat154);
    }
    else
    {
        gui_move_text_cursor(x, category_154_message1_y);
        gui_set_line_height(h1);
        gui_print_text(MMI_message_string);
    }
    if (Category154Align)
    {
        x = WGUI_CAT154_TEXT_GAP;
    }
    else
    {
        x = (UI_device_width >> 1) - (w2 >> 1);
        if (x < WGUI_CAT154_TEXT_GAP)
        {
            x = WGUI_CAT154_TEXT_GAP;
        }
    }

    if (r2lMMIFlag)
    {
        if (gui_get_string_width((UI_string_type) MMI_message_string2) >= UI_device_width)
        {
            x = UI_device_width - WGUI_CAT154_TEXT_GAP;
        }
        else
        {
            x += gui_get_string_width((UI_string_type) MMI_message_string2);
        }
    }

    gui_print_truncated_text(x, category_154_message2_y, UI_device_width - 2*WGUI_CAT154_TEXT_GAP, MMI_message_string2);
#ifdef __MMI_SCREEN_ROTATE__	
	if(mmi_frm_is_screen_width_height_swapped())
	{
		gdi_layer_set_clip(
			0,
			(MMI_title_y + MMI_title_height) + 1,
			UI_device_width - 1,
			UI_device_height - 1);
	}
	else
#endif
	{
    gdi_layer_set_clip(
        0,
        (MMI_title_y + MMI_title_height) + 1,
        UI_device_width - 1,
        UI_device_height - MMI_button_bar_height - 1);
	}
    wgui_show_transparent_animation();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat154_refresh
 * DESCRIPTION
 *  refresh category154 if message change
 * PARAMETERS
 *  void 
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat154_refresh(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	gdi_layer_push_and_set_active(dm_get_layer_handle(1));
	gdi_layer_push_clip();
	gdi_draw_solid_rect(0,
		      (MMI_title_y + MMI_title_height) + 1,
		       UI_device_width - 1,
        UI_device_height - MMI_button_bar_height - 1, GDI_COLOR_TRANSPARENT);
	gdi_anim_stop_all();
    gui_scrolling_text_stop(&scroll_text_cat154);
	wgui_cat154_draw_controlarea();
	gdi_layer_pop_clip();
	gdi_layer_pop_and_restore_active();
	gdi_layer_blt_previous(0, (MMI_title_y + MMI_title_height) + 1,
		UI_device_width - 1,
        UI_device_height - MMI_button_bar_height - 1);

}


/*****************************************************************************
 * FUNCTION
 *  DrawCate154CategoryControlArea
 * DESCRIPTION
 *  redraw 154 control area
 * PARAMETERS
 *  coordinate      [IN]     Area to redraw     
 * RETURNS
 *  void
 *****************************************************************************/
void DrawCate154CategoryControlArea(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	wgui_cat154_draw_controlarea();	
}


/*****************************************************************************
 * FUNCTION
 *  Setcategory154LeftAlign
 * DESCRIPTION
 *  Set content of category154 left alignment
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void Setcategory154LeftAlign(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    Category154Align = 1;
}


/*****************************************************************************
 * FUNCTION
 *  ChangeCategory154Data
 * DESCRIPTION
 *  Change data of category154
 * PARAMETERS
 *  message1            [IN]        Data pointer of message1
 *  message2            [IN]        Data pointer of message2
 *  message_icon        [IN]        Id of message icon
 * RETURNS
 *  void
 *****************************************************************************/
void ChangeCategory154Data(U8 *message1, U8 *message2, U16 message_icon)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 w1, h1, w2, h2, w3, h3, y, th, rh;
    PU8 image;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_message_string = (UI_string_type) message1;
    MMI_message_string2 = (UI_string_type) message2;
    gui_set_font(current_UI_theme->multi_line_input_box_theme->text_font);
    gui_measure_string(MMI_message_string, &w1, &h1);
    gui_measure_string(MMI_message_string2, &w2, &h2);
    image = get_image(message_icon);
    if (wgui_switch_title_with_status_bar == 0)
    {
        gui_measure_image(image, &w3, &h3);
        th = h1 + h2 + h3 + 2;
        y = (MMI_title_y + MMI_title_height) + 1 + ((MMI_content_height - 1) >> 1) - (th >> 1);
        if (th < MMI_content_height)
        {
            rh = (MMI_content_height - th) >> 2;
        }
        else
        {
            rh = 0;
        }
        y -= rh;
        if (y < ((MMI_title_y + MMI_title_height) + 1))
        {
            y = (MMI_title_y + MMI_title_height) + 1;
        }
        category_154_message1_y = y;
        category_154_message2_y = y + h1;
        y += h1 + h2 + rh + 2;
    }
    else
    {
        category_154_message1_y = CAT154_IMAGE_Y - h1 - 1 - h2 - 2;
        category_154_message2_y = CAT154_IMAGE_Y - h2 - 2;
        y = CAT154_IMAGE_Y;
    }

    wgui_set_animation_image_y((UI_device_width >> 1), y, image);
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory154Screen
 * DESCRIPTION
 *  Displays the Message Received screen
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  message1                [IN]        Notification message 1
 *  message2                [IN]        Notification message 2
 *  message_icon            [IN]        Image to show
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory154Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U8 *message1,
        U8 *message2,
        U16 message_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 w1, h1, w2, h2, w3, h3, y, th, rh;
    PU8 image;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    dm_reset_context();
    UI_UNUSED_PARAMETER(history_buffer);
    gdi_layer_lock_frame_buffer();
    wgui_title_set_menu_shortcut_number(-1);
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    SetupCategoryKeyHandlers();

    if (title == 0)
    {
        wgui_switch_title_with_status_bar = 1;
        ShowStatusIconsTitle();
    }
    else
    {
        MMI_title_string = get_string(title);
        MMI_title_icon = get_image(title_icon);
        wgui_switch_title_with_status_bar = 0;
    }
    MMI_message_string = (UI_string_type) message1;
    MMI_message_string2 = (UI_string_type) message2;
    gui_set_font(current_UI_theme->multi_line_input_box_theme->text_font);
    gui_measure_string(MMI_message_string, &w1, &h1);
    gui_measure_string(MMI_message_string2, &w2, &h2);
    image = get_image(message_icon);
    if (wgui_switch_title_with_status_bar == 0)
    {
        gui_measure_image(image, &w3, &h3);
        th = h1 + 1 + h2 + 2 + h3;
        y = (MMI_title_y + MMI_title_height) + 1 + ((MMI_content_height - 1) >> 1) - (th >> 1);
        if (th < MMI_content_height)
        {
            rh = (MMI_content_height - th) >> 2;
        }
        else
        {
            rh = 0;
        }
        y -= rh;
        if (y < ((MMI_title_y + MMI_title_height) + 1))
        {
            y = (MMI_title_y + MMI_title_height) + 1;
        }
        category_154_message1_y = y;
        category_154_message2_y = y + h1 + 1;
        y += h1 + 1 + h2 + rh + 2;
    }
    else
    {
        category_154_message1_y = CAT154_IMAGE_Y - h1 - 1 - h2 - 2;
        category_154_message2_y = CAT154_IMAGE_Y - h2 - 2;
        y = CAT154_IMAGE_Y;
    }
    wgui_set_animation_image_y((UI_device_width >> 1), y, image);

    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = ExitCategory154Screen;
    dm_setup_category_functions(dm_redraw_category_screen, dummy_get_history, dummy_get_history_size);
    dm_register_category_controlled_callback(DrawCate154CategoryControlArea);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND_COLOR | DM_SET_NEW_LAYER_ACTIVE;
	if((left_softkey == 0) && (left_softkey_icon == 0) && (right_softkey == 0) && (right_softkey_icon == 0))
	{
		dm_data.s32flags |= DM_NO_SOFTKEY;
	}
    if (wgui_switch_title_with_status_bar == 1)
	{
        dm_data.s32CatId = MMI_CATEGORY154_STATUS_ICON_ID;
    }
    else
    {
    dm_data.s32CatId = MMI_CATEGORY154_ID;
    }
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();

}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory154Screen
 * DESCRIPTION
 *  Exits the Message Received screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory154Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_switch_title_with_status_bar)
    {
        close_status_icons();
        wgui_switch_title_with_status_bar = 0;
    }
    gui_scrolling_text_stop(&scroll_text_cat154);
    Category154Align = 0;
    MMI_message_string = NULL;
    MMI_message_string2 = NULL;
    gui_hide_animations();
}

#if defined(__MMI_SMART_MESSAGE_MT__) || (defined(__MMI_SMART_MESSAGE_MO__) && !defined(__MMI_MESSAGES_EMS__))
/* category 154 message 1 */
UI_string_type category_620_message1 = NULL;

/* category 154 message 2 */
UI_string_type category_620_message2 = NULL;

/* category 154 message 1 y postition */
S32 category_620_message1_y = 0;

/* category 154 message 2 y position  */
S32 category_620_message2_y = 0;
U8 Category620Align = 0;


/* For detail description, please refer to wgui_categories.h */
void RedrawCategory620Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 w1, h1, w2, h2, x;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    gui_hide_animations();
    clear_screen();
    if (wgui_switch_title_with_status_bar)
    {
        show_status_icons();
    }
    else
    {
        draw_title();
    }
    gdi_layer_reset_clip();
    gui_set_font(current_UI_theme->multi_line_input_box_theme->text_font);
    gui_measure_string(category_620_message1, &w1, &h1);
    gui_measure_string(category_620_message2, &w2, &h2);
    gui_set_text_color(gui_color(0, 0, 0));
    if (Category620Align)
    {
        x = 2;
    }
    else
    {
        x = (UI_device_width >> 1) - (w1 >> 1);
        if (x < 2)
        {
            x = 2;
        }
    }
    gui_move_text_cursor(x, category_620_message1_y);
    gui_set_line_height(h1);
    gui_print_text(category_620_message1);
    if (Category620Align)
    {
        x = 2;
    }
    else
    {
        x = (UI_device_width >> 1) - (w2 >> 1);
        if (x < 2)
        {
            x = 2;
        }
    }
    gui_print_truncated_text(x, category_620_message2_y, UI_device_width - 2, category_620_message2);
    gdi_layer_set_clip(
        0,
        (MMI_title_y + MMI_title_height) + 1,
        UI_device_width - 1,
        UI_device_height - MMI_button_bar_height - 1);
    wgui_show_transparent_animation();
    show_softkey_background();
    show_left_softkey();
    show_right_softkey();
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
}


/* For detail description, please refer to wgui_categories.h */
void Setcategory620LeftAlign(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    Category620Align = 1;
}


/* For detail description, please refer to wgui_categories.h */
void ChangeCategory620Data(U8 *message1, U8 *message2, U8 *message_icon_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 w1, h1, w2, h2, w3, h3, y, th, rh;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    category_620_message1 = (UI_string_type) message1;
    category_620_message2 = (UI_string_type) message2;
    gui_set_font(current_UI_theme->multi_line_input_box_theme->text_font);
    gui_measure_string(category_620_message1, &w1, &h1);
    gui_measure_string(category_620_message2, &w2, &h2);
    gui_measure_image((PU8) message_icon_buffer, &w3, &h3);
    th = h1 + h2 + h3 + 2;
    y = (MMI_title_y + MMI_title_height) + 1 + ((MMI_content_height - 1) >> 1) - (th >> 1);
    if (th < MMI_content_height)
    {
        rh = (MMI_content_height - th) >> 2;
    }
    else
    {
        rh = 0;
    }
    y -= rh;
    if (y < ((MMI_title_y + MMI_title_height) + 1))
    {
        y = (MMI_title_y + MMI_title_height) + 1;
    }
    category_620_message1_y = y;
    category_620_message2_y = y + h1;
    y += h1 + h2 + rh + 2;
    wgui_set_animation_image_y((UI_device_width >> 1), y, (PU8) message_icon_buffer);
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategory620Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U8 *message1,
        U8 *message2,
        U8 *message_icon_buffer,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);
    
    dm_reset_context();
    gdi_layer_lock_frame_buffer();
    wgui_title_set_menu_shortcut_number(-1);
    
    dm_add_softkey(get_string(left_softkey), get_image(left_softkey_icon), get_string(right_softkey), get_image(right_softkey_icon));

    if (title == 0)
    {
        wgui_switch_title_with_status_bar = 1;
        ShowStatusIconsTitle();
    }
    else
    {
        MMI_title_string = get_string(title);
        MMI_title_icon = get_image(title_icon);
        wgui_switch_title_with_status_bar = 0;
    }

    dm_add_image((PU8) message_icon_buffer, NULL, NULL);
    dm_add_string((UI_string_type) message1, &MMI_medium_font, UI_COLOR_BLACK, UI_COLOR_BLACK, NULL);
    dm_add_string((UI_string_type) message2, &MMI_medium_font, UI_COLOR_BLACK, UI_COLOR_BLACK, NULL);

    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = ExitCategory620Screen;

    dm_setup_category_functions(dm_redraw_category_screen, dummy_get_history, dummy_get_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY620_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}
#endif /* defined(__MMI_SMART_MESSAGE_MT__) || (defined(__MMI_SMART_MESSAGE_MO__) && !defined(__MMI_MESSAGES_EMS__)) */ 


/*****************************************************************************
* [Category166]
*
* This category draws a full screen animation (align at center of screen)
* Used by power on/off animation
* This screen also able to mimic a static image with animation's behavior
*
*  **********************
*  *                    *
*  *                    *
*  *                    *
*  *                    *
*  *                    *
*  *     Animation      *
*  *                    *
*  *                    *
*  *                    *
*  *                    *
*  *                    *
*  **********************
*
*****************************************************************************/
static void (*cat166_animation_complete_callback) (GDI_RESULT result);
static PS8 cat166_animation_name;
static U16 cat166_animation_id;
static S32 cat166_image_offset_x;
static S32 cat166_image_offset_y;
static S32 cat166_image_width;
static S32 cat166_image_height;
static BOOL cat166_is_gif_anim;
static BOOL cat166_is_avatar_anim;
static U16 cat166_need_resize;
static BOOL cat166_is_invalid;
static GDI_HANDLE cat166_animation_handle = GDI_ERROR_HANDLE;


/*****************************************************************************
 * FUNCTION
 *  Cat166AnimationMimicTimer
 * DESCRIPTION
 *  Mimic animation's play complete call back function for static images
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void Cat166AnimationMimicTimer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Mimic GDI to return last frame callback */
    if (cat166_animation_complete_callback != NULL)
    {
        if (cat166_is_invalid)
        {
            /* error file */
            cat166_animation_complete_callback(-1);
        }
        else
        {
            cat166_animation_complete_callback(GDI_GIF_LAST_FRAME);
            gui_start_timer(1000, Cat166AnimationMimicTimer);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  cat166_animation_complete_callback_failed
 * DESCRIPTION
 *  the animation of category screen no.166 is failed, inform application
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void cat166_animation_complete_callback_failed(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (cat166_animation_complete_callback != NULL)
    {
        cat166_animation_complete_callback(-1);
    }
}


/*****************************************************************************
 * FUNCTION
 *  cat166_animation_complete_callback_int
 * DESCRIPTION
 *  category screen no.166 default animation callback
 * PARAMETERS
 *  result      [IN]        Result of animation
 * RETURNS
 *  void
 *****************************************************************************/
static void cat166_animation_complete_callback_int(GDI_RESULT result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (result < 0)
    {
        /* 
         *animation is terminated abnormally,
         * wait for a while for redraw category no.166
         * to accomplish its job 
         */
        gui_start_timer(200, cat166_animation_complete_callback_failed);
    }
    else if (result == GDI_IMAGE_IS_STILL_IMAGE)
    {
        gui_start_timer(200, Cat166AnimationMimicTimer);
    }
    else
    {
        /* 
         * animation is terminated normally,
         * execute application callback 
         */
        if (cat166_animation_complete_callback != NULL)
        {
            cat166_animation_complete_callback(result);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  RedrawCategory166Screen
 * DESCRIPTION
 *  Redraws sategory 166 screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void RedrawCategory166Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    GDI_RESULT result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_hide_animations();
    gdi_layer_clear(GDI_COLOR_BLACK);
    gui_reset_clip();

    if (cat166_animation_name != NULL)
    {
        /* source from file */
        if (cat166_is_gif_anim)
        {
            /* animation, use GDI's auto play animation */
            gdi_image_set_animation_last_frame_callback(cat166_animation_complete_callback_int);
            
            /* 070406 SVG support Start */
            if (cat166_need_resize)
            {
                cat166_animation_handle = GDI_ERROR_HANDLE;
                result = gdi_image_draw_animation_resized_file(
                            cat166_image_offset_x,
                            cat166_image_offset_y,
                            cat166_image_width,
                            cat166_image_height,
                            (U8*) cat166_animation_name,
                            &cat166_animation_handle);
            }
            else
            {
                cat166_animation_handle = GDI_ERROR_HANDLE;
                result = gdi_image_draw_animation_file(
                            cat166_image_offset_x,
                            cat166_image_offset_y,
                            (U8*) cat166_animation_name,
                            &cat166_animation_handle);
            }
            /* 070406 SVG support End */

            /* if is 1 frame gif, treat as still image */
            if (result == GDI_IMAGE_IS_STILL_IMAGE)
            {
                gui_start_timer(200, Cat166AnimationMimicTimer);
            }
        }
#ifdef __MMI_AVATAR__
        else if (cat166_is_avatar_anim == TRUE)
        {
            result = gdi_anim_draw_mem(
                        0,
                        0,
                        (PS8) cat166_animation_name,
                        GDI_IMAGE_TYPE_AVATAR,
                        0, // NO USE
                        &cat166_animation_handle);
        } 
#endif
        else
        {
            if (cat166_need_resize)
            {
                /* static image */
                result = gdi_image_draw_resized_file(
                            cat166_image_offset_x,
                            cat166_image_offset_y,
                            cat166_image_width,
                            cat166_image_height,
                            cat166_animation_name);

                if (result < 0)
                {
                    /* invalid file */
                    cat166_is_invalid = TRUE;
                }

                gui_start_timer(200, Cat166AnimationMimicTimer);
            }
            else
            {
                /* static image */
                result = gdi_image_draw_file(cat166_image_offset_x, cat166_image_offset_y, cat166_animation_name);

                if (result < 0)
                {
                    /* invalid file */
                    cat166_is_invalid = TRUE;
                }

                gui_start_timer(200, Cat166AnimationMimicTimer);
            }
        }
    }
    else
    {
        /* source from id */
        if (cat166_is_gif_anim)
        {
            /* animation, use GDI's auto play animation */
            gdi_image_set_animation_last_frame_callback(cat166_animation_complete_callback_int);
            cat166_animation_handle = GDI_ERROR_HANDLE;
            result = gdi_image_draw_animation(cat166_image_offset_x, cat166_image_offset_y, (U8*) GetImage(cat166_animation_id), &cat166_animation_handle); 

            /* if is 1 frame gif, treat as still image */
            if (result == GDI_IMAGE_IS_STILL_IMAGE)
            {
                gui_start_timer(200, Cat166AnimationMimicTimer);
            }
        }
        else
        {
            /* static image */
            gdi_image_draw_id(cat166_image_offset_x, cat166_image_offset_y, cat166_animation_id);
            gui_start_timer(200, Cat166AnimationMimicTimer);
        }
    }

    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  DrawCate166CategoryControlArea
 * DESCRIPTION
 *  draw category 166 category control area
 * PARAMETERS
 *  coordinate      [IN]     Area to redraw     
 * RETURNS
 *  void
 *****************************************************************************/
static void DrawCate166CategoryControlArea(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(coordinate);
    RedrawCategory166Screen();
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory166Screen
 * DESCRIPTION
 *  Exit Category166 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void ExitCategory166Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* stop animtion */
    gdi_image_stop_animation_all();
    if(cat166_animation_handle != GDI_ERROR_HANDLE)
    {
        gdi_image_stop_animation(cat166_animation_handle);
        cat166_animation_handle = GDI_ERROR_HANDLE;
    }
    gui_cancel_timer(Cat166AnimationMimicTimer);
    gui_cancel_timer(cat166_animation_complete_callback_failed);

    cat166_animation_complete_callback = NULL;
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategory166Screen(U16 image_id, S8 *image_filename, void (*animation_complete_callback) (GDI_RESULT))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 image_width;
    S32 image_height;
    GDI_RESULT ret;
    U16 img_type;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* 
     * If image_filename != NULL, means will use image from file as first priority.
     * We will use image_id when the file is not able to play correctly. 
     */

    /* init var */
    cat166_animation_complete_callback = animation_complete_callback;

    cat166_animation_id = image_id;
    cat166_animation_name = image_filename;
    cat166_image_offset_x = 0;
    cat166_image_offset_y = 0;
    cat166_is_gif_anim = FALSE;
    cat166_need_resize = FALSE;
    cat166_is_invalid = FALSE;

#ifdef __MMI_AVATAR__
    if(PhnsetGetDisplayType(image_id) == PHNSET_TYPE_DISP_AVATAR)
    cat166_is_avatar_anim = TRUE;
    else 
    cat166_is_avatar_anim = FALSE;
#else
    cat166_is_avatar_anim = FALSE;
#endif

    /* full screen category */
    entry_full_screen();

    /* clear all key handlers */
    clear_category_screen_key_handlers();
    clear_left_softkey();
    clear_right_softkey();

   /*** get image parameters ***/

    /* source from file */
    if (cat166_animation_name != NULL)
    {
    #ifdef __MMI_AVATAR__
        if (cat166_is_avatar_anim)
        {
            
            if (mmi_avatar_is_avatar_existed((U32)cat166_animation_name))
            ret = gdi_image_get_dimension_mem(GDI_IMAGE_TYPE_AVATAR,(U8 *)cat166_animation_name,0, &image_width, &image_height);
            else 
                ret = -1;
            if (ret >= 0)
            {
                cat166_is_gif_anim = FALSE;
                cat166_need_resize = FALSE;		
            }
        }    
        else
            ret = gdi_image_get_dimension_file(cat166_animation_name, &image_width, &image_height);
    #else
        ret = gdi_image_get_dimension_file(cat166_animation_name, &image_width, &image_height);
    #endif


        if (ret < 0)
        {
            /* set filename to NULL, will skip play this file */
            cat166_animation_name = NULL;
            gdi_layer_clear(GDI_COLOR_BLACK);
            gdi_layer_blt_base_layer(0, 0, UI_device_width - 1, UI_device_height - 1);

            if (cat166_animation_complete_callback != NULL)
            {
                cat166_animation_complete_callback(-1);
            }

            return;
        }
        else if (cat166_is_avatar_anim == FALSE)
        {
            /* check if is gif animation or not */
            switch (gdi_image_get_type_from_file(cat166_animation_name))
            {
                case GDI_IMAGE_TYPE_JPG_FILE:
                case GDI_IMAGE_TYPE_PNG_FILE: /* png resize */
                    cat166_is_gif_anim = FALSE;
                    cat166_need_resize = TRUE;
                    break;

                case GDI_IMAGE_TYPE_GIF_FILE:
                case GDI_IMAGE_TYPE_SVG_FILE: /* SVG support */
                    cat166_is_gif_anim = TRUE;
                    cat166_need_resize = TRUE; /* resize screensaver */
                    break;

                case GDI_IMAGE_TYPE_M3D_FILE:
                    cat166_is_gif_anim = TRUE;
                    cat166_need_resize = FALSE;		
                    break;

                default:
                    cat166_is_gif_anim = FALSE;
                    cat166_need_resize = FALSE;
                    break;
            }

            if (cat166_need_resize == TRUE)
            {
                if ((image_width <= UI_device_width) && (image_height <= UI_device_height))
                {
                    cat166_need_resize = FALSE;
                }
            }
        }
    }

    /* source from ID */
    if (cat166_animation_id != 0 && cat166_is_avatar_anim == FALSE)
    {
        /* we assume internal resource is always correct */
        gdi_image_get_dimension_id(cat166_animation_id, &image_width, &image_height);

        /* check if is gif animation or not */
        /* PMT DLT_FIXES_157 - TK 20060225 START */
        img_type = gdi_image_get_type_from_id(cat166_animation_id);
    #ifdef __MMI_DOWNLOADABLE_THEMES_SUPPORT__
        if (img_type == IMAGE_TYPE_GIF || img_type == IMAGE_TYPE_GIF_FILE_OFFSET || img_type == IMAGE_TYPE_M3D || img_type == IMAGE_TYPE_SVG) /* 070406 SVG support */
    #else 
        if (img_type == IMAGE_TYPE_GIF || img_type == IMAGE_TYPE_M3D || img_type == IMAGE_TYPE_SVG)
    #endif 
            /* PMT DLT_FIXES_157 - TK 20060225 END */
        {
            cat166_is_gif_anim = TRUE;
        }
        else
        {
            cat166_is_gif_anim = FALSE; /* still image */
        }
    }

    /* calc image draw pos, check if need resize */
    if (cat166_need_resize)
    {

        gdi_image_util_fit_bbox(
            UI_device_width,
            UI_device_height,
            image_width,
            image_height,
            &cat166_image_offset_x,
            &cat166_image_offset_y,
            &cat166_image_width,
            &cat166_image_height);
    }
    else
    {
        cat166_image_offset_x = (UI_device_width - image_width) >> 1;
        cat166_image_offset_y = (UI_device_height - image_height) >> 1;
    }

    ExitCategoryFunction = ExitCategory166Screen;
    dm_data.s32CatId = MMI_CATEGORY166_ID;
    dm_data.s32flags = DM_NO_FLAGS;
    dm_data.s32ScrId = GetActiveScreenId();
    dm_setup_data(&dm_data);
    dm_register_category_controlled_callback(DrawCate166CategoryControlArea);
    dm_redraw_category_screen();
}


/* For detail description, please refer to wgui_categories.h */
void StopCategory166Animation(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_image_stop_animation_all();
    gui_cancel_timer(Cat166AnimationMimicTimer);
}


#ifdef __J2ME__

extern kal_bool jui_is_show_menu;
UI_filled_area *wgui_cat16_backup_filler = NULL;

UI_filled_area g_176_normal_filler =
    {UI_FILLED_AREA_TYPE_COLOR,
    UI_NULL_IMAGE,
    NULL,
    {0, 0, 0, 100},
    {0, 0, 0, 0},
    {0, 0, 0, 0},
    {0, 0, 0, 0},
    0
};

UI_filled_area g_176_focussed_filler =
    {UI_FILLED_AREA_TYPE_COLOR,
    UI_NULL_IMAGE,
    NULL,
    {0, 0, 0, 0},
    {0, 0, 0, 0},
    {255, 255, 255, 0},
    {0, 0, 0, 0},
    0
};

/* 011507 menu Start */
/*****************************************************************************
 * FUNCTION
 *  wgui_cat176_set_jui_menu_filler
 * DESCRIPTION
 *  set jui menu filler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat176_set_jui_menu_filler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_cat16_backup_filler == NULL)
    {
        wgui_cat16_backup_filler = MMI_fixed_list_menu.normal_filler;
        MMI_fixed_list_menu.normal_filler = current_MMI_theme->general_background_filler;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat176_reset_jui_menu_filler
 * DESCRIPTION
 *  reset jui menu filler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat176_reset_jui_menu_filler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (wgui_cat16_backup_filler != NULL)
    {
        MMI_fixed_list_menu.normal_filler = wgui_cat16_backup_filler;
        wgui_cat16_backup_filler = NULL;
    }
}

/* 011507 menu End */


/*****************************************************************************
 * FUNCTION
 *  RedrawCategory176Screen
 * DESCRIPTION
 *  Redraws the dynamic menu screen (For SIM Application Toolkit)
 *  Category 176 is used by java.
 *  It is modify from Category 170, and remove keypad register, scrolling title, shortcut, blt out
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void RedrawCategory176Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_icontext_menuitem *m;
    gdi_handle org_layer_handle;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    clear_buttonbar();

    gdi_get_alpha_blending_source_layer(&org_layer_handle);
    if (jui_layer_handle != GDI_LAYER_EMPTY_HANDLE)
    {
        gdi_set_alpha_blending_source_layer(jui_layer_handle);
        /* title bg color depends on JUI layer on PNG case */
        wgui_title_set_alpha_layer(jui_layer_handle);
    }
    wgui_softkey_set_target_layer(GDI_LAYER_MAIN_BASE_LAYER_HANDLE);

#if defined (MMI_SHOW_STATUS_ICON_IN_TITLE)
    wgui_status_icon_integrated_enable(KAL_TRUE);
    wgui_status_icon_integrated_register_redraw(gui_title_oem_show_normal_ex);
#endif
    draw_title();

    /* Temp solution for SQC to verify Java menu
       Will apply right solution before W0723 */
    m = (fixed_icontext_menuitem*) MMI_fixed_list_menu.common_item_data;
    m->normal_text_color = UI_COLOR_BLACK;
    m->focussed_text_color = UI_COLOR_WHITE;
    m->normal_filler = &g_176_normal_filler;
    m->focussed_filler = &g_176_focussed_filler;
    m->focussed_without_sc_filler = &g_176_focussed_filler;

    show_fixed_list();
    show_softkey_background();
    show_left_softkey();
    show_right_softkey();
    gdi_set_alpha_blending_source_layer(org_layer_handle);
    wgui_title_reset_alpha_blend_layer();
    gdi_layer_unlock_frame_buffer();
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory176Screen
 * DESCRIPTION
 *  Displays the Dynamic menu screen
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon displayed with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Left softkey icon
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Right softkey icon
 *  number_of_items         [IN]        Number of items
 *  list_of_items           [IN]        Array of items
 *  list_of_icons           [IN]        Array of icons
 *  flags                   [IN]        Flags (Always set to 0. Reserved for future use.)
 *  highlighted_item        [IN]        Highlighted index
 *  is_full_screen          [IN]        Is full screen or not
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory176Screen(
        U8 *title,
        PU8 title_icon,
        U8 *left_softkey,
        PU8 left_softkey_icon,
        U8 *right_softkey,
        PU8 right_softkey_icon,
        S32 number_of_items,
        U8 **list_of_items,
        PU8 *list_of_icons,
        S32 flags,
        S32 highlighted_item,
        U32 is_full_screen,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;
    U8 flag = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(flags);
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    gdi_layer_lock_frame_buffer();
    dm_add_title((UI_string_type)title, title_icon);
    wgui_text_menuitem_reset_scrolling();

    /* list create function */
    wgui_fixed_list_create_icontext_menu(number_of_items, highlighted_item, WGUI_LIST_MENU_DISABLE_SHORTCUT | WGUI_LIST_MENU_DISABLE_KEY_HANDLE, MMI_CATEGORY176_ID, history_buffer);
    //register_menu_shortcut_handler(UI_dummy_function);
    /* rigister highlight handler as dummy */
	register_fixed_list_highlight_handler(UI_dummy_function_s32);

    /* Softkeys */
    set_left_softkey_label((UI_string_type) left_softkey);
    set_left_softkey_icon(left_softkey_icon);
    set_right_softkey_label((UI_string_type) right_softkey);
    set_right_softkey_icon(right_softkey_icon);

    /* List */
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gui_block_list_effect();
#endif 

    for (i = 0; i < number_of_items; i++)
    {
        if (list_of_icons[i] != UI_NULL_IMAGE)
        {
            flag = 1;
        }
    }

    wgui_fixed_list_move_icontext_menu(0, MMI_title_height);
    if(is_full_screen)
    {
        wgui_fixed_list_resize_icontext_menu(MMI_content_width, UI_device_height-MMI_title_height-MMI_button_bar_height);
    }
    else
    {
        wgui_fixed_list_resize_icontext_menu(MMI_content_width, MMI_content_height);
    }

    resize_fixed_icontext_menuitems(0, MMI_ICONTEXT_MENUITEM_HEIGHT);
    if (flag)
    {
        //set_fixed_icontext_positions(MMI_MENUITEM_HEIGHT + 2, 0, 1, 0);
    }
    else
    {
        set_fixed_icontext_positions(GUI_TEXT_MENUITEM_TEXT_X, 0, 1, 0);
        //MMI_fixed_icontext_menuitem.scroll_width = MMI_fixed_icontext_menuitem.width - 2;
    }

    wgui_fixed_list_add_icontext_items(list_of_items, list_of_icons, NULL);

    gui_set_multilayer_mask(gui_get_multilayer_mask() & ~UI_MUL_BKG_SUBMENU);
    gui_set_multilayer_mask(gui_get_multilayer_mask() & ~UI_MUL_BKG_MAINMENU);

    gdi_layer_unlock_frame_buffer();
    MMI_fixed_list_menu.act_lcd_handle = GDI_LCD_MAIN_LCD_HANDLE;
    MMI_fixed_list_menu.act_layer_handle = jui_layer_handle;

    SetListScreenFunctions(MMI_CATEGORY176_ID);
    RedrawCategoryFunction = RedrawCategory176Screen;
    ExitCategoryFunction = ExitCategory176Screen;
    RedrawCategoryFunction();
    jui_is_show_menu = KAL_TRUE;

}   /* end of ShowCategory176Screen */


/*****************************************************************************
 * FUNCTION
 *  ExitCategory176Screen
 * DESCRIPTION
 *  Exits the dynamic menu screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory176Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_title_disable_menu_shortcut_display(MMI_FALSE);
    close_scrolling_title();
    ClearHighlightHandler();
    reset_softkeys();
    reset_menu_shortcut_handler();
    reset_fixed_list();
    MMI_fixed_list_menu.act_lcd_handle = GDI_LCD_MAIN_LCD_HANDLE;
    MMI_fixed_list_menu.act_layer_handle = GDI_LAYER_MAIN_BASE_LAYER_HANDLE;
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gui_unblock_list_effect();
#endif 
    jui_is_show_menu = KAL_FALSE;
}
#endif /* __J2ME__ */ 


/*****************************************************************************
 * FUNCTION
 *  redraw_fixed_list_and_title_bar
 * DESCRIPTION
 *  redraw fixed list and title bar
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void redraw_fixed_list_and_title_bar(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if(UI_BLINKING_CURSOR_SUPPORT)
    StopTimer(BLINKING_CURSOR);
#endif 
    draw_title();
    redraw_fixed_list();
    SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    SetRightSoftkeyFunction(UI_dummy_function, KEY_EVENT_DOWN);

}

/* Phonebook   */


/*****************************************************************************
 * FUNCTION
 *  show_phonebook_list_inputbox
 * DESCRIPTION
 *  show phonebook list inputbox
 * PARAMETERS
 *  pbName      [IN]        String to show
 * RETURNS
 *  void
 *****************************************************************************/
void show_phonebook_list_inputbox(PU8 pbName)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    S32 inputbox_x, inputbox_y, inputbox_width, inputbox_height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_setup_input_information(0, 1, UI_device_width >> 1, (MMI_title_y + MMI_title_height) - 2);
    inputbox_x = wgui_inputbox_information_bar_width;
    inputbox_y = 0;
    inputbox_width = UI_device_width - wgui_inputbox_information_bar_width;
    inputbox_height = MMI_title_height;
    wgui_setup_singleline_inputbox(
        inputbox_x,
        inputbox_y,
        inputbox_width,
        inputbox_height,
        pbName,
        7,
        MMI_CATEGORY53_ID,
        get_string(STR_GLOBAL_BACK),
        get_image(IMG_GLOBAL_BACK),
        IMM_INPUT_TYPE_SENTENCE | INPUT_TYPE_USE_ENCODING_BASED_LENGTH,
        NULL,
        1);
    wgui_singleline_inputbox_RSK_function = redraw_fixed_list_and_title_bar;
}

/* MTK end */
static S32 input_box_y = 0, input_box_x = 0;
static U16 cat200_search_img = 0;
static MMI_BOOL g_wgui_cat199_has_checkbox = MMI_FALSE;
static MMI_BOOL g_wgui_cat200_set_specific_highlight = MMI_FALSE;
static MMI_BOOL g_wgui_cat199_disable_tab_title = MMI_FALSE;
void wgui_cat199_redraw_controlled_area(dm_coordinates *coordinate);

S32(*cat200_search_function) (U8 *);
BOOL(*wgui_check_application_present) (S32 *max_number) = NULL;
void (*g_wgui_cat200_resize_and_move_func)(S32) = NULL;
void (*g_wgui_cat200_draw_information_bar_func)(void) = NULL;
void (*g_wgui_cat200_set_special_key_func)(void) = NULL;
#define WGUI_CAT199_DEFAULT_HIGHLIGHT_ITEM (1)


UI_filled_area cat200_inputbox_BG_filler = 
{
    UI_FILLED_AREA_TYPE_COLOR,
    UI_NULL_IMAGE,
    NULL,
    {255, 255, 255, 100},
    {0, 0, 0, 0},
    {255, 255, 255, 100},
    {255, 255, 255, 100},
    0
};


UI_single_line_input_box_theme cat200_singleline_inputbox_theme = { 
    &cat200_inputbox_BG_filler,
    &cat200_inputbox_BG_filler,
    &cat200_inputbox_BG_filler,
    {0, 0, 0, 100},
    {128, 128, 128, 100},
    {0, 0, 0, 100},
    {255, 255, 255, 100},
    {51, 88, 171, 100},
    {255, 0, 0, 100},
    &UI_DEFAULT_FONT,
    1,
    UI_SINGLE_LINE_INPUT_BOX_CENTER_Y,
    '*'
};


/*****************************************************************************
 * FUNCTION
 *  wgui_cat200_set_specific_highlight
 * DESCRIPTION
 *  for APP to set specific highlight
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat200_set_specific_highlight(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat200_set_specific_highlight = MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  SetCategory200LeftSoftkeyFunction
 * DESCRIPTION
 *  Set left softkey function of category 200
 * PARAMETERS
 *  f               [IN]        Function pointer
 *  k               [IN]        Event type
 * RETURNS
 *  void
 *****************************************************************************/
void SetCategory200LeftSoftkeyFunction(void (*f) (void), MMI_key_event_type k)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(k);
    wgui_singleline_inputbox_LSK_function = f;
}


/*****************************************************************************
 * FUNCTION
 *  SetCategory200RightSoftkeyFunction
 * DESCRIPTION
 *  Set right soft key function of category 200
 * PARAMETERS
 *  f               [IN]        Function pointer
 *  k               [IN]        Event type
 * RETURNS
 *  void
 *****************************************************************************/
void SetCategory200RightSoftkeyFunction(void (*f) (void), MMI_key_event_type k)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(k);
    wgui_singleline_inputbox_RSK_function = f;
}


/*****************************************************************************
 * FUNCTION
 *  RegisterCat200SearchFunction
 * DESCRIPTION
 *  Register search function (for APP)
 * PARAMETERS
 *  search_function     [IN]        Function pointer
 * RETURNS
 *  void
 *****************************************************************************/
void RegisterCat200SearchFunction(S32(*search_function) (U8 *))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (search_function)
    {
        cat200_search_function = search_function;
    }
}


/*****************************************************************************
 * FUNCTION
 *  Register_appl_present_function
 * DESCRIPTION
 *  Register application present function
 * PARAMETERS
 *  application_present_function        [IN]        Function pointer
 * RETURNS
 *  void
 *****************************************************************************/
void Register_appl_present_function(BOOL(*application_present_function) (S32 *max_number))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_check_application_present = application_present_function;
}


/*****************************************************************************
 * FUNCTION
 *  refresh_search_list_change_list_ext
 * DESCRIPTION
 *  draw search list and related setting
 * PARAMETERS
 *  no_entries              [IN]        Item count
 *  highlighted_item        [IN]        Inedex of highlighted item
 * RETURNS
 *  void
 *****************************************************************************/
void refresh_search_list_change_list_ext(S32 no_entries, S32 highlighted_item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 max_entries = 0;
    BOOL showOption, application_present;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_fixed_list_menu.highlighted_item = highlighted_item;
    MMI_fixed_list_menu.n_items = no_entries;
    MMI_fixed_list_menu.displayed_items = no_entries;

    if (wgui_check_application_present)
    {
        application_present = wgui_check_application_present(&max_entries);   /* true in case of dictionary */
    }
    else
    {
        application_present = MMI_FALSE;
    }

	if (g_dm_data.s32CatId ==  MMI_CATEGORY199_ID ||
        g_dm_data.s32CatId ==  MMI_CATEGORY199_SCROLLTEXT_ID) 
    {
		if (g_wgui_cat199_disable_tab_title == MMI_FALSE)
		{
			set_menu_item_count(no_entries);
		}
    }
	else
	{
        if (application_present)
        {
            set_menu_item_count(max_entries);  /* number of words goes beyond this limit, and increases at the run time */
        }
        else
        {
            set_menu_item_count(no_entries);
        }
    }

    if (application_present)
    {
        showOption = no_entries >= 0 ? MMI_TRUE : MMI_FALSE;
    }
    else
    {
        showOption = no_entries > 0 ? MMI_TRUE : MMI_FALSE;
    }

    if (showOption)
    {
        S32 first_item, last_item;
        
        set_left_softkey_label(wgui_singleline_inputbox_LSK_label_string);
        set_left_softkey_icon(wgui_singleline_inputbox_LSK_label_icon);
        redraw_left_softkey();
        register_left_softkey_handler();
        set_left_softkey_function(wgui_singleline_inputbox_LSK_function, KEY_EVENT_UP);
        set_left_softkey_function(UI_dummy_function, KEY_EVENT_DOWN);
        

        first_item = MMI_fixed_list_menu.first_displayed_item;
        last_item = MMI_fixed_list_menu.last_displayed_item;

        dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);

        MMI_fixed_list_menu.first_displayed_item = first_item;
        MMI_fixed_list_menu.last_displayed_item = last_item;
    }
    else
    {
        set_left_softkey_label(NULL);
        set_left_softkey_icon(NULL);
        redraw_left_softkey();
        set_left_softkey_function(UI_dummy_function, KEY_EVENT_UP);
        set_left_softkey_function(UI_dummy_function, KEY_EVENT_DOWN);
        gui_fixed_icontext_menuitem_stop_scroll();
        gui_pop_up_description_stop_scroll();
#if !defined(GUI_EDITOR_SHOW_TITLE)
        if (g_dm_data.s32CatId !=  MMI_CATEGORY202_ID &&
            g_dm_data.s32CatId !=  MMI_CATEGORY202_NOINFO_ID)
#endif
        {
            wgui_title_set_menu_shortcut_number(0);
        }
        wgui_current_pop_up_description_index = -1;
    }

    /* title */
    if (g_dm_data.s32CatId !=  MMI_CATEGORY199_ID && 
        g_dm_data.s32CatId !=  MMI_CATEGORY199_SCROLLTEXT_ID)  /* for category199 */
    {
#if !defined(GUI_EDITOR_SHOW_TITLE)
    if (g_dm_data.s32CatId !=  MMI_CATEGORY202_ID &&
        g_dm_data.s32CatId !=  MMI_CATEGORY202_NOINFO_ID)
#endif
        {
            draw_title();
        }
    }
    else if (g_dm_data.s32CatId ==  MMI_CATEGORY199_ID ||
        g_dm_data.s32CatId ==  MMI_CATEGORY199_SCROLLTEXT_ID )  /* for category199 */
    {
        if (g_wgui_cat199_disable_tab_title == MMI_FALSE)
        {
            wgui_horizontal_show(GUI_TITLE_PART_ALL);
        }
    }
    else
    {
        draw_title();
    }

    show_dynamic_list();
}


/*****************************************************************************
 * FUNCTION
 *  refresh_search_list
 * DESCRIPTION
 *  Refreash search list
 * PARAMETERS
 *  name        [IN]     Name to search
 * RETURNS
 *  void
 *****************************************************************************/
void refresh_search_list(U8 *name)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 no_entries = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(cat200_search_function != NULL);
    no_entries = cat200_search_function(name);
    
    MMI_ASSERT(no_entries >= 0); /* return entry must >=0 or list will have problem */
    load_dynamic_item_buffer(no_entries);
    
    if ( ((g_dm_data.s32CatId == MMI_CATEGORY199_ID) && (g_wgui_cat199_has_checkbox == MMI_FALSE))
         || ((g_dm_data.s32CatId == MMI_CATEGORY200_ID) && (g_wgui_cat200_set_specific_highlight == MMI_TRUE)) )
    {
        if (wgui_inputs_sl_is_empty() && (no_entries >= (WGUI_CAT199_DEFAULT_HIGHLIGHT_ITEM + 1)))
        {
            /* there are some items */
            /* because first line is "Add new content", should not highlight on first line */
            refresh_search_list_change_list_ext(no_entries, WGUI_CAT199_DEFAULT_HIGHLIGHT_ITEM);
        }
        else
        {
            refresh_search_list_change_list_ext(no_entries, 0);
        }
    }
    else
    {
        refresh_search_list_change_list_ext(no_entries, 0);
    }
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
}


#ifdef __MMI_TOUCH_SCREEN__
/*****************************************************************************
 * FUNCTION
 *  wgui_cat200_virtual_keypad_callback
 * DESCRIPTION
 *  virtual keypad callback of category 200
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat200_virtual_keypad_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_imc_redraw_screen_by_state();
}


/*****************************************************************************
 * FUNCTION
 *  Cate200CategoryControlAreaPenDownHandler
 * DESCRIPTION
 *  pen down handler for category 200
 * PARAMETERS
 *  point       [IN]        Pen down position
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL Cate200CategoryControlAreaPenDownHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;
    gui_list_pen_enum menu_event;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_fixed_list_menu.pen_redraw_menu_function = show_dynamic_list;
    gui_vertical_scrollbar_set_pen_self_scroll(&MMI_fixed_list_menu.vbar, MMI_TRUE);
    gui_fixed_list_menu_set_pen_scroll_delay(&MMI_fixed_list_menu, GUI_DYNAMIC_LIST_PEN_SCROLL_DELAY);

    ret = gui_dynamic_list_menu_translate_pen_event(
            &MMI_fixed_list_menu,
            MMI_PEN_EVENT_DOWN,
            point.x,
            point.y,
            &menu_event);
    if (ret)
    {
        if (menu_event == GUI_LIST_PEN_HIGHLIGHT_CHANGED || menu_event == GUI_LIST_PEN_NEED_REDRAW)
        {
            show_dynamic_list();
        }
        return MMI_TRUE;
    }

    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  Cate200CategoryControlAreaPenUpHandler
 * DESCRIPTION
 *  pen up handler of category 200
 * PARAMETERS
 *  point       [IN]        Pen up position
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL Cate200CategoryControlAreaPenUpHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_general_pen_dynamic_list_menu_hdlr(point, MMI_PEN_EVENT_UP);
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  Cate200CategoryControlAreaPenMoveHandler
 * DESCRIPTION
 *  pen move handler of category 200
 * PARAMETERS
 *  point       [IN]        Pen move position
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL Cate200CategoryControlAreaPenMoveHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_general_pen_dynamic_list_menu_hdlr(point, MMI_PEN_EVENT_MOVE);
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  Cate200CategoryControlAreaPenLongTapHandler
 * DESCRIPTION
 *  pen long tap hanlder
 * PARAMETERS
 *  point       [IN]        Pen long tap position
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL Cate200CategoryControlAreaPenLongTapHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_general_pen_dynamic_list_menu_hdlr(point, MMI_PEN_EVENT_LONG_TAP);
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  Cate200CategoryControlAreaPenRepeatHandler
 * DESCRIPTION
 *  pen repeat hanlder
 * PARAMETERS
 *  point       [IN]        Pen repeat position
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL Cate200CategoryControlAreaPenRepeatHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_general_pen_dynamic_list_menu_hdlr(point, MMI_PEN_EVENT_REPEAT);
    return ret;
}
#endif /* __MMI_TOUCH_SCREEN__ */ 


/*****************************************************************************
 * FUNCTION
 *  wgui_cat200_resize_and_move
 * DESCRIPTION
 *  This is a callback function when IME send resize and move message
 *  1.resize list
 *  2.move singleline inputbox
 * PARAMETERS
 *  inputbox_y   [IN]    sinlgeline inputbox y position
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat200_resize_and_move(S32 inputbox_y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 menu_h = 0, sl_y = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    sl_y = inputbox_y - 1; /* border */
    menu_h = sl_y - 1 /* border */ - MMI_fixed_list_menu.y;
    resize_fixed_list(MMI_fixed_list_menu.width, menu_h);
    gui_dynamic_list_menu_locate_highlighted_item(&MMI_fixed_list_menu);
    wgui_inputs_sl_move(MMI_singleline_inputbox.x, sl_y);
}

#if defined(__MMI_VIRTUAL_KEYBOARD__)
/*****************************************************************************
 * FUNCTION
 *  wgui_cat_stop_pop_up_description_scroll
 * DESCRIPTION
 *  stop the pop up description scroll.
 * PARAMETERS
 *  x1        [IN]   unused.
 *  y1        [IN]   unused.
 *  x2        [IN]   unused.
 *  y2        [IN]   unused.
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat_stop_pop_up_description_scroll(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
        
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_inputbox_stop_cursor(x1, y1, x2, y2);
    gui_fixed_icontext_menuitem_stop_scroll();
    gui_pop_up_description_stop_scroll();
    wgui_dynamic_list_show_icontext_menu();
    gui_pop_up_description_stop_scroll();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat_resume_pop_up_description_scroll
 * DESCRIPTION
 *  resume the pop up description scroll.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat_resume_pop_up_description_scroll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
        
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_inputbox_start_cursor();
    /* Revise: gui_pop_up_description_start_scroll(..) */
    gui_fixed_icontext_menuitem_start_scroll();
    wgui_dynamic_list_show_icontext_menu();
}
#endif


/*****************************************************************************
 * FUNCTION
 *  RedrawCategoryControlledArea200Screen
 * DESCRIPTION
 *  redraw category200
 *  1. information bar
 *  2. list
 *  3. search image
 *  4. singleline inputbox
 * PARAMETERS
 *  coordinate      [IN]     Area to redraw     
 * RETURNS
 *  void
 *****************************************************************************/
void RedrawCategoryControlledArea200Screen(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    color ccblack = {0, 0, 0, 100};
    S32 temp_w = 0, temp_h = 0, image_y = 0, image_x1 = 0, image_x2 = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_dm_data.s32CatId ==  MMI_CATEGORY202_ID ||
        g_dm_data.s32CatId ==  MMI_CATEGORY202_NOINFO_ID)  /* for category202 */
    {
        RedrawCategoryControlledArea202Screen(coordinate);
        return;
    }
    else if (g_dm_data.s32CatId ==  MMI_CATEGORY199_ID || 
             g_dm_data.s32CatId ==  MMI_CATEGORY199_SCROLLTEXT_ID)  /* for category199 */
    {
        wgui_cat199_redraw_controlled_area(coordinate);
        return;
    }
    else
    {    
        gdi_layer_lock_frame_buffer();

        gui_reset_clip();
        gdi_layer_reset_clip();

        /* information bar */
        wgui_setup_input_information(0, MMI_SUBMENU_CONTENT_Y, UI_device_width, INFORMATION_BAR_HEIGHT);
        wgui_inputs_sl_redraw_information_bar();

        /* list */
		gui_pop_up_description_stop_scroll();
        gui_fixed_icontext_menuitem_stop_scroll();
        gui_fixed_icontext_menuitem_start_scroll();
        show_dynamic_list();

        gui_reset_clip();
        
#if defined(__MMI_TOUCH_SCREEN__)
        /* clear background of input area*/
        input_box_y = MMI_SUBMENU_CONTENT_Y + INFORMATION_BAR_HEIGHT + MMI_fixed_list_menu.height + 1;
        gdi_draw_solid_rect(0, input_box_y - 1, UI_device_width - 1, input_box_y + CAT200_INPUTBOX_H, GDI_COLOR_TRANSPARENT);
#endif /* defined(__MMI_TOUCH_SCREEN__) */ 

        /* draw black frame of input area */
        gui_draw_rectangle(
            CAT200_MARGIN_WIDTH,
            input_box_y - 1,
            UI_device_width - CAT200_MARGIN_WIDTH - 1,
            input_box_y + CAT200_INPUTBOX_H,
            ccblack);

        /* draw search image */
        gui_measure_image(get_image(cat200_search_img), &temp_w, &temp_h);
        image_y = ((CAT200_INPUTBOX_H >> 1) - (temp_h >> 1));
        
        if (r2lMMIFlag)
        {        
            input_box_y = MMI_singleline_inputbox.y;
            input_box_x = CAT200_MARGIN_WIDTH + 2;
            image_x1 = UI_device_width - CAT200_MARGIN_WIDTH - 1 - 2 - temp_w;
            image_x2 = UI_device_width - CAT200_MARGIN_WIDTH - 1 - 1;            
        }
        else
        {            
            input_box_y = MMI_singleline_inputbox.y;
            input_box_x = CAT200_INPUTBOX_X;
            image_x1 = CAT200_MARGIN_WIDTH + 1 + 1;
            image_x2 = input_box_x;            
        }
        
        
        gdi_layer_set_clip(CAT200_MARGIN_WIDTH + 1, input_box_y, UI_device_width - CAT200_MARGIN_WIDTH - 1 - 1, input_box_y + CAT200_INPUTBOX_H - 1);
        if (wgui_is_wallpaper_on_bottom() == MMI_TRUE)
        {
            /* clear background of image area */
            gui_fill_rectangle(CAT200_MARGIN_WIDTH + 1, input_box_y, UI_device_width - CAT200_MARGIN_WIDTH - 1 - 1, input_box_y + CAT200_INPUTBOX_H - 1, MMI_singleline_inputbox.normal_filler->c);
        }

        gui_show_image(image_x1, input_box_y + image_y, get_image(cat200_search_img));
        
        wgui_inputs_sl_move(input_box_x, input_box_y);
        redraw_singleline_inputbox();

        gdi_layer_unlock_frame_buffer();
        gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);

#if defined(__MMI_VIRTUAL_KEYBOARD__)
        wgui_virtual_keyboard_register_hide_cursor_callback(wgui_cat_stop_pop_up_description_scroll);
        wgui_virtual_keyboard_register_blink_cursor_callback(wgui_cat_resume_pop_up_description_scroll);
#endif

        /* 
         * In Category 200, redraw_category_screen() is being called here instead of ShowCategory, 
         * since RedrawCategory200Screen is doing many other things like drawing image etc.
         */
    }
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory200Screen
 * DESCRIPTION
 *  Exit category200 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory200Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ClearHighlightHandler();
    reset_softkeys();
    reset_menu_shortcut_handler();
    reset_fixed_list();
    reset_dynamic_list();
    reset_pop_up_descriptions();
    wgui_inputs_sl_close();
    cat200_search_function = NULL;
    g_wgui_cat200_resize_and_move_func = NULL;
    g_wgui_cat200_draw_information_bar_func = NULL;
#ifdef __MMI_UI_HINTS_IN_MENUITEM__
    reset_all_force_flags_for_hints();
    #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gui_unblock_list_effect();
    #endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__*/ 
#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 
    dynamic_item_text_align_left = FALSE;
    g_wgui_cat200_set_specific_highlight = MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory200HistorySize
 * DESCRIPTION
 *  Gets the history buffer size of category 200
 * PARAMETERS
 *  void
 * RETURNS
 *  size in U8s of the history buffer
 *****************************************************************************/
S32 GetCategory200HistorySize(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (((sizeof(list_menu_category_history) + 3) / 4) * 4 + sizeof(singleline_inputbox_category_history));
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory200History
 * DESCRIPTION
 *  Gets the history buffer of category200
 * PARAMETERS
 *  history_buffer      [OUT]        Is the buffer into which the history data is stored
 * RETURNS
 *  return history buffer
 *****************************************************************************/
U8 *GetCategory200History(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 s;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    get_list_menu_category_history(MMI_CATEGORY200_ID, history_buffer);
    s = sizeof(list_menu_category_history);
    s = (s + 3) / 4;
    s *= 4;
    wgui_inputs_sl_get_category_history(MMI_CATEGORY200_ID, (U8*) (history_buffer + s));
    return (history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat200_editor_change_callback
 * DESCRIPTION
 *  editor change callback
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat200_editor_change_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    MMI_fixed_list_menu.last_displayed_item -= MMI_fixed_list_menu.first_displayed_item;
    MMI_fixed_list_menu.first_displayed_item = 0;
    refresh_search_list(MMI_singleline_inputbox.text);
    wgui_inputs_sl_handle_input();
    gdi_layer_unlock_frame_buffer();
    gdi_lcd_repaint_all();
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory200Screen
 * DESCRIPTION
 *  Show Category200 screen (phonebook quick search)
 * PARAMETERS
 *  title                   [IN]        Title id
 *  title_icon              [IN]        Title icon
 *  left_softkey            [IN]        Left soft key label
 *  left_softkey_icon       [IN]        Left soft key icon
 *  right_softkey           [IN]        Right soft key label
 *  right_softkey_icon      [IN]        Right soft key icon
 *  number_of_items         [IN]        Number of items
 *  get_item_func           [IN]        Callback function of get menu item 
 *  get_hint_func           [IN]        Callback function of get menu item hint
 *  highlighted_item        [IN]        Highlighted item index
 *  search_image            [IN]        Seach image in input area
 *  buffer                  [IN]        Buffer
 *  buffer_max_length       [IN]        Buffer max length
 *  history_buffer          [IN]        Histpry buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory200Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        S32 number_of_items,
        GetItemFuncPtr get_item_func,
        GetHintFuncPtr get_hint_func,
        S32 highlighted_item,
        U16 search_image,
        U8 *buffer,
        S32 buffer_max_length,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 input_box_width = 0, list_height = 0, max_entries = 0;
    U8 h_flag;
    BOOL application_present;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    ShowListCategoryScreen_ext(
        get_string(title),
        get_image(title_icon),
        get_string(left_softkey),
        get_image(left_softkey_icon),
        get_string(right_softkey),
        get_image(right_softkey_icon));

	wgui_singleline_inputbox_LSK_label_icon = get_image(left_softkey_icon);
    wgui_singleline_inputbox_LSK_label_string = get_string(left_softkey);

    g_wgui_cat200_resize_and_move_func = wgui_cat200_resize_and_move;
    g_wgui_cat200_draw_information_bar_func = wgui_inputs_sl_redraw_information_bar;

    dynamic_item_text_align_left = TRUE;
    
    wgui_dynamic_list_create_icontext_menu(
        number_of_items,
        get_item_func,
        get_hint_func,
        WGUI_LIST_INVALID_HIGHLIGHT,
        MMI_FALSE,
        UI_dummy_function,
        0,
        0,
        NULL);

    if (wgui_check_application_present)
    {
        application_present = wgui_check_application_present(&max_entries);     /* true in case of dictionary */
    }
    else
    {
        application_present = MMI_FALSE;
    }

    if (application_present)
    {
        /* number of words goes beyond this limit, and increases at the run time */
        set_menu_item_count(max_entries);
    }
    else
    {
        set_menu_item_count(number_of_items);
    }

#ifdef __MMI_TOUCH_SCREEN__
    /* Because the list menu is resized according to virtual keyboard */
    MMI_fixed_list_menu.flags |= UI_LIST_MENU_ALIGN_TO_TOP;
#endif /* __MMI_TOUCH_SCREEN__ */ 

    list_height = UI_device_height - MMI_button_bar_height - MMI_SUBMENU_CONTENT_Y - CAT200_INPUTBOX_H - INFORMATION_BAR_HEIGHT - 2;
    resize_fixed_list(MMI_content_width, list_height);
    move_fixed_list(0, MMI_SUBMENU_CONTENT_Y + INFORMATION_BAR_HEIGHT);
    
    h_flag = set_list_menu_category_history(MMI_CATEGORY200_ID, history_buffer);
#ifdef __MMI_UI_HINTS_IN_MENUITEM__
    if (get_hint_func)
    {
        if (is_set_force_icon_on_highlight_only_in_menuitem())
        {
            wgui_show_icon_only_highlight_in_icontext_menuitem();
        }
        if (is_set_force_all_hints_in_menuitem())
        {
            wgui_enable_hints_in_icontext_menuitem();
        }
        else if (is_set_force_hints_on_highlight_in_menuitem())
        {
            wgui_enable_hint_highlight_in_icontext_menuitem();
        }
        else
        {
            wgui_enable_hint_highlight_in_icontext_menuitem();
        }

        if (history_buffer != NULL)
        {
            set_dynamic_pop_up_descriptions(MMI_fixed_list_menu.highlighted_item);
        }
        else
        {
            set_dynamic_pop_up_descriptions(highlighted_item);
        }

    #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        gui_block_list_effect();
    #endif 
    }
#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 

    input_box_x = CAT200_INPUTBOX_X;
    input_box_y = MMI_SUBMENU_CONTENT_Y + INFORMATION_BAR_HEIGHT + MMI_fixed_list_menu.height + 1;    
    input_box_width = MAIN_LCD_DEVICE_WIDTH - CAT200_INPUTBOX_X - CAT200_MARGIN_WIDTH - 1 /* border */;

    if (history_buffer != NULL)
    {
        S32 size = sizeof(list_menu_category_history);

        size = (size + 3) / 4;
        size *= 4;
        wgui_inputs_sl_disable_up_down_key_register(MMI_TRUE);
        wgui_inputs_sl_setup(
            input_box_x,
            input_box_y,
            input_box_width,
            CAT200_INPUTBOX_H,
            buffer,
            buffer_max_length,
            MMI_CATEGORY200_ID,
            get_string(right_softkey),
            get_image(right_softkey_icon),
            IMM_INPUT_TYPE_QUICK_SEARCH,
            (U8*) (history_buffer + size),
            1);
        list_height -= mmi_imc_get_current_imui_height();
        resize_fixed_list(MMI_content_width, list_height);
        dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);

        if (cat200_search_function)
        {
            if (!application_present)
            {
                S32 no_entries;

                no_entries = cat200_search_function((U8*) MMI_singleline_inputbox.text);
                load_dynamic_item_buffer(no_entries);
                refresh_search_list_change_list_ext(no_entries, MMI_fixed_list_menu.highlighted_item);
            }
        }
    }
    else /* initial */
    {
        dynamic_list_goto_item_no_redraw(highlighted_item);
        wgui_inputs_sl_disable_up_down_key_register(MMI_TRUE);
        wgui_inputs_sl_setup(
            input_box_x,
            input_box_y,
            input_box_width,
            CAT200_INPUTBOX_H,
            buffer,
            buffer_max_length,
            MMI_CATEGORY200_ID,
            get_string(right_softkey),
            get_image(right_softkey_icon),
            IMM_INPUT_TYPE_QUICK_SEARCH,
            NULL,
            1);
    }

    gui_set_single_line_input_box_theme(&MMI_singleline_inputbox, &cat200_singleline_inputbox_theme);
    cat200_search_img = search_image;

    resize_dynamic_icontext_menuitems_to_list_width();
    if (h_flag)
    {
        set_dynamic_pop_up_descriptions(MMI_fixed_list_menu.highlighted_item);

        if (application_present)
        {
            if (MMI_fixed_list_menu.highlighted_item <= 0)
            {
                ClearKeyHandler(KEY_UP_ARROW, KEY_EVENT_DOWN);
                ClearKeyHandler(KEY_VOL_UP, KEY_EVENT_DOWN);
            }
        }
    }
    else
    {
        set_dynamic_pop_up_descriptions(highlighted_item);
    }

    singleline_inputbox_input_callback();
    if (!h_flag)
    {
        if (number_of_items > 0)
        {
            set_left_softkey_label(wgui_singleline_inputbox_LSK_label_string);
            set_left_softkey_icon(wgui_singleline_inputbox_LSK_label_icon);
            redraw_left_softkey();
            register_left_softkey_handler();
            set_left_softkey_function(wgui_singleline_inputbox_LSK_function, KEY_EVENT_UP);
            set_left_softkey_function(UI_dummy_function, KEY_EVENT_DOWN);
        }
        else
        {
            set_left_softkey_label(NULL);
            set_left_softkey_icon(NULL);
            redraw_left_softkey();
            set_left_softkey_function(UI_dummy_function, KEY_EVENT_UP);
            set_left_softkey_function(UI_dummy_function, KEY_EVENT_DOWN);
        }
    }
    
    register_singleline_inputbox_input_callback(wgui_cat200_editor_change_callback);

    gdi_layer_unlock_frame_buffer();
    ExitCategoryFunction = ExitCategory200Screen;
    dm_setup_category_functions(dm_redraw_category_screen, GetCategory200History, GetCategory200HistorySize);
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
#ifdef __MMI_TOUCH_SCREEN__
    dm_data.s32flags |= DM_SHOW_VKPAD;
#endif /* __MMI_TOUCH_SCREEN__ */
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY200_ID;
    dm_setup_data(&dm_data);
    dm_register_category_controlled_callback(RedrawCategoryControlledArea200Screen);
    
#ifdef __MMI_TOUCH_SCREEN__
    dm_register_vkpad_callback(wgui_cat200_virtual_keypad_callback);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenDownHandler, MMI_PEN_EVENT_DOWN);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenUpHandler, MMI_PEN_EVENT_UP);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenMoveHandler, MMI_PEN_EVENT_MOVE);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenLongTapHandler, MMI_PEN_EVENT_LONG_TAP);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenRepeatHandler, MMI_PEN_EVENT_REPEAT);
#endif /* __MMI_TOUCH_SCREEN__ */ 

#if defined(__MMI_VIRTUAL_KEYBOARD__)
    wgui_virtual_keyboard_register_hide_cursor_callback(wgui_cat_stop_pop_up_description_scroll);
    wgui_virtual_keyboard_register_blink_cursor_callback(wgui_cat_resume_pop_up_description_scroll);
#endif

    dm_redraw_category_screen();
}


#if defined(__MMI_MAINLCD_128X128__)
UI_filled_area g_cat199_inputbox_BG_filler = 
{
    UI_FILLED_AREA_TYPE_COLOR,
    UI_NULL_IMAGE,
    NULL,
    {180, 180, 180, 100},   /* gray because no black frame */
    {0, 0, 0, 0},
    {180, 180, 180, 100},
    {180, 180, 180, 100},
    0
};
#else  /* defined(__MMI_MAINLCD_128X128__) */
UI_filled_area g_cat199_inputbox_BG_filler = 
{
    UI_FILLED_AREA_TYPE_COLOR,
    UI_NULL_IMAGE,
    NULL,
    {255, 255, 255, 100},
    {0, 0, 0, 0},
    {255, 255, 255, 100},
    {255, 255, 255, 100},
    0
};
#endif /* defined(__MMI_MAINLCD_128X128__) */


UI_single_line_input_box_theme g_cat199_singleline_inputbox_theme = { 
    &g_cat199_inputbox_BG_filler,
    &g_cat199_inputbox_BG_filler,
    &g_cat199_inputbox_BG_filler,
    {0, 0, 0, 100},
    {128, 128, 128, 100},
    {0, 0, 0, 100},
    {255, 255, 255, 100},
    {51, 88, 171, 100},
    {255, 0, 0, 100},
    &UI_DEFAULT_FONT,
    1,
    UI_SINGLE_LINE_INPUT_BOX_CENTER_Y,
    '*'
};


/*****************************************************************************
 * FUNCTION
 *  wgui_cat199_set_left_and_right_arrow_key
 * DESCRIPTION
 *  Because IME will register left and right arrow key and will not restore it
 *   so category should restore left and right arrow key by ourselves.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat199_set_left_and_right_arrow_key(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
        
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetKeyHandler(mmi_frm_general_tab_l_arrow_key_hdlr, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(mmi_frm_general_tab_r_arrow_key_hdlr, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat199_draw_input_method
 * DESCRIPTION
 *  draw input method in the end of singleline inputbox
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat199_draw_input_method(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	S32 x1 = 0, y1 = 0, x2 = 0, y2 = 0, sl_w = 0, sl_x = 0;
    U32 ime_w = 0;
        
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    gdi_layer_lock_frame_buffer();
	gdi_layer_push_clip();

    gdi_layer_set_clip(
        0, 
        MMI_singleline_inputbox.y,
        UI_device_width - 1,
        MMI_singleline_inputbox.y + MMI_singleline_inputbox.height - 1);

    ime_w = mmi_imc_get_input_mode_hint_width();

    if (r2lMMIFlag)
    {
        y1 = MMI_singleline_inputbox.y;
        y2 = MMI_singleline_inputbox.y + MMI_singleline_inputbox.height - 1;
        x1 = CAT199_MARGIN_WIDTH;        
        x2 = x1 + ime_w - 1;
        sl_w = UI_device_width - CAT199_MARGIN_WIDTH - x2;
        sl_x = x2 + 1;
    }
    else
    {
        x2 = UI_device_width - CAT199_MARGIN_WIDTH - 1;
        y1 = MMI_singleline_inputbox.y;
        y2 = MMI_singleline_inputbox.y + MMI_singleline_inputbox.height - 1;
        ime_w = mmi_imc_get_input_mode_hint_width();
        x1 = x2 - ime_w + 1;
        sl_w = x1 - MMI_singleline_inputbox.x + 1;
        sl_x = CAT199_MARGIN_WIDTH;
    }

    /* draw IME background */ 
    gui_fill_rectangle(x1, y1, x2, y2, /*gui_color(255,0,0));*/ MMI_singleline_inputbox.normal_filler->c);

    mmi_imc_draw_input_mode_hint(x1, y1, x2, y2);

    if (MMI_singleline_inputbox.width != sl_w || MMI_singleline_inputbox.x != x1)
    {
        wgui_inputs_sl_resize(sl_w, MMI_singleline_inputbox.height);
        wgui_inputs_sl_move(sl_x, MMI_singleline_inputbox.y);
        wgui_inputs_sl_redraw();
    }
    
	gdi_layer_pop_clip();
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat199_resize_and_move
 * DESCRIPTION
 *  resize and move list & singleline inputbox
 * PARAMETERS
 *  inputbox_y   [IN]   singleline inputbox y position
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat199_resize_and_move(S32 inputbox_y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 menu_h = 0;
    S32 first_item, last_item;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_MAINLCD_128X128__)
    menu_h = inputbox_y - MMI_fixed_list_menu.y;
#else
    inputbox_y -= 1; /* button border */
    menu_h = inputbox_y - MMI_fixed_list_menu.y - 1 /* up border */;
#endif /* defined(__MMI_MAINLCD_128X128__) */
    resize_fixed_list(MMI_fixed_list_menu.width, menu_h);
    gui_dynamic_list_menu_locate_highlighted_item(&MMI_fixed_list_menu);
    first_item = MMI_fixed_list_menu.first_displayed_item;
    last_item = MMI_fixed_list_menu.last_displayed_item;
    dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
    MMI_fixed_list_menu.first_displayed_item = first_item;
    MMI_fixed_list_menu.last_displayed_item = last_item;
    wgui_inputs_sl_move(MMI_singleline_inputbox.x, inputbox_y);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat199_redraw_controlled_area
 * DESCRIPTION
 *  redraw category199 controlled area
 *   1. dynamic list
 *   2. input method
 *   3. singleline inputbox
 * PARAMETERS
 *  coordinate   [IN]   control area coordinate (not used)
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat199_redraw_controlled_area(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    color ccblack = {0, 0, 0, 100};    
    S32 temp_w = 0, temp_h = 0, image_y = 0, tab_h = 0, scrolltext_h = 0;
        
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(coordinate);
    gdi_layer_lock_frame_buffer();

    gui_reset_clip();
    gdi_layer_reset_clip();

    /* list */
    gui_fixed_icontext_menuitem_stop_scroll();
    gui_fixed_icontext_menuitem_start_scroll();
    gui_pop_up_description_stop_scroll();
    show_dynamic_list();
    
    gui_reset_clip();

#if defined(__MMI_TOUCH_SCREEN__)
#if defined(__MMI_MAINLCD_128X128__) || (defined(__MMI_MAINLCD_320X240__) && defined(__MMI_VIRTUAL_KEYBOARD__))
    tab_h = MMI_HORIZONTAL_TAB_BAR_TAB_AREA_HEIGHT;
#else
    tab_h = MMI_HORIZONTAL_TAB_BAR_TAB_AREA_HEIGHT + MMI_HORIZONTAL_TAB_BAR_HINT_AREA_HEIGHT;
    if (g_dm_data.s32CatId ==  MMI_CATEGORY199_SCROLLTEXT_ID)
    {
        scrolltext_h = CAT202_SCROLL_HEIGHT;
    }
#endif /* defined(__MMI_MAINLCD_128X128__) */
    /* clear background of input area*/
    input_box_y = MMI_HORIZONTAL_TAB_BAR_Y + tab_h + scrolltext_h + MMI_fixed_list_menu.height + 1;
    gdi_draw_solid_rect(0, input_box_y - 1, UI_device_width - 1, input_box_y + CAT199_INPUTBOX_H, GDI_COLOR_TRANSPARENT);
#endif /* defined(__MMI_TOUCH_SCREEN__) */ 

    wgui_cat199_draw_input_method();

/* draw black frame of input area */
#if !defined(__MMI_MAINLCD_128X128__)
    gui_draw_rectangle(
        CAT199_MARGIN_WIDTH - 1,
        input_box_y - 1,
        UI_device_width - CAT199_MARGIN_WIDTH,
        input_box_y + CAT199_INPUTBOX_H,
        ccblack);
#endif /* !defined(__MMI_MAINLCD_128X128__) */
    redraw_singleline_inputbox(); 

    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);

#if defined(__MMI_VIRTUAL_KEYBOARD__)
    wgui_virtual_keyboard_register_hide_cursor_callback(wgui_cat_stop_pop_up_description_scroll);
    wgui_virtual_keyboard_register_blink_cursor_callback(wgui_cat_resume_pop_up_description_scroll);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat199_refresh_search_list
 * DESCRIPTION
 *  refresh category199 search list
 * PARAMETERS
 *  no_entries         [IN]   number of menu item
 *  highlighted_item   [IN]   highlight item
 *  has_tab_title      [IN]   if tab has title
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat199_refresh_search_list(S32 no_entries, S32 highlighted_item, BOOL has_tab_title)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 max_entries = 0;
    BOOL showOption, application_present;
    S32 first_item, last_item;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_fixed_list_menu.highlighted_item = highlighted_item;
    MMI_fixed_list_menu.n_items = no_entries;
    MMI_fixed_list_menu.displayed_items = no_entries;

    application_present = MMI_FALSE;

    if (has_tab_title == TRUE)
    {
        set_menu_item_count(no_entries);
    }
    showOption = no_entries > 0 ? MMI_TRUE : MMI_FALSE;

    if (showOption)
    {
        set_left_softkey_label(wgui_singleline_inputbox_LSK_label_string);
        set_left_softkey_icon(wgui_singleline_inputbox_LSK_label_icon);
        //redraw_left_softkey();
        register_left_softkey_handler();
        set_left_softkey_function(wgui_singleline_inputbox_LSK_function, KEY_EVENT_UP);
        set_left_softkey_function(UI_dummy_function, KEY_EVENT_DOWN);
        first_item = MMI_fixed_list_menu.first_displayed_item;
        last_item = MMI_fixed_list_menu.last_displayed_item;
        dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
        MMI_fixed_list_menu.first_displayed_item = first_item;
        MMI_fixed_list_menu.last_displayed_item = last_item;
    }
    else
    {
        set_left_softkey_label(NULL);
        set_left_softkey_icon(NULL);
        //redraw_left_softkey();
        set_left_softkey_function(UI_dummy_function, KEY_EVENT_UP);
        set_left_softkey_function(UI_dummy_function, KEY_EVENT_DOWN);
        gui_fixed_icontext_menuitem_stop_scroll();
        gui_pop_up_description_stop_scroll();
        wgui_title_set_menu_shortcut_number(0);
        wgui_current_pop_up_description_index = -1;
    }

	//if (has_tab_title == TRUE)
    //{
    //    draw_title();
    //}

    //show_dynamic_list();
}



/*****************************************************************************
 * FUNCTION
 *  ExitCategory199Screen
 * DESCRIPTION
 *  Exit function of category199
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory199Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ClearHighlightHandler();
    reset_softkeys();
    reset_menu_shortcut_handler();
    reset_fixed_list();
    reset_pop_up_descriptions();
    wgui_inputs_sl_close();    
    wgui_close_horizontal_tab_bar();
    reset_dynamic_list();
    cat200_search_function = NULL;
    g_wgui_cat200_resize_and_move_func = NULL;
    g_wgui_cat200_draw_information_bar_func = NULL;
    g_wgui_cat200_set_special_key_func = NULL;
#ifdef __MMI_UI_HINTS_IN_MENUITEM__
    reset_all_force_flags_for_hints();
    #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gui_unblock_list_effect();
    #endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__*/ 
#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 
    dynamic_item_text_align_left = FALSE;
    g_wgui_cat199_has_checkbox = MMI_FALSE;
	g_wgui_cat199_disable_tab_title = MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat199_get_history_size
 * DESCRIPTION
 *  Gets the history buffer size of category 199
 * PARAMETERS
 *  void
 * RETURNS
 *  S32
 *****************************************************************************/
S32 wgui_cat199_get_history_size(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (((sizeof(list_menu_category_history) + 3) / 4) * 4 + sizeof(singleline_inputbox_category_history));
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat199_get_history
 * DESCRIPTION
 *  Gets the history buffer of category199
 * PARAMETERS
 *  history_buffer      [OUT]        The buffer into which the history data is stored
 * RETURNS
 *  U8*
 *****************************************************************************/
U8 *wgui_cat199_get_history(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 s;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    get_list_menu_category_history(MMI_CATEGORY199_ID, history_buffer);
    s = sizeof(list_menu_category_history);
    s = (s + 3) / 4;
    s *= 4;
    wgui_inputs_sl_get_category_history(MMI_CATEGORY199_ID, (U8*) (history_buffer + s));
    return (history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory199Screen
 * DESCRIPTION
 *  Show category199 screen
 * PARAMETERS
 *  left_softkey            [IN]        Left soft key label
 *  left_softkey_icon       [IN]        Left soft key icon
 *  right_softkey           [IN]        Right soft key label
 *  right_softkey_icon      [IN]        Right soft key icon
 *  highlighted_tab         [IN]        Highlighted tab
 *  tab_title               [IN]        Tab title
 *  number_of_items         [IN]        Number of items
 *  info_message            [IN]        Text in info area, NULL will not show info area
 *  get_item_func           [IN]        Callback function of get menu item 
 *  get_hint_func           [IN]        Callback function of get menu item hint
 *  get_state_func          [IN]        Callback function of get state, NULL will not show check box
 *  set_state_func          [IN]        Callback function of state changed, NULL will not show check box
 *  highlighted_item        [IN]        Highlighted item index
 *  buffer                  [IN]        Buffer
 *  buffer_max_length       [IN]        Buffer max length
 *  history_buffer          [IN]        Histpry buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory199Screen(
        UI_string_type left_softkey,
        PU8 left_softkey_icon,
        UI_string_type right_softkey,
        PU8 right_softkey_icon,
        S8 highlighted_tab,
        UI_string_type tab_title,
        UI_string_type info_message,
        S32 number_of_items,
        GetItemFuncPtr get_item_func,
        GetHintFuncPtr get_hint_func,
        checkbox_get_image_funcptr_type get_state_func,
        checkbox_clicked_funcptr_type set_state_func,
        S32 highlighted_item,
        U8 *buffer,
        S32 buffer_max_length,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 input_box_width = 0, list_height = 0, max_entries = 0, i = 0, tab_h = 0, scrolltext_h = 0;
    U8 h_flag;
    BOOL has_tab_title;
    S8 n_tabs;
    S32 first_item, last_item;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    /* softkey */
    dm_add_softkey(left_softkey, left_softkey_icon, right_softkey, right_softkey_icon);
      
    /* horizontal tab bar */
#if defined(__MMI_MAINLCD_128X128__) || (defined(__MMI_MAINLCD_320X240__) && defined(__MMI_VIRTUAL_KEYBOARD__))
    has_tab_title = FALSE;
	g_wgui_cat199_disable_tab_title = MMI_TRUE;
    tab_h = MMI_HORIZONTAL_TAB_BAR_TAB_AREA_HEIGHT;
#else
    has_tab_title = TRUE;
	g_wgui_cat199_disable_tab_title = MMI_FALSE;
    tab_h = MMI_HORIZONTAL_TAB_BAR_TAB_AREA_HEIGHT + MMI_HORIZONTAL_TAB_BAR_HINT_AREA_HEIGHT;
    if (info_message != NULL)
    {
        scrolltext_h = CAT202_SCROLL_HEIGHT;
        /* Scroll Text */
        dm_add_scroll_text(
            (UI_string_type)info_message, 
            NULL, 
            wgui_category_clear_region_with_transparent_color, 
            *current_MMI_theme->list_normal_text_color,
            *current_MMI_theme->list_normal_text_color);
    }
#endif /* defined(__MMI_MAINLCD_128X128__) */

    mmi_frm_get_tab_bar_items(MMI_tab_bar_items, &n_tabs); 
    wgui_create_horizontal_tab_bar(has_tab_title, tab_title, n_tabs, highlighted_tab, MMI_TRUE);
    if (has_tab_title == FALSE)
    {
        wgui_setup_horizontal_tab_bar_no_title_shortcut();
    }
    
    dynamic_item_text_align_left = TRUE;

    wgui_dynamic_list_create_icontext_menu(
        number_of_items,
        get_item_func,
        get_hint_func,
        WGUI_LIST_INVALID_HIGHLIGHT,
        MMI_FALSE,
        UI_dummy_function,
        0,
        0,
        NULL);

    if (has_tab_title == FALSE)
    {
        wgui_set_disable_shortcut_display();
    }
    else
    {
        set_menu_item_count(number_of_items);
    }

#ifdef __MMI_TOUCH_SCREEN__
    /* Because the list menu is resized according to virtual keyboard */
    MMI_fixed_list_menu.flags |= UI_LIST_MENU_ALIGN_TO_TOP;
#endif /* __MMI_TOUCH_SCREEN__ */ 

    list_height = UI_device_height - MMI_HORIZONTAL_TAB_BAR_Y - tab_h - scrolltext_h - CAT199_INPUTBOX_H - MMI_BUTTON_BAR_HEIGHT;
#if !defined(__MMI_MAINLCD_128X128__)
    list_height -= 2; /* border */
#endif

    resize_fixed_list(MMI_content_width, list_height);
    move_fixed_list(0, MMI_HORIZONTAL_TAB_BAR_Y + tab_h + scrolltext_h);
    
    h_flag = set_list_menu_category_history(MMI_CATEGORY199_ID, history_buffer);
#ifdef __MMI_UI_HINTS_IN_MENUITEM__
    if (get_hint_func)
    {
        if (is_set_force_icon_on_highlight_only_in_menuitem())
        {
            wgui_show_icon_only_highlight_in_icontext_menuitem();
        }
        if (is_set_force_all_hints_in_menuitem())
        {
            wgui_enable_hints_in_icontext_menuitem();
        }
        else if (is_set_force_hints_on_highlight_in_menuitem())
        {
            wgui_enable_hint_highlight_in_icontext_menuitem();
        }
        else
        {
            wgui_enable_hint_highlight_in_icontext_menuitem();
        }

        if (h_flag)
        {
            set_dynamic_pop_up_descriptions(MMI_fixed_list_menu.highlighted_item);
        }
        else
        {
            set_dynamic_pop_up_descriptions(highlighted_item);
        }

    #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        gui_block_list_effect();
    #endif 
    }
#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 

    if ((get_state_func != NULL) && (set_state_func != NULL))
    {
        /* if function isn't NULL, then set check-box */
        wgui_menuitem_set_icontext_checkbox_position(1, 0);
        wgui_menuitem_register_icontext_checkbox_callback(set_state_func, get_state_func);
        set_fixed_icontext_positions((2*CFG_UI_ICONTEXT_MENUITEM_TEXT_X - CFG_UI_ICONTEXT_MENUITEM_ICON_X), 0, CFG_UI_ICONTEXT_MENUITEM_TEXT_X, 0);
        g_wgui_cat199_has_checkbox = MMI_TRUE;
    }

    wgui_singleline_inputbox_LSK_label_icon = left_softkey_icon;
    wgui_singleline_inputbox_LSK_label_string = left_softkey;
    g_wgui_cat200_resize_and_move_func = wgui_cat199_resize_and_move;
    g_wgui_cat200_draw_information_bar_func = wgui_cat199_draw_input_method;
    g_wgui_cat200_set_special_key_func = wgui_cat199_set_left_and_right_arrow_key;

    input_box_x = CAT199_MARGIN_WIDTH;
    input_box_y = UI_device_height - MMI_BUTTON_BAR_HEIGHT - CAT199_INPUTBOX_H;
    input_box_width = UI_device_width - CAT199_MARGIN_WIDTH - CAT199_MARGIN_WIDTH;
    
#if !defined(__MMI_MAINLCD_128X128__)
    input_box_y -= 1; /* buttom border */
#endif

    if (h_flag)
    {
        S32 size = sizeof(list_menu_category_history);

        size = (size + 3) / 4;
        size *= 4;

        first_item = MMI_fixed_list_menu.first_displayed_item;
        last_item = MMI_fixed_list_menu.last_displayed_item;
        dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
        MMI_fixed_list_menu.first_displayed_item = first_item;
        MMI_fixed_list_menu.last_displayed_item = last_item;

        wgui_inputs_sl_disable_up_down_key_register(MMI_TRUE);
        wgui_inputs_sl_disable_left_right_key_register(MMI_TRUE);
        wgui_inputs_sl_setup(
            input_box_x,
            input_box_y,
            input_box_width,
            CAT199_INPUTBOX_H,
            buffer,
            buffer_max_length,
            MMI_CATEGORY199_ID,
            right_softkey,
            right_softkey_icon,
            IMM_INPUT_TYPE_QUICK_SEARCH,
            (U8*) (history_buffer + size),
            0);
        if (cat200_search_function)
        {
            S32 no_entries;

            no_entries = cat200_search_function((U8*) MMI_singleline_inputbox.text);
            load_dynamic_item_buffer(no_entries);
            //refresh_search_list_change_list_ext(no_entries, MMI_fixed_list_menu.highlighted_item);
            wgui_cat199_refresh_search_list(no_entries, MMI_fixed_list_menu.highlighted_item, has_tab_title);
        }
    }
    else /* initial */
    {
        dynamic_list_goto_item_no_redraw(highlighted_item);
        wgui_inputs_sl_disable_up_down_key_register(MMI_TRUE);
        wgui_inputs_sl_disable_left_right_key_register(MMI_TRUE);
        wgui_inputs_sl_setup(
            input_box_x,
            input_box_y,
            input_box_width,
            CAT199_INPUTBOX_H,
            buffer,
            buffer_max_length,
            MMI_CATEGORY199_ID,
            right_softkey,
            right_softkey_icon,
            IMM_INPUT_TYPE_QUICK_SEARCH,
            NULL,
            0);
    }

    gui_set_single_line_input_box_theme(&MMI_singleline_inputbox, &g_cat199_singleline_inputbox_theme);

    resize_dynamic_icontext_menuitems_to_list_width();
    if (h_flag)
    {
        set_dynamic_pop_up_descriptions(MMI_fixed_list_menu.highlighted_item);
    }
    else
    {
        set_dynamic_pop_up_descriptions(highlighted_item);
    }

    singleline_inputbox_input_callback();
    if (!h_flag)
    {
        if (number_of_items > 0)
        {
            set_left_softkey_label(wgui_singleline_inputbox_LSK_label_string);
            set_left_softkey_icon(wgui_singleline_inputbox_LSK_label_icon);
            redraw_left_softkey();
            register_left_softkey_handler();
            set_left_softkey_function(wgui_singleline_inputbox_LSK_function, KEY_EVENT_UP);
            set_left_softkey_function(UI_dummy_function, KEY_EVENT_DOWN);
        }
        else
        {
            set_left_softkey_label(NULL);
            set_left_softkey_icon(NULL);
            redraw_left_softkey();
            set_left_softkey_function(UI_dummy_function, KEY_EVENT_UP);
            set_left_softkey_function(UI_dummy_function, KEY_EVENT_DOWN);
        }
    }
    
    register_singleline_inputbox_input_callback(wgui_cat200_editor_change_callback);

    gdi_layer_unlock_frame_buffer();
    ExitCategoryFunction = ExitCategory199Screen;
    dm_setup_category_functions(dm_redraw_category_screen, wgui_cat199_get_history, wgui_cat199_get_history_size);
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
#ifdef __MMI_TOUCH_SCREEN__
    dm_data.s32flags |= DM_SHOW_VKPAD;
#endif /* __MMI_TOUCH_SCREEN__ */
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    if (info_message != NULL)
    {
        dm_data.s32CatId = MMI_CATEGORY199_SCROLLTEXT_ID;
    }
    else
    {
        dm_data.s32CatId = MMI_CATEGORY199_ID;
    }
    dm_setup_data(&dm_data);
    dm_register_category_controlled_callback(RedrawCategoryControlledArea200Screen);
    
#ifdef __MMI_TOUCH_SCREEN__
    dm_register_vkpad_callback(wgui_cat200_virtual_keypad_callback);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenDownHandler, MMI_PEN_EVENT_DOWN);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenUpHandler, MMI_PEN_EVENT_UP);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenMoveHandler, MMI_PEN_EVENT_MOVE);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenLongTapHandler, MMI_PEN_EVENT_LONG_TAP);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenRepeatHandler, MMI_PEN_EVENT_REPEAT);
#endif /* __MMI_TOUCH_SCREEN__ */ 

#if defined(__MMI_VIRTUAL_KEYBOARD__)
    wgui_virtual_keyboard_register_hide_cursor_callback(wgui_cat_stop_pop_up_description_scroll);
    wgui_virtual_keyboard_register_blink_cursor_callback(wgui_cat_resume_pop_up_description_scroll);
#endif

    dm_redraw_category_screen();
}


extern void DrawCate384CategoryControlAreaBackground(S32 x1, S32 y1, S32 x2, S32 y2);

/*****************************************************************************
 * FUNCTION
 *  RedrawCategoryControlledArea202Screen
 * DESCRIPTION
 *  redraw category202
 * PARAMETERS
 *  coordinate      [IN]     Area to redraw     
 * RETURNS
 *  void
 *****************************************************************************/
void RedrawCategoryControlledArea202Screen(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    color ccblack = {0, 0, 0, 100};
    S32 temp_w = 0, temp_h = 0, image_y = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    gui_reset_clip();
    gdi_layer_reset_clip();
#if !defined(GUI_EDITOR_SHOW_TITLE)
    wgui_setup_input_information(
            0, 0,
            UI_device_width, INFORMATION_BAR_HEIGHT);
#else
    wgui_setup_input_information(
            0, CAT202_SCROLL_Y - INFORMATION_BAR_HEIGHT,
            UI_device_width, INFORMATION_BAR_HEIGHT);
#endif
    wgui_redraw_singleline_input_information_bar();

    /* list */
    gui_fixed_icontext_menuitem_stop_scroll();
    gui_fixed_icontext_menuitem_start_scroll();
    gui_pop_up_description_stop_scroll();
    show_dynamic_list();

    gui_reset_clip();
#if defined(__MMI_TOUCH_SCREEN__)
    input_box_y = MMI_singleline_inputbox.y;
    gdi_draw_solid_rect(0, input_box_y - 1, UI_device_width - 1, input_box_y + CAT200_INPUTBOX_H, GDI_COLOR_TRANSPARENT);
#endif /* defined(__MMI_TOUCH_SCREEN__) */ 
    gui_draw_rectangle(
        CAT200_MARGIN_WIDTH,
        (input_box_y - 1),
        (UI_device_width - CAT200_MARGIN_WIDTH - 1),
        (input_box_y + CAT200_INPUTBOX_H),
        ccblack);
    gdi_layer_set_clip(CAT200_MARGIN_WIDTH + 1, input_box_y, (input_box_x), (input_box_y + CAT200_INPUTBOX_H - 1));

    gui_measure_image(get_image(cat200_search_img), &temp_w, &temp_h);
    image_y = ((CAT200_INPUTBOX_H >> 1) - (temp_h >> 1));
    if (wgui_is_wallpaper_on_bottom() == MMI_TRUE)
    {
        gui_fill_rectangle(CAT200_MARGIN_WIDTH + 1, input_box_y, input_box_x, input_box_y + CAT200_INPUTBOX_H - 1, MMI_singleline_inputbox.normal_filler->c);
    }
    gui_show_image(CAT200_MARGIN_WIDTH + 2, (input_box_y + image_y), get_image(cat200_search_img));
    
    redraw_singleline_inputbox();

    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);

#if defined(__MMI_VIRTUAL_KEYBOARD__)
    wgui_virtual_keyboard_register_hide_cursor_callback(wgui_cat_stop_pop_up_description_scroll);
    wgui_virtual_keyboard_register_blink_cursor_callback(wgui_cat_resume_pop_up_description_scroll);
#endif
}

/*****************************************************************************
 * FUNCTION
 *  cat202_virtual_keypad_callback
 * DESCRIPTION
 *  virtual keypad callback of category 202
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void cat202_virtual_keypad_callback(void)
{
#if defined(__MMI_TOUCH_SCREEN__)
    mmi_imc_redraw_screen_by_state();
#endif /* defined(__MMI_TOUCH_SCREEN__) */ 
}

/*****************************************************************************
 * FUNCTION
 *  ExitCategory202Screen
 * DESCRIPTION
 *  exit function of category202
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory202Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ClearHighlightHandler();
    reset_softkeys();
    reset_menu_shortcut_handler();
    reset_fixed_list();
    reset_dynamic_list();
    reset_pop_up_descriptions();
    wgui_close_singleline_inputbox();
    cat200_search_function = NULL;
    g_wgui_cat200_resize_and_move_func = NULL;
    g_wgui_cat200_draw_information_bar_func = NULL;
#ifdef __MMI_UI_HINTS_IN_MENUITEM__
    reset_all_force_flags_for_hints();
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gui_unblock_list_effect();
#endif 
#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 

}



/*****************************************************************************
 * FUNCTION
 *  ShowCategory202Screen
 * DESCRIPTION
 *  category screen of phone search and Multi Select
 * PARAMETERS
 *  title                   [IN]        Title id
 *  title_icon              [IN]        Title icon
 *  left_softkey            [IN]        Left soft key label
 *  left_softkey_icon       [IN]        Left soft key icon
 *  right_softkey           [IN]        Right soft key label
 *  right_softkey_icon      [IN]        Right soft key icon
 *  number_of_items         [IN]        Number of items
 *  get_item_func           [IN]        
 *  get_hint_func           [IN]        
 *  highlighted_item        [IN]        Highlighted item index
 *  search_image            [IN]        Seach image
 *  buffer                  [IN]        Buffer
 *  buffer_max_length       [IN]        
 *  history_buffer          [IN]        Histpry buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory202Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U8* info_message,
        S32 number_of_items,
        GetItemFuncPtr get_item_func,
        GetHintFuncPtr get_hint_func,
        checkbox_get_image_funcptr_type get_state_func,
        checkbox_clicked_funcptr_type set_state_func,        
        S32 highlighted_item,
        U16 search_image,
        U8 *buffer,
        S32 buffer_max_length,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 input_box_width = 0;
    U8 h_flag;
    S32 scroll_height = 0;
    S32 first_item, last_item;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_setup_common_layout();

    gdi_layer_lock_frame_buffer();

    g_wgui_cat200_resize_and_move_func = wgui_cat200_resize_and_move;
    g_wgui_cat200_draw_information_bar_func = wgui_inputs_sl_redraw_information_bar;

    /* Title,shortcut and Softkey */
    dm_add_title((UI_string_type)get_string(title), (PU8)get_image(title_icon));
    wgui_title_set_menu_shortcut_number(-1);
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    
    dm_add_softkey(
        (UI_string_type)get_string(left_softkey), 
        (PU8)get_image(left_softkey_icon), 
        (UI_string_type)get_string(right_softkey), 
        (PU8)get_image(right_softkey_icon));
    
    if (info_message != NULL)
    {
        /* Scroll Text */
        dm_add_scroll_text(
            (UI_string_type)info_message, 
            NULL, 
            DrawCate384CategoryControlAreaBackground, 
            *current_MMI_theme->list_normal_text_color,
            *current_MMI_theme->list_normal_text_color);
        scroll_height = CAT202_SCROLL_HEIGHT;
    }

    /* Dynamic list */
    wgui_dynamic_list_create_icontext_menu(
        number_of_items,
        get_item_func,
        get_hint_func,
        WGUI_LIST_INVALID_HIGHLIGHT,
        MMI_FALSE,
        UI_dummy_function,
#if !defined(GUI_EDITOR_SHOW_TITLE)
        WGUI_LIST_MENU_DISABLE_SHORTCUT,
#else
        0,
#endif
        0,
        NULL);

#ifdef __MMI_TOUCH_SCREEN__
    /* Because the list menu is resized according to virtual keyboard */
    MMI_fixed_list_menu.flags |= UI_LIST_MENU_ALIGN_TO_TOP;
#endif /* __MMI_TOUCH_SCREEN__ */ 

    resize_fixed_list(
        MMI_content_width,
        MAIN_LCD_DEVICE_HEIGHT - CAT202_SCROLL_Y - CAT200_INPUTBOX_H - 2 - scroll_height - MMI_BUTTON_BAR_HEIGHT);

    input_box_y = MAIN_LCD_DEVICE_HEIGHT - MMI_BUTTON_BAR_HEIGHT - CAT200_INPUTBOX_H - 1;
    
    move_fixed_list(0, (CAT202_SCROLL_Y + scroll_height));
    resize_fixed_icontext_menuitems(0, MMI_MENUITEM_HEIGHT);
    set_fixed_icontext_positions(2*MMI_ICONTEXT_MENUITEM_HEIGHT + 3, 0, MMI_ICONTEXT_MENUITEM_HEIGHT + 2, 0);

    input_box_width = MMI_content_width - CAT200_INPUTBOX_X - CAT200_MARGIN_WIDTH - 1/* border */;
    input_box_x = CAT200_INPUTBOX_X;

    ExitCategoryFunction = ExitCategory200Screen;
    dm_setup_category_functions(dm_redraw_category_screen, GetCategory200History, GetCategory200HistorySize);   /* 102605 quick search history Calvin add */

    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND | DM_SHOW_VKPAD;
#if !defined(GUI_EDITOR_SHOW_TITLE)
    dm_data.s32flags |= DM_NO_TITLE;
#endif /* !defined(GUI_EDITOR_SHOW_TITLE) */        
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    if (info_message != NULL)
    {
        dm_data.s32CatId = MMI_CATEGORY202_ID;
    }
    else
    {
        dm_data.s32CatId = MMI_CATEGORY202_NOINFO_ID;
    }
    dm_setup_data(&dm_data);


    h_flag = set_list_menu_category_history(MMI_CATEGORY200_ID, history_buffer);
#ifdef __MMI_UI_HINTS_IN_MENUITEM__
    if (get_hint_func)
    {
        if (is_set_force_icon_on_highlight_only_in_menuitem())
        {
            wgui_show_icon_only_highlight_in_icontext_menuitem();
        }
        if (is_set_force_all_hints_in_menuitem())
        {
            wgui_enable_hints_in_icontext_menuitem();
        }
        else if (is_set_force_hints_on_highlight_in_menuitem())
        {
            wgui_enable_hint_highlight_in_icontext_menuitem();
        }
        else
        {
            wgui_enable_hint_highlight_in_icontext_menuitem();
        }

        if (h_flag)
        {
            set_dynamic_pop_up_descriptions(MMI_fixed_list_menu.highlighted_item);
        }
        else
        {
            set_dynamic_pop_up_descriptions(highlighted_item);
        }

    #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        gui_block_list_effect();
    #endif 
    }
#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 


    /* set check-box */
    wgui_menuitem_set_icontext_checkbox_position(1, 0);
    wgui_menuitem_register_icontext_checkbox_callback(set_state_func, get_state_func);


    if (h_flag)
    {
        S32 s = sizeof(list_menu_category_history);

        s = (s + 3) / 4;
        s *= 4;

        first_item = MMI_fixed_list_menu.first_displayed_item;
        last_item = MMI_fixed_list_menu.last_displayed_item;
        dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
        MMI_fixed_list_menu.first_displayed_item = first_item;
        MMI_fixed_list_menu.last_displayed_item = last_item;

        wgui_inputs_sl_disable_up_down_key_register(MMI_TRUE);
        wgui_setup_singleline_inputbox(
            input_box_x,
            (input_box_y),
            input_box_width,
            CAT200_INPUTBOX_H,
            buffer,
            buffer_max_length,
            MMI_CATEGORY200_ID,
            get_string(right_softkey),
            get_image(right_softkey_icon),
            IMM_INPUT_TYPE_QUICK_SEARCH,
            (U8*) (history_buffer + s),
            1);
        if (cat200_search_function)
        {
            S32 no_entries;

            no_entries = cat200_search_function((U8*) MMI_singleline_inputbox.text);
            load_dynamic_item_buffer(no_entries);
            refresh_search_list_change_list_ext(no_entries, MMI_fixed_list_menu.highlighted_item);
        }
    }
    else
    {
        dynamic_list_goto_item_no_redraw(highlighted_item);
        wgui_inputs_sl_disable_up_down_key_register(MMI_TRUE);
        wgui_setup_singleline_inputbox(
            input_box_x,
            (input_box_y),
            input_box_width,
            CAT200_INPUTBOX_H,
            buffer,
            buffer_max_length,
            MMI_CATEGORY200_ID,
            get_string(right_softkey),
            get_image(right_softkey_icon),
            IMM_INPUT_TYPE_QUICK_SEARCH,
            NULL,
            1);
    }

    gui_set_single_line_input_box_theme(&MMI_singleline_inputbox, &cat200_singleline_inputbox_theme);
    cat200_search_img = search_image;


    resize_dynamic_icontext_menuitems_to_list_width();

    if (h_flag)
    {
        set_dynamic_pop_up_descriptions(MMI_fixed_list_menu.highlighted_item);
    }
    else
    {
        set_dynamic_pop_up_descriptions(highlighted_item);
    }

    singleline_inputbox_input_callback();
    wgui_singleline_inputbox_LSK_label_icon = get_image(left_softkey_icon);
    wgui_singleline_inputbox_LSK_label_string = get_string(left_softkey);
    if (!h_flag)
    {
        if (number_of_items > 0)
        {
            set_left_softkey_label(wgui_singleline_inputbox_LSK_label_string);
            set_left_softkey_icon(wgui_singleline_inputbox_LSK_label_icon);
            redraw_left_softkey();
            register_left_softkey_handler();
            set_left_softkey_function(wgui_singleline_inputbox_LSK_function, KEY_EVENT_UP);
            set_left_softkey_function(UI_dummy_function, KEY_EVENT_DOWN);
        }
        else
        {
            set_left_softkey_label(NULL);
            set_left_softkey_icon(NULL);
            redraw_left_softkey();
            set_left_softkey_function(UI_dummy_function, KEY_EVENT_UP);
            set_left_softkey_function(UI_dummy_function, KEY_EVENT_DOWN);
        }
    }
    register_singleline_inputbox_input_callback(wgui_cat200_editor_change_callback);
    
    gdi_layer_unlock_frame_buffer();

    dm_register_category_controlled_callback(RedrawCategoryControlledArea202Screen);
    dm_register_vkpad_callback(cat202_virtual_keypad_callback);
#ifdef __MMI_TOUCH_SCREEN__
    wgui_register_category_screen_control_area_pen_handlers(
        Cate200CategoryControlAreaPenDownHandler,
        MMI_PEN_EVENT_DOWN);
    wgui_register_category_screen_control_area_pen_handlers(Cate200CategoryControlAreaPenUpHandler, MMI_PEN_EVENT_UP);
    wgui_register_category_screen_control_area_pen_handlers(
        Cate200CategoryControlAreaPenMoveHandler,
        MMI_PEN_EVENT_MOVE);
    wgui_register_category_screen_control_area_pen_handlers(
        Cate200CategoryControlAreaPenLongTapHandler,
        MMI_PEN_EVENT_LONG_TAP);
    wgui_register_category_screen_control_area_pen_handlers(
        Cate200CategoryControlAreaPenRepeatHandler,
        MMI_PEN_EVENT_REPEAT);
#endif /* __MMI_TOUCH_SCREEN__ */ 

#if defined(__MMI_VIRTUAL_KEYBOARD__)
    wgui_virtual_keyboard_register_hide_cursor_callback(wgui_cat_stop_pop_up_description_scroll);
    wgui_virtual_keyboard_register_blink_cursor_callback(wgui_cat_resume_pop_up_description_scroll);
#endif
    
    dm_redraw_category_screen();

}








#if defined ( __MMI_MAINLCD_240X320__) || defined (__MMI_MAINLCD_320X240__) || defined (__MMI_MAINLCD_240X400__) || defined ( __MMI_MAINLCD_320X480__)

#include "worldclock.h"

#ifdef __MMI_TOUCH_SCREEN__
typedef enum
{
    CAT230_TOUCH_NONE,
    CAT230_TOUCH_ON_LEFT_ARROW_UP,
    CAT230_TOUCH_ON_LEFT_ARROW_DOWN,
    CAT230_TOUCH_ON_RIGHT_ARROW_UP,
    CAT230_TOUCH_ON_RIGHT_ARROW_DOWN,
    CAT230_TOUCH_ON_INDEX_UP,
    CAT230_TOUCH_ON_INDEX_DOWN,
    CAT230_TOUCH_ON_PAINT_UP,
    CAT230_TOUCH_ON_PAINT_DOWN,
    CAT230_TOUCH_ON_PAINT_REPEAT,
    CAT230_TOUCH_ON_PAINT_MOVE,
    CAT230_TOUCH_ON_RSK
} CAT230_PEN_EVENTS;

S32 Cat230PenEvent = CAT230_TOUCH_NONE;
#endif /* __MMI_TOUCH_SCREEN__ */

MMI_BOOL Cat230LeftArrowPressed = MMI_FALSE;
MMI_BOOL Cat230RightArrowPressed = MMI_FALSE;
U8 *Cat230TitleString = NULL;
U8 *Cat230IndexInfoString[MAX_CAT230_INDEX];
U8 Cat230NumberofIndex = 0;
U8 Cat230HighlightedIndex = 0;
S32 Cat230Paint_y = 0;
S32 Cat230Paint_height = 0;
GDI_HANDLE Cat230PaintLayer = GDI_NULL_HANDLE;
MMI_BOOL Cat230FirstEnter = MMI_TRUE;

color Cat230Index_bg = {254, 164, 42, 255};
color Cat230Index_bg_highlight = {254, 210, 41, 255};
color Cat230Index_fg = {0, 0, 0, 255};
color Cat230Index_fg_highlight = {255, 255, 255, 255};


void (*Cat230AppLeftKeyHandler) (U8 index_num) = UI_dummy_function_byte;
void (*Cat230AppRightKeyHandler) (U8 index_num) = UI_dummy_function_byte;
void (*Cat230RedrawPaint) (void) = UI_dummy_function;
void (*Cat230GetPaintInfo) (void *paint_info) = NULL;

static void RedrawCategory230Screen(void);

static void Cat230RedrawPaint_WC(void);
FuncPtr Cat230RedrawPaintArray[CAT230_SCREEN_TYPE_MAX] = {    Cat230RedrawPaint_WC    };

#ifdef __MMI_TOUCH_SCREEN__
typedef void (*Cat230PaintPenEventFuncPtr) (S32 x, S32 y, S32 event_type);

void (*Cat230PaintPenEventHandler) (S32 x, S32 y, S32 event_type) = NULL;
void (*Cat230AppPaintPenEventHandler) (S32 x, S32 y, S32 event_type) = NULL;
static void Cat230PaintPenEventHandler_WC(S32 x, S32 y, S32 event_type);
Cat230PaintPenEventFuncPtr Cat230PaintPenEventHandlerArray[CAT230_SCREEN_TYPE_MAX] = {  Cat230PaintPenEventHandler_WC   };
#endif /* __MMI_TOUCH_SCREEN__ */ 


/*****************************************************************************
 * FUNCTION
 *  SetCat230IndexInfo
 * DESCRIPTION
 *  set category index info
 * PARAMETERS
 *  index_num       [IN]        Index to set info
 *  info_string     [IN]        Info string to set
 * RETURNS
 *  void
 *****************************************************************************/
void SetCat230IndexInfo(U8 index_num, U8* info_string)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(index_num < MAX_CAT230_INDEX);
    Cat230IndexInfoString[index_num] = info_string;
}

#ifdef __MMI_TOUCH_SCREEN__
/*****************************************************************************
 * FUNCTION
 *  RegisterCat230PaintPenEventHandler
 * DESCRIPTION
 *  register 230 category pen event handler
 * PARAMETERS
 *  AppPaintPenEventHandler     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void RegisterCat230PaintPenEventHandler(void (*AppPaintPenEventHandler) (S32 x, S32 y, S32 event_type))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    Cat230AppPaintPenEventHandler = AppPaintPenEventHandler;
}
#endif /* __MMI_TOUCH_SCREEN__ */ 


/*****************************************************************************
 * FUNCTION
 *  Cat230HandleKeyRight
 * DESCRIPTION
 *  Right arrow key handler of Cat230.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void Cat230HandleKeyRight(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(Cat230AppRightKeyHandler!=NULL);
    Cat230AppRightKeyHandler(Cat230HighlightedIndex);
    RedrawCategory230Screen();
}


/*****************************************************************************
 * FUNCTION
 *  Cat230HandleKeyLeft
 * DESCRIPTION
 *  Left arrow key handler of Cat230.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void Cat230HandleKeyLeft(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(Cat230AppLeftKeyHandler!=NULL);
    Cat230AppLeftKeyHandler(Cat230HighlightedIndex);
    RedrawCategory230Screen();
}


/*****************************************************************************
 * FUNCTION
 *  Cat230HandleKeyUp
 * DESCRIPTION
 *  Up arrow key handler of Cat230.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void Cat230HandleKeyUp(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (Cat230HighlightedIndex == 0)
    {
        Cat230HighlightedIndex = Cat230NumberofIndex - 1;
    }
    else
    {
        Cat230HighlightedIndex--;
    }
    RedrawCategory230Screen();
}


/*****************************************************************************
 * FUNCTION
 *  Cat230HandleKeyDown
 * DESCRIPTION
 *  Down arrow key handler of Cat230.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void Cat230HandleKeyDown(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (Cat230HighlightedIndex == Cat230NumberofIndex-1)
    {
        Cat230HighlightedIndex = 0;
    }
    else
    {
        Cat230HighlightedIndex++;
    }
    RedrawCategory230Screen();
}


/*****************************************************************************
 * FUNCTION
 *  Cat230HandleKeyRightDown
 * DESCRIPTION
 *  Right navigation key down handler of Cat230.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void Cat230HandleKeyRightDown(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    Cat230RightArrowPressed = MMI_TRUE;
    Cat230HandleKeyRight();
}


/*****************************************************************************
 * FUNCTION
 *  Cat230HandleKeyRightUp
 * DESCRIPTION
 *  Right navigation key up handler of Cat230.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void Cat230HandleKeyRightUp(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    Cat230RightArrowPressed = MMI_FALSE;
    RedrawCategory230Screen();
}


/*****************************************************************************
 * FUNCTION
 *  Cat230HandleKeyLeftDown
 * DESCRIPTION
 *  Left navigation key down handler of Cat230.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void Cat230HandleKeyLeftDown(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    Cat230LeftArrowPressed = MMI_TRUE;
    Cat230HandleKeyLeft();
}


/*****************************************************************************
 * FUNCTION
 *  Cat230HandleKeyLeftUp
 * DESCRIPTION
 *  Left navigation key up handler of Cat230.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void Cat230HandleKeyLeftUp(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    Cat230LeftArrowPressed = MMI_FALSE;
    RedrawCategory230Screen();
}


#ifdef __MMI_TOUCH_SCREEN__


/*****************************************************************************
 * FUNCTION
 *  Cat230PenDownHandler
 * DESCRIPTION
 *  category 230 pen down handler
 * PARAMETERS
 *  point       [IN]        Pen down position
 * RETURNS
 *  
 *****************************************************************************/
static MMI_BOOL Cat230PenDownHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_component_info_struct pos;
    U8 j;
    S32 iwidth, iheight;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined (__MMI_MAINLCD_320X240__)
    /* on index */
    pos.pos_x = 0;
    pos.pos_y = 0;
    pos.width = UI_device_width;
    pos.height = CAT230_INDEX_HEIGHT*Cat230NumberofIndex;
#elif defined (__MMI_MAINLCD_240X320__) || defined (__MMI_MAINLCD_240X400__) || defined ( __MMI_MAINLCD_320X480__)
    /* on index */
    pos.pos_x = 0;
    pos.pos_y = MMI_status_bar_height+CAT230_TITLE_HEIGHT;
    pos.width = UI_device_width;
    pos.height = CAT230_INDEX_HEIGHT*Cat230NumberofIndex;
#endif
    
    if (wgui_test_object_position(point, pos) == MMI_TRUE)  /* INDEX */
    {
        gui_measure_image(get_image(LEFT_ARROW_UP), &iwidth, &iheight);
        pos.width = iwidth;
        pos.height = iheight;
        
        /* on left arrow */
        for (j=0; j<Cat230NumberofIndex; j++)
        {
        #if defined (__MMI_MAINLCD_320X240__)
            pos.pos_x = CAT230_ARROW_OFFSET;
            pos.pos_y = CAT230_INDEX_HEIGHT*j + ((CAT230_INDEX_HEIGHT-iheight) >> 1) - 1;
        #elif defined (__MMI_MAINLCD_240X320__) || defined (__MMI_MAINLCD_240X400__) || defined ( __MMI_MAINLCD_320X480__)
            pos.pos_x = CAT230_ARROW_OFFSET;
            pos.pos_y = MMI_status_bar_height+CAT230_TITLE_HEIGHT+CAT230_INDEX_HEIGHT*j + ((CAT230_INDEX_HEIGHT-iheight) >> 1) - 1;
        #endif
            if (wgui_test_object_position(point, pos) == MMI_TRUE)  /* LEFT ARROW */
            {
                Cat230PenEvent = CAT230_TOUCH_ON_LEFT_ARROW_DOWN;
                Cat230HighlightedIndex = j;
                Cat230HandleKeyLeft();
                return MMI_TRUE;
            }
        }

        /* on right arrow */
        for (j=0; j<Cat230NumberofIndex; j++)
        {
        
        #if defined (__MMI_MAINLCD_320X240__)
            pos.pos_x = UI_device_width - iwidth - 1 - CAT230_ARROW_OFFSET;
            pos.pos_y = CAT230_INDEX_HEIGHT*j + ((CAT230_INDEX_HEIGHT-iheight) >> 1) - 1;
        #elif defined (__MMI_MAINLCD_240X320__) ||  defined (__MMI_MAINLCD_240X400__) || defined ( __MMI_MAINLCD_320X480__)
            pos.pos_x = UI_device_width - iwidth - 1 - CAT230_ARROW_OFFSET;
            pos.pos_y = MMI_status_bar_height+CAT230_TITLE_HEIGHT+CAT230_INDEX_HEIGHT*j + ((CAT230_INDEX_HEIGHT-iheight) >> 1) - 1;
        #endif
            if (wgui_test_object_position(point, pos) == MMI_TRUE)  /* RIGHT ARROW */
            {
                Cat230PenEvent = CAT230_TOUCH_ON_RIGHT_ARROW_DOWN;
                Cat230HighlightedIndex = j;
                Cat230HandleKeyRight();
                return MMI_TRUE;
            }
        }
#if defined (__MMI_MAINLCD_320X240__)
        Cat230HighlightedIndex = point.y / CAT230_INDEX_HEIGHT;
#elif defined (__MMI_MAINLCD_240X320__) ||  defined (__MMI_MAINLCD_240X400__) || defined ( __MMI_MAINLCD_320X480__)
        Cat230HighlightedIndex = ((point.y-(MMI_status_bar_height+CAT230_TITLE_HEIGHT)) / CAT230_INDEX_HEIGHT);
#endif
        Cat230PenEvent = CAT230_TOUCH_ON_INDEX_DOWN;
        RedrawCategory230Screen();
        return MMI_TRUE;
    }

    /* on paint */
    pos.pos_x = 0;
    pos.pos_y = Cat230Paint_y;
    pos.width = UI_device_width;
    pos.height = Cat230Paint_height;
    if (wgui_test_object_position(point, pos) == MMI_TRUE)  /* Paint */
    {
        Cat230PenEvent = CAT230_TOUCH_ON_PAINT_DOWN;
        Cat230PaintPenEventHandler(point.x, point.y, Cat230PenEvent);
        return MMI_TRUE;
    }
    
    Cat230PenEvent = CAT230_TOUCH_NONE;
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  Cat230PenUpHandler
 * DESCRIPTION
 *  pen up handler of category 230
 * PARAMETERS
 *  point       [IN]        Pen up position
 * RETURNS
 *  
 *****************************************************************************/
static MMI_BOOL Cat230PenUpHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_component_info_struct pos;
    S32 iwidth, iheight;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_measure_image(get_image(LEFT_ARROW_UP), &iwidth, &iheight);
    pos.width = iwidth;
    pos.height = iheight;
    /* left arrow */
    if (Cat230PenEvent == CAT230_TOUCH_ON_LEFT_ARROW_DOWN)
    {
    
    #if defined (__MMI_MAINLCD_320X240__)
        pos.pos_x = CAT230_ARROW_OFFSET;
        pos.pos_y = CAT230_INDEX_HEIGHT*Cat230HighlightedIndex+ ((CAT230_INDEX_HEIGHT-iheight) >> 1) - 1;
    #elif defined (__MMI_MAINLCD_240X320__) ||  defined (__MMI_MAINLCD_240X400__) || defined ( __MMI_MAINLCD_320X480__)
        pos.pos_x = CAT230_ARROW_OFFSET;
        pos.pos_y = MMI_status_bar_height+CAT230_TITLE_HEIGHT+CAT230_INDEX_HEIGHT*Cat230HighlightedIndex+ ((CAT230_INDEX_HEIGHT-iheight) >> 1) - 1;
    #endif

        if (wgui_test_object_position(point, pos) == MMI_TRUE)  /* LEFT ARROW */
        {
            Cat230PenEvent = CAT230_TOUCH_NONE;
            RedrawCategory230Screen();
            return MMI_TRUE;
        }
    }

    /* right arrow */
    if (Cat230PenEvent == CAT230_TOUCH_ON_RIGHT_ARROW_DOWN)
    {
    #if defined (__MMI_MAINLCD_320X240__)
        pos.pos_x = UI_device_width - iwidth - 1 - CAT230_ARROW_OFFSET;
        pos.pos_y = CAT230_INDEX_HEIGHT*Cat230HighlightedIndex + ((CAT230_INDEX_HEIGHT-iheight) >> 1) - 1;
    #elif defined (__MMI_MAINLCD_240X320__) ||  defined (__MMI_MAINLCD_240X400__) || defined ( __MMI_MAINLCD_320X480__)
        pos.pos_x = UI_device_width - iwidth - 1 - CAT230_ARROW_OFFSET;
        pos.pos_y = MMI_status_bar_height+CAT230_TITLE_HEIGHT+CAT230_INDEX_HEIGHT*Cat230HighlightedIndex + ((CAT230_INDEX_HEIGHT-iheight) >> 1) - 1;
    #endif
        if (wgui_test_object_position(point, pos) == MMI_TRUE)  /* RIGHT ARROW */
        {
            Cat230PenEvent = CAT230_TOUCH_NONE;
            RedrawCategory230Screen();
            return MMI_TRUE;
        }
    }
    
    Cat230PenEvent = CAT230_TOUCH_NONE;
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  Cat230PenRepeatHandler
 * DESCRIPTION
 *  pen repeat handler of category 230
 * PARAMETERS
 *  point       [IN]        Pen repeat position
 * RETURNS
 *  
 *****************************************************************************/
static MMI_BOOL Cat230PenRepeatHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* left arrow */
    if (Cat230PenEvent == CAT230_TOUCH_ON_LEFT_ARROW_DOWN)
    {
        Cat230HandleKeyLeft();
        return MMI_TRUE;
    }

    /* right arrow */
    if (Cat230PenEvent == CAT230_TOUCH_ON_RIGHT_ARROW_DOWN)
    {
        Cat230HandleKeyRight();
        return MMI_TRUE;
    }
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  Cat230PenMoveHandler
 * DESCRIPTION
 *  pen move handler of category 230
 * PARAMETERS
 *  point       [IN]        Pen move position
 * RETURNS
 *  
 *****************************************************************************/
static MMI_BOOL Cat230PenMoveHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_component_info_struct pos;
    U8 highlighted_index;
    S32 iwidth, iheight;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
#if defined (__MMI_MAINLCD_320X240__)
    /* on index */
    pos.pos_x = 0;
    pos.pos_y = 0;
    pos.width = UI_device_width;
    pos.height = CAT230_INDEX_HEIGHT*Cat230NumberofIndex;
#elif defined (__MMI_MAINLCD_240X320__) ||  defined (__MMI_MAINLCD_240X400__) || defined ( __MMI_MAINLCD_320X480__)
    /* on index */
    pos.pos_x = 0;
    pos.pos_y = MMI_status_bar_height+CAT230_TITLE_HEIGHT;
    pos.width = UI_device_width;
    pos.height = CAT230_INDEX_HEIGHT*Cat230NumberofIndex;
#endif
    if (wgui_test_object_position(point, pos) == MMI_TRUE)  /* INDEX */
    {
        gui_measure_image(get_image(LEFT_ARROW_UP), &iwidth, &iheight);
        pos.width = iwidth;
        pos.height = iheight;
        /* left arrow */
        if (Cat230PenEvent == CAT230_TOUCH_ON_LEFT_ARROW_DOWN ||
            Cat230PenEvent == CAT230_TOUCH_ON_LEFT_ARROW_UP)
        {
        
        #if defined (__MMI_MAINLCD_320X240__)
            pos.pos_x = CAT230_ARROW_OFFSET;
            pos.pos_y = CAT230_INDEX_HEIGHT*Cat230HighlightedIndex + ((CAT230_INDEX_HEIGHT-iheight) >> 1) - 1;
        #elif defined (__MMI_MAINLCD_240X320__) ||  defined (__MMI_MAINLCD_240X400__) || defined ( __MMI_MAINLCD_320X480__)
            pos.pos_x = CAT230_ARROW_OFFSET;
            pos.pos_y = MMI_status_bar_height+CAT230_TITLE_HEIGHT+CAT230_INDEX_HEIGHT*Cat230HighlightedIndex + ((CAT230_INDEX_HEIGHT-iheight) >> 1) - 1;
        #endif
            if (wgui_test_object_position(point, pos) == MMI_TRUE)  /* LEFT ARROW */
            {
                Cat230PenEvent = CAT230_TOUCH_ON_LEFT_ARROW_DOWN;
                return MMI_TRUE;
            }
            else
            {
                if (Cat230PenEvent == CAT230_TOUCH_ON_LEFT_ARROW_DOWN)
                {
                    Cat230PenEvent = CAT230_TOUCH_ON_LEFT_ARROW_UP;
                    RedrawCategory230Screen();
                }
                return MMI_TRUE;
            }
        }
        /* right arrow */
        if (Cat230PenEvent == CAT230_TOUCH_ON_RIGHT_ARROW_DOWN ||
            Cat230PenEvent == CAT230_TOUCH_ON_RIGHT_ARROW_UP)
        {
        
        #if defined (__MMI_MAINLCD_320X240__)
            pos.pos_x = UI_device_width - iwidth - 1 - CAT230_ARROW_OFFSET;
            pos.pos_y = CAT230_INDEX_HEIGHT*Cat230HighlightedIndex + ((CAT230_INDEX_HEIGHT-iheight) >> 1) - 1;
        #elif defined (__MMI_MAINLCD_240X320__) ||  defined (__MMI_MAINLCD_240X400__) || defined ( __MMI_MAINLCD_320X480__)
            pos.pos_x = UI_device_width - iwidth - 1 - CAT230_ARROW_OFFSET;
            pos.pos_y = MMI_status_bar_height+CAT230_TITLE_HEIGHT+CAT230_INDEX_HEIGHT*Cat230HighlightedIndex + ((CAT230_INDEX_HEIGHT-iheight) >> 1) - 1;
        #endif
            if (wgui_test_object_position(point, pos) == MMI_TRUE)  /* RIGHT ARROW */
            {
                Cat230PenEvent = CAT230_TOUCH_ON_RIGHT_ARROW_DOWN;
                return MMI_TRUE;
            }
            else
            {
                if (Cat230PenEvent == CAT230_TOUCH_ON_RIGHT_ARROW_DOWN)
                {
                    Cat230PenEvent = CAT230_TOUCH_ON_RIGHT_ARROW_UP;
                    RedrawCategory230Screen();
                }
                return MMI_TRUE;
            }
        }

        if (Cat230PenEvent == CAT230_TOUCH_ON_INDEX_DOWN ||
            Cat230PenEvent == CAT230_TOUCH_ON_INDEX_UP)
        {
        
        #if defined (__MMI_MAINLCD_320X240__)
            highlighted_index = point.y / CAT230_INDEX_HEIGHT;
        #elif defined (__MMI_MAINLCD_240X320__) ||  defined (__MMI_MAINLCD_240X400__) || defined ( __MMI_MAINLCD_320X480__)
            highlighted_index = ((point.y-(MMI_status_bar_height+CAT230_TITLE_HEIGHT)) / CAT230_INDEX_HEIGHT);
        #endif
        
        #if defined (__MMI_MAINLCD_320X240__)
            if (highlighted_index != Cat230HighlightedIndex &&
                point.y >= 0 &&
                highlighted_index <= Cat230NumberofIndex)
        #elif defined (__MMI_MAINLCD_240X320__) ||  defined (__MMI_MAINLCD_240X400__) || defined ( __MMI_MAINLCD_320X480__)
            if (highlighted_index != Cat230HighlightedIndex &&
                point.y >= (MMI_status_bar_height+CAT230_TITLE_HEIGHT) &&
                highlighted_index <= Cat230NumberofIndex)
        #endif
            {
                Cat230HighlightedIndex = highlighted_index;
                Cat230PenEvent = CAT230_TOUCH_ON_INDEX_DOWN;
                RedrawCategory230Screen();
            }
            return MMI_TRUE;
        }
    }
    else
    {
        if (Cat230PenEvent == CAT230_TOUCH_ON_LEFT_ARROW_DOWN)
        {
            Cat230PenEvent = CAT230_TOUCH_ON_LEFT_ARROW_UP;
            RedrawCategory230Screen();
        }
        else if (Cat230PenEvent == CAT230_TOUCH_ON_RIGHT_ARROW_DOWN)
        {
            Cat230PenEvent = CAT230_TOUCH_ON_RIGHT_ARROW_UP;
            RedrawCategory230Screen();
        }
    }

    /* on paint */
    pos.pos_x = 0;
    pos.pos_y = Cat230Paint_y;
    pos.width = UI_device_width;
    pos.height = Cat230Paint_height;
    if (wgui_test_object_position(point, pos) == MMI_TRUE)  /* Paint */
    {
        if (Cat230PenEvent == CAT230_TOUCH_ON_PAINT_DOWN ||
            Cat230PenEvent == CAT230_TOUCH_ON_PAINT_UP)
        {
            Cat230PenEvent = CAT230_TOUCH_ON_PAINT_DOWN;
            Cat230PaintPenEventHandler(point.x, point.y, Cat230PenEvent);
            return MMI_TRUE;
        }
    }

    if (Cat230PenEvent == CAT230_TOUCH_ON_INDEX_DOWN ||
        Cat230PenEvent == CAT230_TOUCH_ON_INDEX_UP)
    {
        Cat230PenEvent = CAT230_TOUCH_ON_INDEX_UP;
    }
    else if (Cat230PenEvent == CAT230_TOUCH_ON_PAINT_DOWN ||
        Cat230PenEvent == CAT230_TOUCH_ON_PAINT_UP)
    {
        Cat230PenEvent = CAT230_TOUCH_ON_PAINT_DOWN;
    }
    else
    {
        Cat230PenEvent = CAT230_TOUCH_NONE;
    }
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  Cat230PaintPenEventHandler_WC
 * DESCRIPTION
 *  pen event hanlder of category 230
 * PARAMETERS
 *  x               [IN]        X
 *  y               [IN]        Y
 *  event_type      [IN]        Event type
 * RETURNS
 *  void
 *****************************************************************************/
static void Cat230PaintPenEventHandler_WC(S32 x, S32 y, S32 event_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 relative_x, relative_y;
    wgui_component_info_struct pos;
    mmi_pen_point_struct point;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    point.x = x;
    point.y = y;

    
#if defined (__MMI_MAINLCD_320X240__)
    pos.pos_x = 0;
    pos.pos_y = Cat230Paint_y + CAT230_TIME_HEIGHT;
    pos.width = UI_device_width;
    pos.height = Cat230Paint_height-CAT230_TIME_HEIGHT;
#elif defined (__MMI_MAINLCD_240X320__) ||  defined (__MMI_MAINLCD_240X400__) || defined ( __MMI_MAINLCD_320X480__)
    pos.pos_x = 0;
    pos.pos_y = Cat230Paint_y + CAT230_TIME_HEIGHT;
    pos.width = UI_device_width;
    pos.height = Cat230Paint_height-CAT230_TIME_HEIGHT*2-CAT230_CITY_HEIGHT;
#endif

    if (wgui_test_object_position(point, pos) == MMI_TRUE)  /* Map */
    {
        relative_x = x;
        relative_y = y - Cat230Paint_y - CAT230_TIME_HEIGHT;
        Cat230AppPaintPenEventHandler(relative_x, relative_y, event_type);
        RedrawCategory230Screen();
    }
}
#endif /* __MMI_TOUCH_SCREEN__ */ 


/*****************************************************************************
 * FUNCTION
 *  ExitCategory230Screen
 * DESCRIPTION
 *  exit function of category230
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory230Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    reset_softkeys();
    Cat230TitleString = NULL;
    for (i=0; i<MAX_CAT230_INDEX; i++)
    {
        Cat230IndexInfoString[i] = NULL;
    }
    Cat230NumberofIndex = 0;
    Cat230HighlightedIndex = 0;
    Cat230FirstEnter = MMI_TRUE;

    Cat230AppLeftKeyHandler = UI_dummy_function_byte;
    Cat230AppRightKeyHandler = UI_dummy_function_byte;
    Cat230RedrawPaint = UI_dummy_function;
    Cat230GetPaintInfo = NULL;
#ifdef __MMI_TOUCH_SCREEN__
    Cat230PaintPenEventHandler = NULL;
    Cat230AppPaintPenEventHandler = NULL;
#endif /* __MMI_TOUCH_SCREEN__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory230HistorySize
 * DESCRIPTION
 *  Gets the history buffer size of category 230
 * PARAMETERS
 *  void
 * RETURNS
 *  size in U8s of the history buffer
 *****************************************************************************/
S32 GetCategory230HistorySize(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return 0;
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory230History
 * DESCRIPTION
 *  Gets the history buffer of category230
 * PARAMETERS
 *  history_buffer      [OUT]        Is the buffer into which the history data is stored
 * RETURNS
 *  return history buffer
 *****************************************************************************/
U8 *GetCategory230History(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return history_buffer;
}


/*****************************************************************************
 * FUNCTION
 *  Cat230DrawTitle
 * DESCRIPTION
 *  Category 230 redraw title
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void Cat230DrawTitle(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    color cblack = {0, 0, 0, 255};
    color cwhite = {255, 255, 255, 255};
    S32 width = 0;
    S32 height = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_reset_clip();
    gui_reset_text_clip();
    gui_lock_double_buffer();

#ifdef __MMI_MAINLCD_320X480__
    gui_set_font(&MMI_large_font);
#else
    gui_set_font(&MMI_default_font);
#endif
    gui_measure_string((UI_string_type)Cat230TitleString, &width, &height);
    gdi_draw_solid_rect(0, MMI_status_bar_height, UI_device_width-1, MMI_status_bar_height+CAT230_TITLE_HEIGHT-1, gdi_act_color_from_rgb(cblack.alpha, cblack.r, cblack.g, cblack.b));
    if (r2lMMIFlag)
    {
        gui_move_text_cursor(((UI_device_width - width) >> 1) + width, MMI_status_bar_height + ((CAT230_TITLE_HEIGHT-height)>>1));
    }
    else
    {
        gui_move_text_cursor((UI_device_width - width) >> 1, MMI_status_bar_height + ((CAT230_TITLE_HEIGHT-height)>>1));
    }
    gui_set_text_color(cwhite);
    gui_print_text((UI_string_type)Cat230TitleString);

    gui_unlock_double_buffer();
    gui_BLT_double_buffer(0, MMI_status_bar_height, UI_device_width-1, MMI_status_bar_height+CAT230_TITLE_HEIGHT-1);
}


/*****************************************************************************
 * FUNCTION
 *  Cat230DrawIndex
 * DESCRIPTION
 *  category 230 redraw index
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void Cat230DrawIndex(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 width, height, iwidth, iheight;
    color bg_color, text_color;
    U8 i;
    S32 vertical_gap;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_reset_clip();
    gui_reset_text_clip();
    gui_lock_double_buffer();
    
#if defined (__MMI_MAINLCD_240X320__) ||  defined (__MMI_MAINLCD_240X400__) || defined ( __MMI_MAINLCD_320X480__)
    vertical_gap = MMI_status_bar_height+CAT230_TITLE_HEIGHT;
#elif defined (__MMI_MAINLCD_320X240__)
    vertical_gap = 0;
#endif
    
    gui_set_font(&MMI_small_font);
    gui_measure_image(get_image(LEFT_ARROW_UP), &iwidth, &iheight);

    for (i=0; i<Cat230NumberofIndex; i++)
    {
        width = height = 0;
        if (i == Cat230HighlightedIndex)
        {
            bg_color = Cat230Index_bg_highlight;
            text_color = Cat230Index_fg_highlight;
        }
        else
        {
            bg_color = Cat230Index_bg;
            text_color = Cat230Index_fg;
        }
        
        /* draw background */
        gdi_draw_solid_rect(0, vertical_gap + CAT230_INDEX_HEIGHT * i, UI_device_width - 1, 
            vertical_gap + CAT230_INDEX_HEIGHT * (i + 1) - 1, 
            gdi_act_color_from_rgb(bg_color.alpha, bg_color.r, bg_color.g, bg_color.b));
        
        /* draw fg text */
        gui_measure_string((UI_string_type)Cat230IndexInfoString[i], &width, &height);
        
        if (r2lMMIFlag)
        {
            gui_move_text_cursor(((UI_device_width - width) >> 1) + width, 
                vertical_gap + CAT230_INDEX_HEIGHT * i + ((CAT230_INDEX_HEIGHT - height) >> 1));
        }
        else
        {
            gui_move_text_cursor((UI_device_width - width) >> 1, 
                vertical_gap + CAT230_INDEX_HEIGHT * i + ((CAT230_INDEX_HEIGHT - height) >> 1));
        }
        gui_set_text_color(text_color);
        gui_print_text((UI_string_type)Cat230IndexInfoString[i]);

        /* draw left arrow */
    #ifdef __MMI_TOUCH_SCREEN__
        if (Cat230PenEvent == CAT230_TOUCH_ON_LEFT_ARROW_DOWN && i == Cat230HighlightedIndex)
        {
            gui_show_transparent_image(
                CAT230_ARROW_OFFSET,
                vertical_gap + CAT230_INDEX_HEIGHT * i + ((CAT230_INDEX_HEIGHT - iheight) >> 1),
                get_image(LEFT_ARROW_DOWN),
                0);
        }
        else
    #endif /* __MMI_TOUCH_SCREEN__ */ 
        {
            if (Cat230LeftArrowPressed && i == Cat230HighlightedIndex)
            {
                gui_show_transparent_image(
                    CAT230_ARROW_OFFSET,
                    vertical_gap + CAT230_INDEX_HEIGHT * i + ((CAT230_INDEX_HEIGHT - iheight) >> 1),
                    get_image(LEFT_ARROW_DOWN),
                    0);
            }
            else
            {
                gui_show_transparent_image(
                    CAT230_ARROW_OFFSET,
                    vertical_gap + CAT230_INDEX_HEIGHT * i + ((CAT230_INDEX_HEIGHT - iheight) >> 1),
                    get_image(LEFT_ARROW_UP),
                    0);
            }
        }            
    
        /* draw right arrow */
    #ifdef __MMI_TOUCH_SCREEN__
        if (Cat230PenEvent == CAT230_TOUCH_ON_RIGHT_ARROW_DOWN && i == Cat230HighlightedIndex)
        {
            gui_show_transparent_image(
                UI_device_width - iwidth - 1 - CAT230_ARROW_OFFSET,
                vertical_gap + CAT230_INDEX_HEIGHT * i + ((CAT230_INDEX_HEIGHT - iheight) >> 1),
                get_image(RIGHT_ARROW_DOWN),
                0);
        }
        else
    #endif /* __MMI_TOUCH_SCREEN__ */ 
        {
            if (Cat230RightArrowPressed && i == Cat230HighlightedIndex)
            {
                gui_show_transparent_image(
                    UI_device_width - iwidth - 1 - CAT230_ARROW_OFFSET,
                    vertical_gap + CAT230_INDEX_HEIGHT * i + ((CAT230_INDEX_HEIGHT - iheight) >> 1),
                    get_image(RIGHT_ARROW_DOWN),
                    0);
            }
            else
            {
                gui_show_transparent_image(
                    UI_device_width - iwidth - 1 - CAT230_ARROW_OFFSET,
                    vertical_gap + CAT230_INDEX_HEIGHT * i + ((CAT230_INDEX_HEIGHT - iheight) >> 1),
                    get_image(RIGHT_ARROW_UP),
                    0);
            }                
        }
    }

    gui_unlock_double_buffer();
    gui_BLT_double_buffer(0, vertical_gap, UI_device_width-1, Cat230Paint_y-1);
}

static void Cat230RedrawDynaTime(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 width = 0;
    S32 height = 0;
    S32 start_y = 0;
    cat230_paint_wc_info_struct wc_info;
    
    color dynamic_time_bg = {255, 113, 21, 255};
    color dynamic_time_fg = {0, 0, 0, 255};
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_ASSERT(Cat230GetPaintInfo!=NULL);
    Cat230GetPaintInfo((void *)(&wc_info));

    
    gui_set_font(&MMI_small_font);
 
    /* draw dynamic time */
    start_y = Cat230Paint_y;
    gui_measure_string((UI_string_type)wc_info.dynamic_string, &width, &height);
    gdi_draw_solid_rect(0, start_y, UI_device_width-1, start_y+CAT230_TIME_HEIGHT-1, gdi_act_color_from_rgb(dynamic_time_bg.alpha, dynamic_time_bg.r, dynamic_time_bg.g, dynamic_time_bg.b));
    if (r2lMMIFlag)
    {
        gui_move_text_cursor(((UI_device_width - width) >> 1) + width, start_y + ((CAT230_TIME_HEIGHT-height)>>1));
    }
    else
    {
        gui_move_text_cursor((UI_device_width - width) >> 1, start_y + ((CAT230_TIME_HEIGHT-height)>>1));
    }
    gui_set_text_color(dynamic_time_fg);
    gui_print_text((UI_string_type)wc_info.dynamic_string);

}

static void Cat230RedrawStaticTime(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 width = 0;
    S32 height = 0;
    S32 start_y = 0;
    cat230_paint_wc_info_struct wc_info;
    
    color static_time_bg = {82, 22, 48, 255};
    color static_time_fg = {255, 255, 255, 255};
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_ASSERT(Cat230GetPaintInfo!=NULL);
    Cat230GetPaintInfo((void *)(&wc_info));

    
    gui_set_font(&MMI_small_font);
 
     /* draw static time */
    start_y = UI_device_height-MMI_button_bar_height-CAT230_TIME_HEIGHT;
    gui_measure_string((UI_string_type)wc_info.static_string, &width, &height);
    gdi_draw_solid_rect(0, start_y, UI_device_width-1, start_y+CAT230_TIME_HEIGHT-1, gdi_act_color_from_rgb(static_time_bg.alpha, static_time_bg.r, static_time_bg.g, static_time_bg.b));
    if (r2lMMIFlag)
    {
        gui_move_text_cursor(((UI_device_width - width) >> 1) + width, start_y + ((CAT230_TIME_HEIGHT-height)>>1));
    }
    else
    {
        gui_move_text_cursor((UI_device_width - width) >> 1, start_y + ((CAT230_TIME_HEIGHT-height)>>1));
    }
    gui_set_text_color(static_time_fg);
    gui_print_text((UI_string_type)wc_info.static_string);

}

void Cat230UpdateTime(void)
{
    gui_lock_double_buffer();
    
    Cat230RedrawDynaTime();
    
#ifndef  __MMI_MAINLCD_320X240__
    Cat230RedrawStaticTime();
#endif
    
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(0, Cat230Paint_y, UI_device_width-1, Cat230Paint_y+Cat230Paint_height-1);
}

/*****************************************************************************
 * FUNCTION
 *  Cat230RedrawPaint_WC
 * DESCRIPTION
 *  redraw paint_wc
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void Cat230RedrawPaint_WC(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if defined(__MMI_MAINLCD_240X320__) ||  defined (__MMI_MAINLCD_240X400__) || defined ( __MMI_MAINLCD_320X480__)
    color city_bg = {0, 0, 0, 255};
    color city_fg = {255, 255, 255, 255};
    color hint_fg = {150, 150, 150, 255};
#endif /* defined(__MMI_MAINLCD_240X320__) */
    color dynamic_line = {255, 0, 0, 255};
    color static_line = {0, 0, 0, 255};
    S32 width = 0;
    S32 height = 0;
    
#if defined(__MMI_MAINLCD_240X320__) ||  defined (__MMI_MAINLCD_240X400__) || defined ( __MMI_MAINLCD_320X480__)
    S32 width1 = 0;
    S32 height1 = 0;
#endif /* defined(__MMI_MAINLCD_240X320__) */
    S32 start_y = 0;
    cat230_paint_wc_info_struct wc_info;
    S32 vertical_gap;

    MMI_ASSERT(Cat230GetPaintInfo!=NULL);
    Cat230GetPaintInfo((void *)(&wc_info));

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* 060706 NITZ category Calvin Start */
    if (!wc_info.need_redraw)
    {
        return;
    }
    /* 060706 NITZ category Calvin End */
    
    
#if defined (__MMI_MAINLCD_240X320__) ||  defined (__MMI_MAINLCD_240X400__) || defined ( __MMI_MAINLCD_320X480__)
    vertical_gap = MMI_status_bar_height;
#elif defined (__MMI_MAINLCD_320X240__)
    vertical_gap = 0;
#endif
    
    gui_reset_clip();
    gui_reset_text_clip();
    gui_lock_double_buffer();
    
    gui_set_font(&MMI_small_font);

    /* draw dynamic time */
    Cat230RedrawDynaTime();
    
#if defined(__MMI_MAINLCD_240X320__) ||  defined (__MMI_MAINLCD_240X400__) || defined ( __MMI_MAINLCD_320X480__)
    /* draw city */
    start_y = UI_device_height-MMI_button_bar_height-CAT230_TIME_HEIGHT-CAT230_CITY_HEIGHT;
    gui_measure_string((UI_string_type)wc_info.hint_string, &width, &height);
    gui_measure_string((UI_string_type)wc_info.city_string, &width1, &height1);
    gdi_draw_solid_rect(0, start_y, UI_device_width-1, start_y+CAT230_CITY_HEIGHT-1, gdi_act_color_from_rgb(city_bg.alpha, city_bg.r, city_bg.g, city_bg.b));
    if (r2lMMIFlag)
    {
        gui_move_text_cursor(((UI_device_width - (width+5+width1)) >> 1) + width+5+width1, start_y + ((CAT230_CITY_HEIGHT-height)>>1));
    }
    else
    {
        gui_move_text_cursor((UI_device_width - (width+5+width1)) >> 1, start_y + ((CAT230_CITY_HEIGHT-height)>>1));
    }
    gui_set_text_color(hint_fg);
    gui_print_text((UI_string_type)wc_info.hint_string);
    if (r2lMMIFlag)
    {
        gui_move_text_cursor(((UI_device_width - (width+5+width1)) >> 1) + width1, start_y + ((CAT230_CITY_HEIGHT-height1)>>1));
    }
    else
    {
        gui_move_text_cursor(((UI_device_width - (width+5+width1)) >> 1) + width+5, start_y + ((CAT230_CITY_HEIGHT-height1)>>1));
    }
    gui_set_text_color(city_fg);
    gui_print_text((UI_string_type)wc_info.city_string);
    
     /* draw static time */
     /*
    start_y = UI_device_height-MMI_button_bar_height-CAT230_TIME_HEIGHT;
    gui_measure_string((UI_string_type)wc_info.static_string, &width, &height);
    gdi_draw_solid_rect(0, start_y, UI_device_width-1, start_y+CAT230_TIME_HEIGHT-1, gdi_act_color_from_rgb(static_time_bg.alpha, static_time_bg.r, static_time_bg.g, static_time_bg.b));
    if (r2lMMIFlag)
    {
        gui_move_text_cursor(((UI_device_width - width) >> 1) + width, start_y + ((CAT230_TIME_HEIGHT-height)>>1));
    }
    else
    {
        gui_move_text_cursor((UI_device_width - width) >> 1, start_y + ((CAT230_TIME_HEIGHT-height)>>1));
    }
    gui_set_text_color(static_time_fg);
    gui_print_text((UI_string_type)wc_info.static_string);
    */ 

     Cat230RedrawStaticTime();

#endif /* defined(__MMI_MAINLCD_240X320__) */

    /* draw map */
    start_y = Cat230Paint_y + CAT230_TIME_HEIGHT;
    if (Cat230FirstEnter == MMI_TRUE)
    {
#if defined(__MMI_MAINLCD_240X320__) ||  defined (__MMI_MAINLCD_240X400__) || defined ( __MMI_MAINLCD_320X480__)
        dm_create_layer(0, start_y, UI_device_width, Cat230Paint_height-CAT230_TIME_HEIGHT*2-CAT230_CITY_HEIGHT, &Cat230PaintLayer, DM_LAYER_BOTTOM);
#elif defined(__MMI_MAINLCD_320X240__)
        dm_create_layer(0, start_y, UI_device_width, Cat230Paint_height-CAT230_TIME_HEIGHT, &Cat230PaintLayer, DM_LAYER_BOTTOM);
#endif
        gdi_layer_push_and_set_active(Cat230PaintLayer);
        gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
        gdi_layer_clear(GDI_COLOR_TRANSPARENT);
        gdi_layer_reset_clip();
        /* draw fix list backgroud */
        gdi_image_draw_id(0, 0, WORLD_CLOCK_IMAGE1);
        gdi_layer_pop_and_restore_active();
        Cat230FirstEnter = MMI_FALSE;
    }

    /* draw line indication */
    gdi_layer_push_clip();
#if defined(__MMI_MAINLCD_240X320__) ||  defined (__MMI_MAINLCD_240X400__) || defined ( __MMI_MAINLCD_320X480__)
    gdi_layer_set_clip(0, start_y, UI_device_width-1, UI_device_height-MMI_button_bar_height-CAT230_TIME_HEIGHT-CAT230_CITY_HEIGHT-1);
    gdi_draw_solid_rect(0, start_y, UI_device_width-1, UI_device_height-MMI_button_bar_height-CAT230_TIME_HEIGHT-CAT230_CITY_HEIGHT-1, GDI_COLOR_TRANSPARENT);
    gui_draw_vertical_line(start_y, UI_device_height-MMI_button_bar_height-CAT230_TIME_HEIGHT-CAT230_CITY_HEIGHT-1, wc_info.static_x, static_line);
    gui_draw_horizontal_line(0, UI_device_width-1, start_y+wc_info.static_y, static_line);
    gui_draw_vertical_line(start_y, UI_device_height-MMI_button_bar_height-CAT230_TIME_HEIGHT-CAT230_CITY_HEIGHT-1, wc_info.dynamic_x, dynamic_line);
    gui_draw_horizontal_line(0, UI_device_width-1, start_y+wc_info.dynamic_y, dynamic_line);
#elif defined(__MMI_MAINLCD_320X240__)
    gdi_layer_set_clip(0, start_y, UI_device_width-1, UI_device_height-MMI_button_bar_height-1);
    gdi_draw_solid_rect(0, start_y, UI_device_width-1, UI_device_height-MMI_button_bar_height-1, GDI_COLOR_TRANSPARENT);
    gui_draw_vertical_line(start_y, UI_device_height-MMI_button_bar_height - 1, wc_info.static_x, static_line);
    gui_draw_horizontal_line(0, UI_device_width-1, start_y+wc_info.static_y, static_line);
    gui_draw_vertical_line(start_y, UI_device_height-MMI_button_bar_height - 1, wc_info.dynamic_x, dynamic_line);
    gui_draw_horizontal_line(0, UI_device_width-1, start_y+wc_info.dynamic_y, dynamic_line);
#endif
    gdi_layer_pop_clip();

    gui_unlock_double_buffer();
    gui_BLT_double_buffer(0, Cat230Paint_y, UI_device_width-1, Cat230Paint_y+Cat230Paint_height-1);
    
}


/*****************************************************************************
 * FUNCTION
 *  RedrawCategory230Screen
 * DESCRIPTION
 *  redraw category 230
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void RedrawCategory230Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_MAINLCD_240X320__) ||  defined (__MMI_MAINLCD_240X400__) || defined ( __MMI_MAINLCD_320X480__)
    Cat230DrawTitle();
#endif
    Cat230DrawIndex();
    MMI_ASSERT(Cat230RedrawPaint!=NULL);
    Cat230RedrawPaint();
}


/*****************************************************************************
 * FUNCTION
 *  RedrawCategoryControlledArea230Screen
 * DESCRIPTION
 *  redraw category230 control area
 * PARAMETERS
 *  coordinate      [IN]     Area to redraw     
 * RETURNS
 *  void
 *****************************************************************************/
void RedrawCategoryControlledArea230Screen(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RedrawCategory230Screen();
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory230Screen
 * DESCRIPTION
 *  category screen of phone search
 * PARAMETERS
 *  title                   [IN]        Title string
 *  number_of_index         [IN]        Number of index
 *  index_info              [IN]        
 *  highlighted_index       [IN]        Highlighted index
 *  screen_type             [IN]        Screen type
 *  left_key_handler        [IN]        Function pointer to app right key handler
 *  right_key_handler       [IN]        
 *  get_paint_info          [IN]        Function pointer to get info of non-index area
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory230Screen(
        U8 *title,
        U8 number_of_index,
        U8 **index_info,
        U8 highlighted_index,
        U8 screen_type,
        void (*left_key_handler) (U8 index_num),
        void (*right_key_handler) (U8 index_num),
        void (*get_paint_info) (void *paint_info))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    U8 i;
    S32 vertical_gap;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined (__MMI_MAINLCD_240X320__) ||  defined (__MMI_MAINLCD_240X400__) || defined ( __MMI_MAINLCD_320X480__)
    vertical_gap = MMI_status_bar_height+CAT230_TITLE_HEIGHT;
#elif defined (__MMI_MAINLCD_320X240__)
    vertical_gap = 0;
#endif

    Cat230LeftArrowPressed = MMI_FALSE;
    Cat230RightArrowPressed = MMI_FALSE;
    Cat230TitleString = title;
    Cat230NumberofIndex = number_of_index;
    for(i=0; i<MAX_CAT230_INDEX; i++)
    {
        Cat230IndexInfoString[i] = index_info[i];
    }
    Cat230HighlightedIndex = highlighted_index;
    Cat230AppLeftKeyHandler = left_key_handler;
    Cat230AppRightKeyHandler = right_key_handler;
    Cat230RedrawPaint = Cat230RedrawPaintArray[screen_type];
#ifdef __MMI_TOUCH_SCREEN__
    Cat230PaintPenEventHandler = Cat230PaintPenEventHandlerArray[screen_type];
    Cat230PenEvent = CAT230_TOUCH_NONE;
#endif
    Cat230GetPaintInfo = get_paint_info;
    Cat230Paint_y = vertical_gap + CAT230_INDEX_HEIGHT*Cat230NumberofIndex;
    Cat230Paint_height = UI_device_height - Cat230Paint_y - MMI_button_bar_height;
   
    SetupCategoryKeyHandlers();
    ClearKeyEvents();    
    dm_register_category_controlled_callback(RedrawCategoryControlledArea230Screen);

    SetKeyHandler(Cat230HandleKeyLeftDown, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(Cat230HandleKeyLeftUp, KEY_LEFT_ARROW, KEY_EVENT_UP);    
    SetKeyHandler(Cat230HandleKeyLeftDown, KEY_LEFT_ARROW, KEY_LONG_PRESS);
    
    SetKeyHandler(Cat230HandleKeyRightDown, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(Cat230HandleKeyRightUp, KEY_RIGHT_ARROW, KEY_EVENT_UP);    
    SetKeyHandler(Cat230HandleKeyRightDown, KEY_RIGHT_ARROW, KEY_LONG_PRESS);
    
    SetKeyHandler(Cat230HandleKeyUp, KEY_UP_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(Cat230HandleKeyUp, KEY_UP_ARROW, KEY_LONG_PRESS);
    SetKeyHandler(Cat230HandleKeyDown, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(Cat230HandleKeyDown, KEY_DOWN_ARROW, KEY_LONG_PRESS);
    
#ifdef __MMI_TOUCH_SCREEN__
    wgui_register_category_screen_control_area_pen_handlers(Cat230PenDownHandler, MMI_PEN_EVENT_DOWN);
    wgui_register_category_screen_control_area_pen_handlers(Cat230PenUpHandler, MMI_PEN_EVENT_UP);
    wgui_register_category_screen_control_area_pen_handlers(Cat230PenRepeatHandler, MMI_PEN_EVENT_REPEAT);
    wgui_register_category_screen_control_area_pen_handlers(Cat230PenMoveHandler, MMI_PEN_EVENT_MOVE);
#endif /* __MMI_TOUCH_SCREEN__ */ 

    /* 060706 NITZ category Calvin Start */
    ExitCategoryFunction = ExitCategory230Screen;
    RedrawCategoryFunction = dm_redraw_category_screen;
    GetCategoryHistory = GetCategory230History;
    GetCategoryHistorySize = GetCategory230HistorySize;
    /* 060706 NITZ category Calvin End */
    dm_data.s32CatId = MMI_CATEGORY230_ID;
    dm_data.s32ScrId = GetActiveScreenId();
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}
#endif /* defined ( __MMI_MAINLCD_240X320__) */ 
/* 052206 NITZ category Calvin End */


#if defined ( __MMI_MAINLCD_128X128__) || defined ( __MMI_MAINLCD_128X160__) ||  defined (__MMI_MAINLCD_176X220__)

#ifdef __MMI_TOUCH_SCREEN__
typedef enum
{
    CAT231_TOUCH_NONE,
    CAT231_TOUCH_ON_LEFT_ARROW_UP,
    CAT231_TOUCH_ON_LEFT_ARROW_DOWN,
    CAT231_TOUCH_ON_RIGHT_ARROW_UP,
    CAT231_TOUCH_ON_RIGHT_ARROW_DOWN,
    CAT231_TOUCH_ON_MAP,
    CAT231_TOUCH_ON_MAX
} cat231_pen_event;
#endif /* __MMI_TOUCH_SCREEN__ */ 

void (*Cat231AppLeftKeyHandler) (void) = UI_dummy_function;
void (*Cat231AppRightKeyHandler) (void) = UI_dummy_function;
void (*Cat231GetPaintInfo) (void *paint_info) = NULL;
gdi_image_cache_bmp_struct Cat231VLine_buf;
gdi_image_cache_bmp_struct Cat231HLine_buf;
cat231_paint_wc_info_struct old_wc_info;
S32 Cat231_map_width, Cat231_map_height;
S32 Cat231_dt_y;
MMI_BOOL Cat231_show_status_icon = MMI_FALSE;
#ifdef __MMI_TOUCH_SCREEN__
void (*Cat231AppPaintPenEventHandler) (S32 x, S32 y) = NULL;
MMI_BOOL left_arrow_pressed = MMI_FALSE;
MMI_BOOL right_arrow_pressed = MMI_FALSE;
S32 left_x1, left_y1, left_width, left_height;
S32 right_x1, right_y1, right_width, right_height;
#endif

#define CAT231_V_LINE_CACHE_SIZE    ((UI_device_height * MMI_MAIN_BASE_LAYER_BITS_PER_PIXEL) >> 3)
#define CAT231_H_LINE_CACHE_SIZE    ((UI_device_width * MMI_MAIN_BASE_LAYER_BITS_PER_PIXEL) >> 3)
#define CAT231_DAY_IMAGE_GAP        10
#define CAT231_ARROW_GAP            5


#ifdef __MMI_TOUCH_SCREEN__
/*****************************************************************************
 * FUNCTION
 *  RegisterCat231PaintPenEventHandler
 * DESCRIPTION
 *  register 231 category pen event handler
 * PARAMETERS
 *  AppPaintPenEventHandler     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void RegisterCat231PaintPenEventHandler(void (*AppPaintPenEventHandler) (S32 x, S32 y))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    Cat231AppPaintPenEventHandler = AppPaintPenEventHandler;
}
#endif /* __MMI_TOUCH_SCREEN__ */ 


/*****************************************************************************
 * FUNCTION
 *  Cat231Redraw
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void    
 * RETURNS
 *  void
 *****************************************************************************/
void Cat231Redraw(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cat231_paint_wc_info_struct wc_info;
    S32 x1, y1, x2, y2;
    S32 text_x1, text_y1, width, height, iwidth, iheight, ix1, iy1;
    S32 dt_x1, dt_x2, dt_y1, dt_y2;
    color cwhite = {255, 255, 255, 100};
    color cred = {255, 0, 0, 100};
    color cblack = {0, 0, 0, 100};
    color cblue = {160, 205, 250, 100};
    S32 gap = CAT231_DAY_IMAGE_GAP;
    #ifdef __MMI_TOUCH_SCREEN__
    S32 igap = CAT231_ARROW_GAP;
    #endif
    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_DBG_ASSERT(Cat231GetPaintInfo!=NULL);
    Cat231GetPaintInfo((void *)(&wc_info));

    gdi_layer_lock_frame_buffer();

    /* draw title */
    x1 = 0;
    x2 = MMI_title_width - 1;
    if (Cat231_show_status_icon)
    {
        y1 = MMI_status_bar_height;
        y2 = y1 + MMI_title_height - 1;
    }
    else
    {
        y1 = 0;
        y2 = MMI_title_height - 1;
    }
    
    if (wc_info.title_string)
    {
        gui_measure_string((UI_string_type)wc_info.title_string, &width, &height);
        text_x1 = x1 + ((x2 - x1 + 1 - width) >> 1) + (r2lMMIFlag ? width : 0);
        text_y1 = y1 + ((y2 - y1 + 1 - height) >> 1);
        
        gdi_layer_push_clip();
        gdi_layer_set_clip(x1, y1, x2, y2);
        gdi_draw_solid_rect(x1, y1, x2, y2,GDI_COLOR_BLACK);
        gdi_layer_pop_clip();
    
        gui_set_text_color(cwhite);
        gui_set_font(&MMI_medium_font);
        gui_move_text_cursor(text_x1, text_y1);
        gui_print_text((UI_string_type)wc_info.title_string);
        old_wc_info.title_string = wc_info.title_string;
    }

#ifdef __MMI_TOUCH_SCREEN__
    if (left_arrow_pressed)
    {
        ix1 = x1 + igap;
        gui_measure_image((PU8)GetImage(WORLD_CLOCK_LEFT_ARROW_DOWN), &iwidth, &iheight);
        iy1 = y1 + ((y2 - y1 + 1 - iheight) >> 1);
        gui_show_image(ix1, iy1, (PU8)GetImage(WORLD_CLOCK_LEFT_ARROW_DOWN));
    }
    else
    {
        ix1 = x1 + igap;
        gui_measure_image((PU8)GetImage(WORLD_CLOCK_LEFT_ARROW_UP), &iwidth, &iheight);
        iy1 = y1 + ((y2 - y1 + 1 - iheight) >> 1);
        gui_show_image(ix1, iy1, (PU8)GetImage(WORLD_CLOCK_LEFT_ARROW_UP));
    }
    left_x1 = ix1;
    left_y1 = iy1;
    left_width = iwidth;
    left_height = iheight;
    
    if (right_arrow_pressed)
    {
        gui_measure_image((PU8)GetImage(WORLD_CLOCK_RIGHT_ARROW_DOWN), &iwidth, &iheight);
        ix1 = x2 - igap - iwidth;
        iy1 = y1 + ((y2 - y1 + 1 - iheight) >> 1);
        gui_show_image(ix1, iy1, (PU8)GetImage(WORLD_CLOCK_RIGHT_ARROW_DOWN));
    }
    else
    {
        gui_measure_image((PU8)GetImage(WORLD_CLOCK_RIGHT_ARROW_UP), &iwidth, &iheight);
        ix1 = x2 - igap - iwidth;
        iy1 = y1 + ((y2 - y1 + 1 - iheight) >> 1);
        gui_show_image(ix1, iy1, (PU8)GetImage(WORLD_CLOCK_RIGHT_ARROW_UP));
    }
    right_x1 = ix1;
    right_y1 = iy1;
    right_width = iwidth;
    right_height = iheight;
#endif /* __MMI_TOUCH_SCREEN__ */    


    /* draw map */
    y1 = y2 + 1;
    gui_measure_image(get_image(wc_info.curMap), &width, &height);
    y2 = y1 + height - 1;
    Cat231_map_width = x2 - x1 + 1;
    Cat231_map_height = y2 - y1 + 1;

    if (wc_info.curMap != old_wc_info.curMap)
    {
        gdi_layer_push_clip();
        gdi_layer_set_clip(x1, y1, x2, y2);
        gui_show_image(x1, y1, get_image(wc_info.curMap));
        gdi_layer_pop_clip();
        old_wc_info.curMap = wc_info.curMap;

        old_wc_info.x = -1;
        old_wc_info.y = -1;
    }


    /* draw 2 lines */
    if (wc_info.x != old_wc_info.x || wc_info.y != old_wc_info.y)
    {
        if (old_wc_info.x != -1 && old_wc_info.y != -1)
        {
            gdi_image_cache_bmp_draw(x1, y1 + old_wc_info.y, &Cat231HLine_buf);
            gdi_image_cache_bmp_draw(x1 + old_wc_info.x, y1, &Cat231VLine_buf);        
        }
    
        gdi_image_cache_bmp_get(x1 + wc_info.x, y1, x1 + wc_info.x, y2, &Cat231VLine_buf);
        gdi_image_cache_bmp_get(x1, y1 + wc_info.y, x2, y1 + wc_info.y, &Cat231HLine_buf);
        
        gui_draw_vertical_line(y1, y2, x1 + wc_info.x, cred);
        gui_draw_horizontal_line(x1, x2, y1 + wc_info.y, cred);

        old_wc_info.x = wc_info.x;
        old_wc_info.y = wc_info.y;
    }

    /* draw date time */
    y1 = y2;
    y2 = UI_device_height - MMI_softkey_height;
    Cat231_dt_y = y1;

    gdi_layer_push_clip();
    gdi_layer_set_clip(x1, y1, x2, y2);
    gui_fill_rectangle(x1, y1, x2, y2 - 1, cblue);
    gdi_layer_pop_clip();
    
    dt_x1 = x1;
    dt_x2 = x2;
    dt_y1 = y1;
    dt_y2 = y1 + ((y2 - y1) >> 1);
    gui_set_text_color(cblack);
    if (wc_info.date_string)
    {
        gui_measure_string((UI_string_type)wc_info.date_string, &width, &height);
        text_x1 = dt_x1 + ((dt_x2 - dt_x1 + 1 - width) >> 1) + (r2lMMIFlag ? width : 0);
        text_y1 = dt_y1 + ((dt_y2 - dt_y1 + 1 - height) >> 1);
    
        gui_move_text_cursor(text_x1, text_y1);
        gui_print_text((UI_string_type)wc_info.date_string);
    }
    
    dt_y1 = dt_y2;
    dt_y2 = y2;
    
    if (wc_info.time_string)
    {
        gui_measure_string((UI_string_type)wc_info.time_string, &width, &height);
        gui_measure_image((PU8)GetImage(wc_info.day_image), &iwidth, &iheight);
    
        text_x1 = dt_x1 + ((dt_x2 - dt_x1 + 1 - width - iwidth - gap) >> 1) + (r2lMMIFlag ? width : 0);
        text_y1 = dt_y1 + ((dt_y2 - dt_y1 + 1 - height) >> 1);
    
        gui_move_text_cursor(text_x1, text_y1);
        gui_print_text((UI_string_type)wc_info.time_string);
    
        ix1 = text_x1 + (r2lMMIFlag ? 0 : width) + gap;
        iy1 = text_y1;
        if (iy1 + iheight > dt_y2)
        {
            iy1 = dt_y2 - iheight;
        }
        gui_show_image(ix1, iy1, (PU8)GetImage(wc_info.day_image));
    }

    gdi_layer_unlock_frame_buffer();
}


/*****************************************************************************
 * FUNCTION
 *  Cat231UpdateDT
 * DESCRIPTION
 *  
 * PARAMETERS
 *      
 * RETURNS
 *  void
 *****************************************************************************/
void Cat231UpdateDT(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cat231_paint_wc_info_struct wc_info;
    S32 x1, y1, x2, y2;
    S32 text_x1, text_y1, width, height, iwidth, iheight, ix1, iy1;
    S32 dt_x1, dt_x2, dt_y1, dt_y2;
    color cblack = {0, 0, 0, 100};
    color cblue = {160, 205, 250, 100};
    S32 gap = CAT231_DAY_IMAGE_GAP;
    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_DBG_ASSERT(Cat231GetPaintInfo!=NULL);
    Cat231GetPaintInfo((void *)(&wc_info));

    gdi_layer_lock_frame_buffer();

    x1 = 0;
    x2 = MMI_title_width - 1;

    /* draw date time */
    y1 = Cat231_dt_y;
    y2 = UI_device_height - MMI_softkey_height;

    gdi_layer_push_clip();
    gdi_layer_set_clip(x1, y1, x2, y2);
    gui_fill_rectangle(x1, y1, x2, y2 - 1, cblue);
    gdi_layer_pop_clip();
    
    dt_x1 = x1;
    dt_x2 = x2;
    dt_y1 = y1;
    dt_y2 = y1 + ((y2 - y1) >> 1);
    gui_set_text_color(cblack);
    if (wc_info.date_string)
    {
        gui_measure_string((UI_string_type)wc_info.date_string, &width, &height);
        text_x1 = dt_x1 + ((dt_x2 - dt_x1 + 1 - width) >> 1) + (r2lMMIFlag ? width : 0);
        text_y1 = dt_y1 + ((dt_y2 - dt_y1 + 1 - height) >> 1);
    
        gui_move_text_cursor(text_x1, text_y1);
        gui_print_text((UI_string_type)wc_info.date_string);
    }
    
    dt_y1 = dt_y2;
    dt_y2 = y2;
    
    if (wc_info.time_string)
    {
        gui_measure_string((UI_string_type)wc_info.time_string, &width, &height);
        gui_measure_image((PU8)GetImage(wc_info.day_image), &iwidth, &iheight);
    
        text_x1 = dt_x1 + ((dt_x2 - dt_x1 + 1 - width - iwidth - gap) >> 1) + (r2lMMIFlag ? width : 0);
        text_y1 = dt_y1 + ((dt_y2 - dt_y1 + 1 - height) >> 1);
    
        gui_move_text_cursor(text_x1, text_y1);
        gui_print_text((UI_string_type)wc_info.time_string);
    
        ix1 = text_x1 + (r2lMMIFlag ? 0 : width) + gap;
        iy1 = text_y1;
        if (iy1 + iheight > dt_y2)
        {
            iy1 = dt_y2 - iheight;
        }
    
        gui_show_image(ix1, iy1, (PU8)GetImage(wc_info.day_image));
    }
    gdi_layer_unlock_frame_buffer();

    gdi_layer_blt_previous(x1, y1, x2, y2);
}


/*****************************************************************************
 * FUNCTION
 *  RedrawCategoryControlledArea231Screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *      
 * RETURNS
 *  void
 *****************************************************************************/
void RedrawCategoryControlledArea231Screen(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    Cat231Redraw();

}


/*****************************************************************************
 * FUNCTION
 *  Cat231HandleKeyLeft
 * DESCRIPTION
 *  
 * PARAMETERS
 *      
 * RETURNS
 *  void
 *****************************************************************************/
static void Cat231HandleKeyLeft(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_ASSERT(Cat231AppLeftKeyHandler != NULL);
    Cat231AppLeftKeyHandler();
    Cat231Redraw();
    
    gdi_layer_blt_previous(0, 0, UI_device_width-1, UI_device_height-1);
}


/*****************************************************************************
 * FUNCTION
 *  Cat231HandleKeyRight
 * DESCRIPTION
 *  
 * PARAMETERS
 *      
 * RETURNS
 *  void
 *****************************************************************************/
static void Cat231HandleKeyRight(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    MMI_ASSERT(Cat231AppRightKeyHandler != NULL);
    Cat231AppRightKeyHandler();
    Cat231Redraw();
    
    gdi_layer_blt_previous(0, 0, UI_device_width-1, UI_device_height-1);
}


#ifdef __MMI_TOUCH_SCREEN__
/*****************************************************************************
 * FUNCTION
 *  Cat231PenDownHandler
 * DESCRIPTION
 *  
 * PARAMETERS
 *      
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL Cat231PenDownHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;
    wgui_component_info_struct pos;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* on arrow */
    pos.pos_x = left_x1;
    pos.pos_y = left_y1;
    pos.width = left_width;
    pos.height = left_height;
    if (wgui_test_object_position(point, pos) == MMI_TRUE)  
    {
        left_arrow_pressed = MMI_TRUE;
        Cat231HandleKeyLeft();
        return MMI_TRUE;
    }
    
    pos.pos_x = right_x1;
    pos.pos_y = right_y1;
    pos.width = right_width;
    pos.height = right_height;
    if (wgui_test_object_position(point, pos) == MMI_TRUE)  
    {
        right_arrow_pressed = MMI_TRUE;
        Cat231HandleKeyRight();
        return MMI_TRUE;
    }
    
    /* on paint */
    pos.pos_x = 0;
    if (Cat231_show_status_icon)
    {
        pos.pos_y = MMI_title_height + MMI_status_bar_height;
    }
    else
    {
        pos.pos_y = MMI_title_height;
    }
    pos.width = Cat231_map_width;
    pos.height = Cat231_map_height;
    
    if (wgui_test_object_position(point, pos) == MMI_TRUE)  
    {
        Cat231AppPaintPenEventHandler(point.x, point.y);
        Cat231Redraw();
        gdi_layer_blt_previous(0, 0, UI_device_width-1, UI_device_height-1);
        return MMI_TRUE;
    }

    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  Cat231PenUpHandler
 * DESCRIPTION
 *  
 * PARAMETERS
 *      
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL Cat231PenUpHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;
    wgui_component_info_struct pos;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* on arrow */
    if (left_arrow_pressed)
    {
        pos.pos_x = left_x1;
        pos.pos_y = left_y1;
        pos.width = left_width;
        pos.height = left_height;
        if (wgui_test_object_position(point, pos) == MMI_TRUE)  
        {
            left_arrow_pressed = MMI_FALSE;
            Cat231Redraw();
            gdi_layer_blt_previous(0, 0, UI_device_width-1, UI_device_height-1);
            return MMI_TRUE;
        }
    }

    if (right_arrow_pressed)
    {
        pos.pos_x = right_x1;
        pos.pos_y = right_y1;
        pos.width = right_width;
        pos.height = right_height;
        if (wgui_test_object_position(point, pos) == MMI_TRUE)  
        {
            right_arrow_pressed = MMI_FALSE;
            Cat231Redraw();
            gdi_layer_blt_previous(0, 0, UI_device_width-1, UI_device_height-1);
            return MMI_TRUE;
        }
    }
    
    if (left_arrow_pressed)
    {
        left_arrow_pressed = MMI_FALSE;
    }
    
    if (right_arrow_pressed)
    {
        right_arrow_pressed = MMI_FALSE;
    }
    
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  Cat231PenRepeatHandler
 * DESCRIPTION
 *  
 * PARAMETERS
 *      
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL Cat231PenRepeatHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;
    wgui_component_info_struct pos;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* on arrow */
    pos.pos_x = left_x1;
    pos.pos_y = left_y1;
    pos.width = left_width;
    pos.height = left_height;
    if (wgui_test_object_position(point, pos) == MMI_TRUE)  
    {
        left_arrow_pressed = MMI_TRUE;
        Cat231HandleKeyLeft();
        return MMI_TRUE;
    }
    
    pos.pos_x = right_x1;
    pos.pos_y = right_y1;
    pos.width = right_width;
    pos.height = right_height;
    if (wgui_test_object_position(point, pos) == MMI_TRUE)  
    {
        right_arrow_pressed = MMI_TRUE;
        Cat231HandleKeyRight();
        return MMI_TRUE;
    }
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  Cat231PenMoveHandler
 * DESCRIPTION
 *  
 * PARAMETERS
 *      
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL Cat231PenMoveHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;
    wgui_component_info_struct pos;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* on arrow */
    if (left_arrow_pressed)
    {
        pos.pos_x = left_x1;
        pos.pos_y = left_y1;
        pos.width = left_width;
        pos.height = left_height;
        if (wgui_test_object_position(point, pos) != MMI_TRUE)  
        {
            left_arrow_pressed = MMI_FALSE;
            Cat231Redraw();
            gdi_layer_blt_previous(0, 0, UI_device_width-1, UI_device_height-1);
            return MMI_TRUE;
        }
    }

    if (right_arrow_pressed)
    {
        pos.pos_x = right_x1;
        pos.pos_y = right_y1;
        pos.width = right_width;
        pos.height = right_height;
        if (wgui_test_object_position(point, pos) != MMI_TRUE)  
        {
            right_arrow_pressed = MMI_FALSE;
            Cat231Redraw();
            gdi_layer_blt_previous(0, 0, UI_device_width-1, UI_device_height-1);
            return MMI_TRUE;
        }
    }
    
    /* on paint */
    pos.pos_x = 0;
    
    if (Cat231_show_status_icon)
    {
        pos.pos_y = MMI_title_height + MMI_status_bar_height;
    }
    else
    {
        pos.pos_y = MMI_title_height;
    }
    pos.width = Cat231_map_width;
    pos.height = Cat231_map_height;
    
    if (wgui_test_object_position(point, pos) == MMI_TRUE)  
    {
        Cat231AppPaintPenEventHandler(point.x, point.y);
        Cat231Redraw();
        gdi_layer_blt_previous(0, 0, UI_device_width-1, UI_device_height-1);
        return MMI_TRUE;
    }
    return ret;
}

#endif /* __MMI_TOUCH_SCREEN__ */


/*****************************************************************************
 * FUNCTION
 *  ExitCategory231Screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *      
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory231Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (Cat231VLine_buf.buf_ptr != NULL)
    {
        mmi_frm_scrmem_free(Cat231VLine_buf.buf_ptr);
        Cat231VLine_buf.buf_ptr = NULL;
    }

    if (Cat231HLine_buf.buf_ptr != NULL)
    {
        mmi_frm_scrmem_free(Cat231HLine_buf.buf_ptr);
        Cat231HLine_buf.buf_ptr = NULL;
    }
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory231History
 * DESCRIPTION
 *  
 * PARAMETERS
 *      
 * RETURNS
 *  
 *****************************************************************************/
U8 *GetCategory231History(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return history_buffer;
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory231HistorySize
 * DESCRIPTION
 *  
 * PARAMETERS
 *      
 * RETURNS
 *  
 *****************************************************************************/
S32 GetCategory231HistorySize(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return 0;
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory231Screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *      
 * RETURNS
 *  
 *****************************************************************************/
void ShowCategory231Screen(
        void (*left_key_handler) (void),
        void (*right_key_handler) (void),
        void (*get_paint_info) (void *paint_info),
        MMI_BOOL show_status_icons)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    Cat231AppLeftKeyHandler = left_key_handler;
    Cat231AppRightKeyHandler = right_key_handler;
    Cat231GetPaintInfo = get_paint_info;

    Cat231VLine_buf.buf_ptr= (U8*)mmi_frm_scrmem_alloc(CAT231_V_LINE_CACHE_SIZE);
    Cat231HLine_buf.buf_ptr = (U8*)mmi_frm_scrmem_alloc(CAT231_H_LINE_CACHE_SIZE);

    MMI_DBG_ASSERT(Cat231VLine_buf.buf_ptr);
    MMI_DBG_ASSERT(Cat231HLine_buf.buf_ptr);

    old_wc_info.curMap = 0;
    old_wc_info.date_string = NULL;
    old_wc_info.day_image = 0;
    old_wc_info.time_string = NULL;
    old_wc_info.title_string = NULL;
    old_wc_info.x = -1;
    old_wc_info.y = -1;

#ifdef __MMI_TOUCH_SCREEN__
    left_arrow_pressed = MMI_FALSE;
    right_arrow_pressed = MMI_FALSE;
#endif

    SetupCategoryKeyHandlers();
    dm_register_category_controlled_callback(RedrawCategoryControlledArea231Screen);

    SetKeyHandler(Cat231HandleKeyLeft, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(Cat231HandleKeyLeft, KEY_LEFT_ARROW, KEY_LONG_PRESS);
    SetKeyHandler(Cat231HandleKeyRight, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(Cat231HandleKeyRight, KEY_RIGHT_ARROW, KEY_LONG_PRESS);
    
#ifdef __MMI_TOUCH_SCREEN__
    wgui_register_category_screen_control_area_pen_handlers(Cat231PenDownHandler, MMI_PEN_EVENT_DOWN);
    wgui_register_category_screen_control_area_pen_handlers(Cat231PenUpHandler, MMI_PEN_EVENT_UP);
    wgui_register_category_screen_control_area_pen_handlers(Cat231PenRepeatHandler, MMI_PEN_EVENT_REPEAT);
    wgui_register_category_screen_control_area_pen_handlers(Cat231PenMoveHandler, MMI_PEN_EVENT_MOVE);
#endif /* __MMI_TOUCH_SCREEN__ */ 

    ExitCategoryFunction = ExitCategory231Screen;
    RedrawCategoryFunction = dm_redraw_category_screen;
    GetCategoryHistory = GetCategory231History;
    GetCategoryHistorySize = GetCategory231HistorySize;

    Cat231_show_status_icon = show_status_icons;

    if (Cat231_show_status_icon)
    {
        dm_data.s32CatId = MMI_CATEGORY232_ID;
    }
    else
    {
        dm_data.s32CatId = MMI_CATEGORY231_ID;
    }
    dm_data.s32ScrId = GetActiveScreenId();
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}



#endif /* defined ( __MMI_MAINLCD_128X128__) || defined ( __MMI_MAINLCD_128X160__) ||  defined (__MMI_MAINLCD_176X220__) */


/***************************************************************************
Function Name: EMS_matrix_highlight_handler
***************************************************************************/


/*****************************************************************************
 * FUNCTION
 *  EMS_matrix_highlight_handler
 * DESCRIPTION
 *  EMS screen matrix highlight handler
 * PARAMETERS
 *  item_index      [IN]        Highlighted index
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_matrix_highlight_handler(S32 item_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef __MMI_MAINLCD_128X128__
    extern color MMI_white_color;
#endif /* __MMI_MAINLCD_128X128__ */
    S32 new_text_length = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_title_set_menu_shortcut_number(item_index + 1);
    MMI_highlighted_item_text = get_item_text(item_index);

    gdi_layer_lock_frame_buffer();

#ifdef __MMI_MAINLCD_128X128__
    gui_fill_rectangle(
        MMI_singleline_inputbox.x,
        MMI_singleline_inputbox.y,
        MMI_singleline_inputbox.x + MMI_singleline_inputbox.width,
        MMI_singleline_inputbox.y + MMI_singleline_inputbox.height,
        MMI_white_color);
#else /* __MMI_MAINLCD_128X128__ */
    gdi_draw_solid_rect(
        MMI_singleline_inputbox.x,
        MMI_singleline_inputbox.y,
        MMI_singleline_inputbox.x + MMI_singleline_inputbox.width,
        MMI_singleline_inputbox.y + MMI_singleline_inputbox.height,
        GDI_COLOR_TRANSPARENT);
#endif /* __MMI_MAINLCD_128X128__ */
    
    new_text_length = gui_strlen((UI_string_type) MMI_highlighted_item_text);
    gui_create_single_line_input_box_set_buffer(
        &MMI_singleline_inputbox,
        MMI_singleline_inputbox.x,
        MMI_singleline_inputbox.y,
        MMI_singleline_inputbox.width,
        MMI_singleline_inputbox.height,
        MMI_highlighted_item_text,
        (new_text_length + 1) * 2,
        (new_text_length + 1) * 2,
        new_text_length);
    set_singleline_inputbox_mask(0);
    MMI_singleline_inputbox.flags |=
        (UI_SINGLE_LINE_INPUT_BOX_DISABLE_BACKGROUND | UI_SINGLE_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW |
         UI_SINGLE_LINE_INPUT_BOX_CENTER_JUSTIFY);
    gdi_layer_unlock_frame_buffer();

    redraw_singleline_inputbox();
    MMI_matrix_highlight_handler(item_index);

}

/***************************************************************************
Function Name: ShowCategoryEMSScreen
***************************************************************************/


/*****************************************************************************
 * FUNCTION
 *  ShowCategoryEMSScreen
 * DESCRIPTION
 *  show EMS category
 * PARAMETERS
 *  title                   [IN]        Title for the screen  
 *  title_icon              [IN]        Icon shown with the title  
 *  left_softkey            [IN]        Left softkey label  
 *  left_softkey_icon       [IN]        Icon for the Left softkey  
 *  right_softkey           [IN]        Right softkey label  
 *  right_softkey_icon      [IN]        Icon for the right softkey  
 *  num_of_symbols          [IN]        Number of symbols
 *  symbols                 [IN]        Symbols list
 *  descriptions            [IN]        Descriptions list
 *  highlighted_item        [IN]        Index of highlighted item
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategoryEMSScreen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        S32 num_of_symbols,
        MMI_ID_TYPE *symbols,
        MMI_ID_TYPE *descriptions,
        S32 highlighted_item,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 i, symbol_width = 0, symbol_height = 0, width = 0, height = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* disable list effect to keep the same behavior with category 22 */
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gui_block_list_effect();
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */
    
    gdi_layer_lock_frame_buffer();

    dm_add_softkey(get_string(left_softkey), get_image(left_softkey_icon), get_string(right_softkey), get_image(right_softkey_icon));
    dm_add_title(get_string(title), get_image(title_icon));

    wgui_fixed_matrix_create_menu(num_of_symbols, highlighted_item, WGUI_LIST_MENU_DISABLE_SHORTCUT, MMI_CATEGORY22_ID, history_buffer);
    MMI_current_menu_type = MATRIX_MENU_EMS;
    wgui_fixed_matrix_begin_add_one_item();
    for (i = 0; i < num_of_symbols; i++)
    {
        PU8 img = (PU8) get_image(symbols[i]);
        wgui_fixed_matrix_add_one_item(i, (U8*) get_string(descriptions[i]), img);
        gui_measure_image(img, &symbol_width, &symbol_height);
        if (symbol_width > width)
        {
            width = symbol_width;
        }
        if (symbol_height > height)
        {
            height = symbol_width;
        }
    }
    configure_fixed_matrix(width, height, 0, 0);
    wgui_fixed_matrix_end_add_one_item();
    
    MMI_fixed_matrix_menu.height =
        MMI_fixed_matrix_menu.n_rows * (MMI_fixed_matrix_menu.width / MMI_fixed_matrix_menu.n_columns);
    MMI_fixed_icontext_menuitem.flags |= UI_MENUITEM_FOCUSSED_ANIMATE | UI_MENUITEM_DISABLE_TEXT_DISPLAY | UI_MENUITEM_CENTER_ICON_X;

    wgui_fixed_matrix_override_highlight_handler(EMS_matrix_highlight_handler);
    MMI_fixed_matrix_menu.flags |= UI_MATRIX_MENU_LOOP;
   // h_flag = set_matrix_menu_category_history(MMI_CATEGORY22_ID, history_buffer);
    if (history_buffer)//(h_flag)
    {
        MMI_highlighted_item_text = get_item_text(MMI_fixed_matrix_menu.highlighted_item);
    }
    else
    {
        MMI_highlighted_item_text = get_item_text(highlighted_item);
    }    
    create_singleline_inputbox_set_buffer(
        (UI_string_type) MMI_highlighted_item_text,
        gui_strlen((UI_string_type) MMI_highlighted_item_text) + 1,
        gui_strlen((UI_string_type) MMI_highlighted_item_text),
        gui_strlen((UI_string_type) MMI_highlighted_item_text));
    set_singleline_inputbox_mask(0);
    MMI_singleline_inputbox.flags |=
        (UI_SINGLE_LINE_INPUT_BOX_DISABLE_BACKGROUND | UI_SINGLE_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW |
         UI_SINGLE_LINE_INPUT_BOX_CENTER_JUSTIFY);

    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = ExitCategory22Screen;
    dm_setup_category_functions(dm_redraw_category_screen, dm_get_category_history, dm_get_category_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY_EMS_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory400History
 * DESCRIPTION
 *  Get category 400 history
 * PARAMETERS
 *  history_buffer     [OUT]        Is the buffer into which the history data is stored
 * RETURNS
 *  
 *****************************************************************************/
static U8 *GetCategory400History(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return history_buffer;
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory400HistorySize
 * DESCRIPTION
 *  Get category 400 history size
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
static S32 GetCategory400HistorySize(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return 0;
}

 
/* For detail description, please refer to wgui_categories.h */
void RedrawCategory400Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    color cb = gui_color(0, 0, 0);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    gdi_layer_push_clip();
    gdi_layer_set_clip(0, 0, UI_device_width - 1, UI_device_height - 1);
    clear_screen();
    show_title_status_icon();
    draw_title();
    gui_draw_rectangle(
        MMI_content_x,
        MMI_content_y,
        MMI_content_x + MMI_content_width - 1,
        MMI_content_y + MMI_content_height - 1,
        cb);
    show_softkey_background();
    show_left_softkey();
    show_right_softkey();
    gdi_layer_pop_clip();
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory400Screen
 * DESCRIPTION
 *  Exit category 400 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void ExitCategory400Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_title_disable_menu_shortcut_display(MMI_FALSE);
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategory400Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    gdi_layer_lock_frame_buffer();
    clear_category_screen_key_handlers();
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    clear_left_softkey();
    clear_right_softkey();
    register_left_softkey_handler();
    register_right_softkey_handler();
    register_default_hide_softkeys();
    MMI_title_string = (UI_string_type) get_string(title);
    MMI_title_icon = (PU8) get_image(title_icon);
    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = ExitCategory400Screen;
    RedrawCategoryFunction = RedrawCategory400Screen;
    GetCategoryHistory = GetCategory400History;
    GetCategoryHistorySize = GetCategory400HistorySize;
    RedrawCategory400Screen();
}

#if (defined(__MMI_SMART_MESSAGE_MO__) && !defined(__MMI_MESSAGES_EMS__)) || defined(__MMI_SMART_MESSAGE_MT__)


/*****************************************************************************
 * FUNCTION
 *  mmi_nsm2_category275_draw_tile
 * DESCRIPTION
 *  NSM2 category redraw title
 * PARAMETERS
 *  strID       [IN]        String ID
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_nsm2_category275_draw_tile(U32 strID)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 iwidth, iheight, character_height, tx, w, iwidth2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    /* ADDED FOR NSM PHASE-II */
    MMI_title_string = get_string((MMI_ID_TYPE) strID);

    gdi_layer_push_clip();
    if ((gOnFullScreen & MMI_IN_FULL_SCREEN) && !(gOnFullScreen & MMI_LEAVE_FULL_IDLE_SCREEN) &&
        !(gOnFullScreen & MMI_IN_NORMAL_SCREEN_WITHOUT_STATUSBAR))
    {
        gdi_layer_set_clip(0, 0, UI_device_width - 1, UI_device_height - 1);
    #if defined(__MMI_UI_DALMATIAN_EDITOR__) || defined(__MMI_UI_DALMATIAN_IDLESCREEN__)
        /* To show proper Title & title image display */
        ShowStatusIconsTitle();
        arrange_status_icons();
        show_status_icons();
        gdi_layer_set_clip(
            MMI_title_x,
            MMI_title_y,
            MMI_title_x + MMI_title_width - 1,
            MMI_title_y + MMI_title_height - 1);
        gui_draw_filled_area(
            MMI_title_x,
            MMI_title_y,
            MMI_title_x + MMI_title_width - 1,
            MMI_title_y + MMI_title_height - 1,
            current_UI_theme->window_title_theme->active_filler);

    #else /* defined(__MMI_UI_DALMATIAN_EDITOR__) || defined(__MMI_UI_DALMATIAN_IDLESCREEN__) */ 
        gdi_layer_set_clip(MMI_title_x, 0, MMI_title_x + MMI_title_width - 1, MMI_title_height - 1);
        gui_draw_filled_area(
            MMI_title_x,
            0,
            MMI_title_x + MMI_title_width - 1,
            MMI_title_height - 1,
            current_UI_theme->window_title_theme->active_filler);
    #endif /* defined(__MMI_UI_DALMATIAN_EDITOR__) || defined(__MMI_UI_DALMATIAN_IDLESCREEN__) */ 
    }
    else
    {
        gdi_layer_set_clip(0, MMI_title_y, UI_device_width - 1, MMI_title_y + MMI_title_height - 1);
    #if defined(__MMI_UI_DALMATIAN_EDITOR__) || defined(__MMI_UI_DALMATIAN_IDLESCREEN__)
        /* Draw title image. */
        gui_draw_filled_area(
            MMI_title_x,
            MMI_title_y,
            MMI_title_x + MMI_title_width - 1,
            MMI_title_y + MMI_title_height - 1,
            current_UI_theme->window_title_theme->active_filler);
    #else /* defined(__MMI_UI_DALMATIAN_EDITOR__) || defined(__MMI_UI_DALMATIAN_IDLESCREEN__) */ 
        gui_draw_filled_area(
            MMI_title_x,
            MMI_title_y,
            MMI_title_x + MMI_title_width - 1,
            MMI_title_y + MMI_title_height - 1,
            current_UI_theme->window_title_theme->active_filler);
    #endif /* defined(__MMI_UI_DALMATIAN_EDITOR__) || defined(__MMI_UI_DALMATIAN_IDLESCREEN__) */ 
    }
    if (MMI_title_icon != NULL)
    {
        gui_measure_image(MMI_title_icon, &iwidth, &iheight);
        /* MTK Elvis for R2L characters */
        if (!r2lMMIFlag)
        {
            gui_show_transparent_image(
                MMI_title_x + 1,
                MMI_title_y + ((MMI_title_height >> 1) - (iheight >> 1)),
                MMI_title_icon,
                gui_transparent_color(0, 0, 0));
            if ((iwidth == 0) || (iheight == 0))
            {
                tx = 2;
            }
            else
            {
                tx = iwidth + 3;
            }

        }
        else
        {
            gui_show_transparent_image(
                MMI_title_width - iwidth - 1,
                MMI_title_y + ((MMI_title_height >> 1) - (iheight >> 1)),
                MMI_title_icon,
                gui_transparent_color(0, 0, 0));
            if ((iwidth == 0) || (iheight == 0))
            {
                tx = MMI_title_width - 2;
            }
            else
            {
                tx = MMI_title_width - iwidth - 3;
            }

        }
        /* MTK end */
    }
    else
    {
        /* MTK Elvis for R2L characters */
        if (!r2lMMIFlag)
        {
            tx = 2;
        }
        else
        {
            tx = MMI_title_width - 2;
        }
        /* MTK end */
    }

    if (MMI_title_icon2 != NULL)
    {
        gui_measure_image(MMI_title_icon2, &iwidth2, &iheight);
        if (iwidth2 > 0 && iheight > 0)
        {
            gui_show_transparent_image(
                MMI_title_x + MMI_title_width - iwidth2 - 1 /* leave one pixel */ ,
                MMI_title_y + ((MMI_title_height >> 1) - (iheight >> 1)),
                MMI_title_icon2,
                gui_transparent_color(0, 0, 0));
        }
    }

    if (MMI_title_string != NULL)   /* Fix for long titles  */
    {
        /* MTK Elvis for R2L characters */
        S32 tw;

        if (!r2lMMIFlag)
        {
            tw = MMI_title_width - tx;
        }
        else
        {
            tw = tx;
        }
        /* MTK end */
        gui_set_font((UI_font_type)gui_font_get_type(GUI_FONT_SIZE_TITLE));
        gui_measure_string(MMI_title_string, &w, &character_height);
        w += 2; /* for bordered text display */
        gui_set_text_color(*current_MMI_theme->title_text_color);
        if ((gOnFullScreen & MMI_IN_FULL_SCREEN || gOnFullScreen & MMI_LEAVE_FULL_SCREEN) &&
            !(gOnFullScreen & MMI_LEAVE_FULL_IDLE_SCREEN))

    #if defined(__MMI_UI_DALMATIAN_EDITOR__) || defined(__MMI_UI_DALMATIAN_IDLESCREEN__)
            /* to move at right point */
            gui_move_text_cursor(MMI_title_x + tx, MMI_title_y + ((MMI_title_height >> 1) - (character_height >> 1)));

    #else /* defined(__MMI_UI_DALMATIAN_EDITOR__) || defined(__MMI_UI_DALMATIAN_IDLESCREEN__) */ 
            gui_move_text_cursor(MMI_title_x + tx, ((MMI_title_height >> 1) - (character_height >> 1)));

    #endif /* defined(__MMI_UI_DALMATIAN_EDITOR__) || defined(__MMI_UI_DALMATIAN_IDLESCREEN__) */ 
        else
        {
            gui_move_text_cursor(MMI_title_x + tx, MMI_title_y + ((MMI_title_height >> 1) - (character_height >> 1)));
        }
        if (MMI_title_icon2 && iwidth2 > 0 && iheight > 0)
        {
            tw -= (iwidth2 + 1 + 4);
            if (w < tw)
            {
                S32 _tx = tx;

                tx = tx + (tw >> 1) - (w >> 1);
                if (tx < _tx)
                {
                    tx = _tx;
                }
            }
        }
        else if (!wgui_title_is_disable_shortcut_display() && wgui_title_get_menu_shortcut_number() >= 0)
        {
            tw -= MMI_menu_shortcut_box.width;
            if (w < tw)
            {
                S32 _tx = tx;

                /* MTK Elvis for R2L characters */
                if (!r2lMMIFlag)
                {
                    tx = tx + (tw >> 1) - (w >> 1);
                    if (tx < _tx)
                    {
                        tx = _tx;
                    }
                }
                else
                {
                    tx = tx - ((tw >> 1) - (w >> 1));
                    if (tx > _tx)
                    {
                        tx = _tx;
                    }
                }
                /* MTK end */
            }
        }
        else
        {
            if (w < tw)
            {
                S32 _tx = tx;

                /* MTK Elvis for R2L characters */
                if (!r2lMMIFlag)
                {
                    tx = tx + (tw >> 1) - (w >> 1);
                    if (tx < _tx)
                    {
                        tx = _tx;
                    }
                }
                else
                {
                    tx = tx - ((tw >> 1) - (w >> 1));
                    if (tx > _tx)
                    {
                        tx = _tx;
                    }
                }
                /* MTK end */
            }
        }
    #if defined(__MMI_DEFAULT_THEME_3__) || defined(__MMI_DEFAULT_THEME_1__)
        gui_set_text_border_color(*current_MMI_theme->title_text_border_color);
        if ((gOnFullScreen & MMI_IN_FULL_SCREEN || gOnFullScreen & MMI_LEAVE_FULL_SCREEN) &&
            !(gOnFullScreen & MMI_LEAVE_FULL_IDLE_SCREEN))
    #if defined(__MMI_UI_DALMATIAN_EDITOR__) || defined(__MMI_UI_DALMATIAN_IDLESCREEN__)

            /* To print title text on title bar with title icon. */
            gui_print_truncated_borderd_text(
                MMI_title_x + tx,
                MMI_title_y + ((MMI_title_height >> 1) - (character_height >> 1)),
                tw,
                MMI_title_string);

    #else /* defined(__MMI_UI_DALMATIAN_EDITOR__) || defined(__MMI_UI_DALMATIAN_IDLESCREEN__) */ 
            gui_print_truncated_borderd_text(
                MMI_title_x + tx,
                ((MMI_title_height >> 1) - (character_height >> 1)),
                tw,
                MMI_title_string);
    #endif /* defined(__MMI_UI_DALMATIAN_EDITOR__) || defined(__MMI_UI_DALMATIAN_IDLESCREEN__) */ 
        else
        {
            gui_print_truncated_borderd_text(
                MMI_title_x + tx,
                MMI_title_y + ((MMI_title_height >> 1) - (character_height >> 1)),
                tw,
                MMI_title_string);
        }
    #else /* defined(__MMI_DEFAULT_THEME_3__) || defined(__MMI_DEFAULT_THEME_1__) */ 
        if ((gOnFullScreen & MMI_IN_FULL_SCREEN || gOnFullScreen & MMI_LEAVE_FULL_SCREEN) &&
            !(gOnFullScreen & MMI_LEAVE_FULL_IDLE_SCREEN))
        {
            gui_print_truncated_text(
                MMI_title_x + tx,
                ((MMI_title_height >> 1) - (character_height >> 1)),
                tw,
                MMI_title_string);
        }
        else
        {
            gui_print_truncated_text(
                MMI_title_x + tx,
                MMI_title_y + ((MMI_title_height >> 1) - (character_height >> 1)),
                tw,
                MMI_title_string);
        }
    #endif /* defined(__MMI_DEFAULT_THEME_3__) || defined(__MMI_DEFAULT_THEME_1__) */ 
    }
    gdi_layer_pop_clip();
    gdi_layer_unlock_frame_buffer();
    if (MMI_title_icon2 == NULL)
    {
        gui_hide_menu_shortcut();
        show_menu_shortcut();
    }
    if ((gOnFullScreen & MMI_IN_FULL_SCREEN || gOnFullScreen & MMI_LEAVE_FULL_SCREEN) &&
        !(gOnFullScreen & MMI_LEAVE_FULL_IDLE_SCREEN))
    {
        gdi_layer_blt_previous(MMI_title_x, 0, MMI_title_x + MMI_title_width - 1, MMI_title_height - 1);
    }
    else
    {
        gdi_layer_blt_previous(
            MMI_title_x,
            MMI_title_y,
            MMI_title_x + MMI_title_width - 1,
            MMI_title_y + MMI_title_height - 1);
    }
}

extern U8 gNSMBuffer[];


/*****************************************************************************
 * FUNCTION
 *  mmi_nsm2_category275_draw_inbox_header
 * DESCRIPTION
 *  redraw NSM2 category inbox header
 * PARAMETERS
 *  yy      [IN]        (not used)
 *  x1      [IN]        start  x
 *  y1      [IN]        start  y
 *  x2      [IN]        end  x
 *  y2      [IN]        end  y
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_nsm2_category275_draw_inbox_header(MMI_BOOL is_draw, S32 yy, S32 height, S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 pic_offset;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (is_draw == MMI_FALSE)
    {
        return ;
    }
    
    pic_offset = ((LCD_WIDTH - current_MMI_theme->scrollbar_size) >> 1) - 36;   /* To align nsm picture in centre */
    gui_show_image(x1 + pic_offset, y1 + MMI_multiline_inputbox.text_offset_y + 1, (U8*) gNSMBuffer);
}
#endif /* (defined(__MMI_SMART_MESSAGE_MO__) && !defined(__MMI_MESSAGES_EMS__)) || defined(__MMI_SMART_MESSAGE_MT__) */ 

#if (defined(__MMI_SMART_MESSAGE_MO__) && !defined(__MMI_MESSAGES_EMS__))
extern nsm_msg_struct g_nsm_msg_context;


/*****************************************************************************
 * FUNCTION
 *  mmi_nsm2_category275_draw_header
 * DESCRIPTION
 *  redraw NSM2 category 275 header
 * PARAMETERS
 *  identifier      [IN]        (not used)
 *  y_offset        [IN]        (not used)
 *  x1              [IN]        Area x1
 *  y1              [IN]        Area y1
 *  x2              [IN]        Area x2
 *  y2              [IN]        Area y2
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_nsm2_category275_draw_header(U32 identifier, S32 y_offset, S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 pic_offset;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(identifier);
    UI_UNUSED_PARAMETER(y_offset);

    pic_offset = ((LCD_WIDTH - current_MMI_theme->scrollbar_size) >> 1) - 36;
    gui_show_image(x1 + pic_offset, y1 + MMI_multiline_inputbox.text_offset_y + 1, (U8*) g_nsm_msg_context.picbuffer);
}

#endif /* (defined(__MMI_SMART_MESSAGE_MO__) && !defined(__MMI_MESSAGES_EMS__)) */ 


/*****************************************************************************
 * FUNCTION
 *  ShowCategory401Screen
 * DESCRIPTION
 *  show category 401 screen
 * PARAMETERS
 *  percentage      [IN]        Number of percentage
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory401Screen(U16 percentage)
{
#if (defined(_NAND_FLASH_BOOTING_) && defined(__MTK_TARGET__) && !defined(__MAUI_BASIC__) && !defined(__L1_STANDALONE__) && !defined(EMPTY_MMI))
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 bar_width = 0, bar_height = 0;
    S32 bar_x = 0, bar_y = 0;
    S32 fill_width = 0;
    S32 str_width = 0, str_height = 0;
    S32 str_x = 0, str_y = 0;
    U8 *bar_bg_image = nfb_progress_images[0];
    U16 digit[3], idx = 0;
    S32 digit_width[3];
    S32 digit_height[3];
    static U8 isInited = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* it is not necessary to display progress bar while power-on is due to abnormal reset or alarm */
    if ((BMT.PWRon == (kal_uint8)ABNRESET) || (BMT.PWRon == (kal_uint8)RTCPWRON))
    {
        return;
    }

    if (!isInited)
    {
        gdi_init();
        setup_UI_wrappers();
    }

    gdi_layer_lock_frame_buffer();
    gdi_layer_clear(GDI_COLOR_WHITE);
    gdi_layer_push_clip();
    gdi_layer_reset_clip();

    /* percentage images */

    /* decide which images are used */
    if (percentage == 100)
    {
        digit[2] = 1;
        digit[1] = 0;
        digit[0] = 0;
    }
    else if (percentage == 0)
    {
        digit[2] = 0;
        digit[1] = 0;
        digit[0] = 0;
    }
    else if (percentage > 0 && percentage < 100)
    {
        digit[2] = 0;
        digit[1] = percentage / 10;
        digit[0] = percentage - (digit[1] * 10);
    }
    else
    {
        MMI_ASSERT(percentage <= 100);
    }

    /* calculate digit image width and height */
    gdi_image_get_dimension(nfb_progress_images[11], &str_width, &str_height);

    for (idx = 2; idx > 0; idx--)
    {
        if (digit[idx] != 0 || digit[2] == 1)
        {
            gdi_image_get_dimension(nfb_progress_images[digit[idx] + 1], &digit_width[idx], &digit_height[idx]);
            str_width += digit_width[idx];
        }
    }
    gdi_image_get_dimension(nfb_progress_images[digit[0] + 1], &digit_width[0], &digit_height[0]);

    /* decide digit images position */
    str_x = (UI_device_width - str_width) >> 1;
    str_y = (UI_device_height >> 1) + 2;

    /* show the digit images */
    for (idx = 2; idx > 0; idx--)
    {
        if (digit[idx] != 0 || digit[2] == 1)
        {
            gdi_image_draw(str_x, str_y, nfb_progress_images[digit[idx] + 1]);
            str_x += digit_width[idx];
        }
    }
    gdi_image_draw(str_x, str_y, nfb_progress_images[digit[0] + 1]);
    str_x += digit_width[0];
    gdi_image_draw(str_x, str_y, nfb_progress_images[11]);

    /* Progress bar background image */
    gdi_image_get_dimension(bar_bg_image, &bar_width, &bar_height);
    bar_x = (UI_device_width - bar_width - 2 /* gap */ ) >> 1;
    bar_y = (UI_device_height >> 1) - bar_height;

    gdi_layer_set_clip(bar_x, bar_y, bar_x + bar_width - 1, bar_y + bar_height - 1);

    /* Progress bar fill area */
    fill_width = ((bar_width - (MMI_CAT401_X_OFFSET << 1)) * (S32) percentage) / 100;
    gdi_draw_solid_rect(
        bar_x + MMI_CAT401_X_OFFSET,
        bar_y,
        bar_x + MMI_CAT401_X_OFFSET + fill_width - 1,
        bar_y + bar_height - 1,
#if defined(__MMI_OP11_BOOTUP_PROGRESS_BAR_IN_OP_COLOR__)
/* under construction !*/
#else
        GDI_COLOR_RED);
#endif

    gdi_image_draw(bar_x, bar_y, bar_bg_image);

    gdi_layer_pop_clip();
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);

    if (!isInited)
    {
        isInited = 1;
        custom_cfg_gpio_set_level(GPIO_DEV_LED_MAINLCD, 5);
    }
#endif /* (defined(_NAND_FLASH_BOOTING_) && defined(__MTK_TARGET__) && !defined(__MAUI_BASIC__) && !defined(__L1_STANDALONE__) && !defined(EMPTY_MMI)) */ 
}


/* for category 201 */
static MMI_BOOL g_wgui_cat201_is_timer_started = MMI_FALSE;
BOOL(*g_wgui_cat201_check_language_changed) (U8 input_type) = NULL;
static MMI_BOOL g_wgui_cat201_highlight_from_history = MMI_FALSE;
static S32 g_wgui_cat201_number_of_entry_in_history = 0;

/*****************************************************************************
 * FUNCTION
 *  wgui_cat201_register_language_changed_indicator
 * DESCRIPTION
 *  register language changed indicator of category 201
 * PARAMETERS
 *  FuncPtr     [IN]        Function to register
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat201_register_language_changed_indicator(BOOL(*FuncPtr) (U8 input_type))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat201_check_language_changed = FuncPtr;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat201_set_right_softkey_function
 * DESCRIPTION
 *  set right softkey callback of multiline inputbox in category 201
 * PARAMETERS
 *  f       [IN]        Function pointer
 *  k       [IN]        Type of key event
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat201_set_right_softkey_function(void (*f) (void), MMI_key_event_type k)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(k);
    wgui_inputbox_RSK_function = f;
}


#if defined(__MMI_TOUCH_SCREEN__)
/*****************************************************************************
 * FUNCTION
 *  wgui_cat201_virtual_keypad_callback
 * DESCRIPTION
 *  virtual keypad callback
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat201_virtual_keypad_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_imc_redraw_screen_by_state();
}
#endif /* defined(__MMI_TOUCH_SCREEN__) */


/*****************************************************************************
 * FUNCTION
 *  wgui_cat201_redraw_search_list
 * DESCRIPTION
 *  refresh and draw search list
 * PARAMETERS
 *  no_entries      [IN]        Entries count
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat201_redraw_search_list(S32 no_entries)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 shortcut_width;
    S32 max_entries = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_fixed_list_menu.n_items = no_entries;
    MMI_fixed_list_menu.displayed_items = no_entries;

    if (wgui_check_application_present)
    {
        wgui_check_application_present(&max_entries);
    }

    shortcut_width = set_menu_item_count(max_entries) + 7;  /* number of element increases at the run time */
    resize_menu_shortcut_handler(shortcut_width, MMI_title_height);
    move_menu_shortcut_handler(UI_device_width - shortcut_width, MMI_title_y);

    if (g_wgui_cat201_highlight_from_history == MMI_TRUE && g_wgui_cat201_is_timer_started == MMI_TRUE)
    {
        dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
    }
    else
    {
        MMI_fixed_list_menu.highlighted_item = 0;   
        if (no_entries > 0)
        {
            dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
        }
        else
        {
            gui_fixed_icontext_menuitem_stop_scroll();
            gui_pop_up_description_stop_scroll();
            wgui_title_set_menu_shortcut_number(0);
            wgui_current_pop_up_description_index = -1;
        }
    }
    
#if defined(GUI_EDITOR_SHOW_TITLE)
    draw_title();
#endif
    show_dynamic_list();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat201_refresh_search_list
 * DESCRIPTION
 *  refresh category 201 search list
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat201_refresh_search_list(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 no_entries = 0;
    U8 *name = MMI_multiline_inputbox.text;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(cat200_search_function != NULL);

    if (g_wgui_cat201_highlight_from_history == MMI_TRUE && g_wgui_cat201_is_timer_started == MMI_TRUE)
    {
        /* when come back from history, list should contain same items as history and cannot search again */   
        /* If search again, search function will change list result and cause wrong result */
        no_entries = g_wgui_cat201_number_of_entry_in_history;   
    }
	else
	{
		/* not come back from history, search for right list */
		no_entries = cat200_search_function(name);
	}

    MMI_ASSERT(no_entries >= 0); /* return entry must >=0 or list will have problem */
    
    load_dynamic_item_buffer(no_entries);
    wgui_cat201_redraw_search_list(no_entries); /* show list */
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);

    g_wgui_cat201_highlight_from_history = MMI_FALSE;    
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat201_multiline_text_change
 * DESCRIPTION
 *  multiline input changed callback function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat201_multiline_text_change(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat201_is_timer_started) /* the first time must show dynamice list */
    {
   	   g_wgui_cat201_is_timer_started = MMI_FALSE;
       gdi_layer_lock_frame_buffer();
       wgui_cat201_refresh_search_list();
       gdi_layer_unlock_frame_buffer();
    }

    /* use timer to avoid changing list too frequently (search e-dictionary spends much time) */
    gui_cancel_timer(wgui_cat201_refresh_search_list);
    gui_start_timer(20, wgui_cat201_refresh_search_list);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat201_register_key_handler
 * DESCRIPTION
 *  register default key handle function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat201_register_key_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* when first word is highlighted, user should not be able to go to last item by pressing up arrow key. */
    if (MMI_fixed_list_menu.highlighted_item != 0 || MMI_fixed_list_menu.n_items == 0)
    {
        SetKeyHandler(dynamic_list_goto_previous_item, KEY_UP_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(dynamic_list_goto_previous_item, KEY_VOL_UP, KEY_EVENT_DOWN);
    }
    else
    {
        /* input method will register key event, disable here */
        SetKeyHandler(UI_dummy_function, KEY_UP_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(UI_dummy_function, KEY_VOL_UP, KEY_EVENT_DOWN);
    }
    SetKeyHandler(dynamic_list_goto_next_item, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(dynamic_list_goto_next_item, KEY_VOL_DOWN, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat201_redraw_controlled_area
 * DESCRIPTION
 *  redraw category201 control area
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat201_redraw_controlled_area(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    /* dynamic list */
    wgui_cat201_refresh_search_list();
    dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
    show_dynamic_list();

    /* multiline inputbox */
    wgui_inputs_ml_redraw_input_information_bar();
    wgui_inputs_ml_redraw();

    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory201Screen
 * DESCRIPTION
 *  exit function of category 201
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory201Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_cancel_timer(wgui_cat201_refresh_search_list);
    g_wgui_cat201_check_language_changed = NULL;
    g_wgui_cat201_is_timer_started = MMI_FALSE;

    ClearHighlightHandler();

    /* IMPORTANT: 
     *        wgui_close_inputbox() must execute before reset list component & reset softkey & reset search function.
     *        When close inputbox, IME will do something that need refresh list and redraw editor.
     *        For example, IME will confirm multitap and must redraw editor and refresh search list.
     *        If reseting list component and setting refresh function to be NULL is before close multiline inputbox,
     *        it will cause some problems.
     * wgui_close_inputbox() cannot be moved.
     */
    wgui_close_inputbox();
    
    reset_softkeys();
    reset_menu_shortcut_handler();
    reset_fixed_list();
    reset_dynamic_list();
    reset_pop_up_descriptions();
    wgui_reset_multiline_inputbox_register_up_down_key_funcptr();
    g_wgui_cat201_highlight_from_history = MMI_FALSE;    
    cat200_search_function = NULL;      
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory201HistorySize
 * DESCRIPTION
 *  Gets the history buffer size of category 201
 * PARAMETERS
 *  void
 * RETURNS
 *  size in U8 of the history buffer
 *****************************************************************************/
S32 GetCategory201HistorySize(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (((sizeof(list_menu_category_history) + 3) / 4) * 4 + sizeof(multiline_inputbox_category_history));
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory201History
 * DESCRIPTION
 *  Gets the history buffer of category 201
 * PARAMETERS
 *  history_buffer     [OUT]        Is the buffer into which the history data is stored
 * RETURNS
 *  return history buffer
 *****************************************************************************/
U8 *GetCategory201History(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 s;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    get_list_menu_category_history(MMI_CATEGORY201_ID, history_buffer);
    s = sizeof(list_menu_category_history);
    s = (s + 3) / 4;
    s *= 4;
    get_multiline_inputbox_category_history(MMI_CATEGORY201_ID, (U8*) (history_buffer + s));
    return (history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory201Screen
 * DESCRIPTION
 *  category screen of phone search
 * PARAMETERS
 *  title                       [IN]        Title id
 *  title_icon                  [IN]        Title icon
 *  left_softkey                [IN]        Left soft key label
 *  left_softkey_icon           [IN]        Left soft key icon
 *  right_softkey               [IN]        Right soft key label
 *  right_softkey_icon          [IN]        Right soft key icon
 *  number_of_items             [IN]        Number of items
 *  get_item_func               [IN]        Function to get item
 *  get_hint_func               [IN]        Function to get hint
 *  highlighted_item            [IN]        Highlighted item index
 *  search_image                [IN]        Seach image
 *  buffer                      [IN]        Buffer
 *  buffer_max_length           [IN]        Length
 *  input_type                  [IN]        Input type
 *  history_buffer              [IN]        Histpry buffer
 *  required_input_mode_set     [IN]        Input mode set
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory201Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        S32 number_of_items,
        GetItemFuncPtr get_item_func,
        GetHintFuncPtr get_hint_func,
        S32 highlighted_item,
        U16 search_image,
        U8 *buffer,
        S32 buffer_max_length,
        U32 input_type,
        U8 *history_buffer,
        mmi_imm_input_mode_enum *required_input_mode_set)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    U8 h_flag;
    BOOL languageChanged = FALSE;
    S32 iwidth, iheight, max_entries = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    
    g_wgui_cat201_is_timer_started = MMI_TRUE;

    dm_add_title(get_string(title), get_image(title_icon));
    dm_add_softkey(get_string(left_softkey), get_image(left_softkey_icon), get_string(right_softkey), get_image(right_softkey_icon));
    
    if (history_buffer)
    {
        if (mmi_imm_get_user_desired_input_mode() != IMM_INPUT_MODE_NONE)
        {
            languageChanged = g_wgui_cat201_check_language_changed((U8) mmi_imm_get_user_desired_input_mode());
        }
    }

    wgui_dynamic_list_create_icontext_menu(
        number_of_items,
        get_item_func,
        get_hint_func,
        WGUI_LIST_INVALID_HIGHLIGHT,
        MMI_FALSE,
        UI_dummy_function,
        0,
        0,
        NULL);

    /* because set menu as UI_LIST_MENU_DISABLE_SCROLLBAR, it should set focussed_without_sc_filler as default filler */
    MMI_fixed_icontext_menuitem.focussed_without_sc_filler = MMI_fixed_icontext_menuitem.focussed_filler;

    /* disable shortcut must after create dynamic list, because dynamic list default has shortcut */
		//wgui_set_disable_shortcut_display();
    wgui_title_set_no_icon_shct(MMI_FALSE);
    
    if (wgui_check_application_present)
    {
        wgui_check_application_present(&max_entries);
    }

    MMI_fixed_list_menu.flags |= UI_LIST_MENU_ALIGN_TO_TOP | UI_LIST_MENU_DISABLE_SCROLLBAR;

    h_flag = set_list_menu_category_history(MMI_CATEGORY201_ID, history_buffer);

    if (h_flag)
    {
        S32 s = sizeof(list_menu_category_history);
        
        g_wgui_cat201_highlight_from_history = MMI_TRUE;

        s = (s + 3) / 4;
        s *= 4;
        MMI_fixed_list_menu.item_measure_function(NULL, MMI_fixed_list_menu.common_item_data, &iwidth, &iheight);
        MMI_fixed_list_menu.height = iheight * MMI_fixed_list_menu.displayed_items + 10;        /* need to handle this in more cleaner way, it is 22X4 +10 =98, as we only show 4 rows */

        if (languageChanged)
        {
            MMI_fixed_list_menu.highlighted_item = 0;
        }
        
        dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
        wgui_setup_inputbox_ext(
            0,
            0,
            UI_device_width/* - temp_w*/,
            CAT201_EDITOR_HEIGHT,
            buffer,
            buffer_max_length,
            MMI_CATEGORY201_ID,
            get_string(right_softkey),
            get_image(right_softkey_icon),
            input_type,
            history_buffer + s,
            required_input_mode_set,
            1,
            UI_MULTI_LINE_INPUT_BOX_AUTO_DISABLE_SCROLLBAR,
            0,
            0,
            0,
            0,
            NULL);

        if (languageChanged)
        {
            multiline_inputbox_delete_all_characters();
            set_right_softkey_function(GoBackHistory, KEY_EVENT_UP);
        }
        
        g_wgui_cat201_number_of_entry_in_history = MMI_fixed_list_menu.n_items;        
    }
    else
    {
        g_wgui_cat201_highlight_from_history = MMI_FALSE;
        wgui_setup_inputbox_ext(
            0,
            0,
            UI_device_width/* - temp_w*/,
            CAT201_EDITOR_HEIGHT,
            buffer,
            buffer_max_length,
            MMI_CATEGORY201_ID,
            get_string(right_softkey),
            get_image(right_softkey_icon),
            input_type,
            NULL,
            required_input_mode_set,
            1,
            UI_MULTI_LINE_INPUT_BOX_AUTO_DISABLE_SCROLLBAR,
            0,
            0,
            0,
            0,
            NULL);
        dynamic_list_goto_item_no_redraw(highlighted_item);
    }

    /* multiline inputbox */
    MMI_multiline_inputbox.change_callback = wgui_cat201_multiline_text_change;
    wgui_set_multiline_inputbox_register_up_down_key_funcptr(wgui_cat201_register_key_handler);
     /* up and down keys are handled by list menu */
     /* can't remove */
    register_dynamic_list_keys();
    resize_dynamic_icontext_menuitems_to_list_width();
    if (h_flag)
    {
        set_dynamic_pop_up_descriptions(MMI_fixed_list_menu.highlighted_item);
        if (MMI_fixed_list_menu.highlighted_item <= 0)
        {
            ClearKeyHandler(KEY_UP_ARROW, KEY_EVENT_DOWN);
            ClearKeyHandler(KEY_VOL_UP, KEY_EVENT_DOWN);
        }
    }
    else
    {
        set_dynamic_pop_up_descriptions(highlighted_item);
    }
    wgui_singleline_inputbox_LSK_label_icon = get_image(left_softkey_icon);
    wgui_singleline_inputbox_LSK_label_string = get_string(left_softkey);

    gdi_layer_unlock_frame_buffer();
    
    ExitCategoryFunction = ExitCategory201Screen;
    dm_setup_category_functions(dm_redraw_category_screen, GetCategory201History, GetCategory201HistorySize);    
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY201_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
#if !defined(GUI_EDITOR_SHOW_TITLE)
    dm_data.s32flags |= DM_NO_TITLE;
#endif /* !defined(GUI_EDITOR_SHOW_TITLE) */  
#ifdef __MMI_TOUCH_SCREEN__
    dm_data.s32flags |= DM_SHOW_VKPAD;
    dm_register_vkpad_callback(wgui_cat201_virtual_keypad_callback);
#endif      
    dm_setup_data(&dm_data);

    dm_redraw_category_screen();
}


#ifdef __MMI_CAT103_SUPPORT__
static MMI_BOOL wgui_cat103_is_menu_active(void);

S32 (*g_wgui_cat103_search_function) (UI_buffer_type) = NULL;
static MMI_BOOL g_wgui_cat103_editor_active = MMI_FALSE;
static MMI_BOOL g_wgui_cat103_from_history = MMI_FALSE;
static void (*g_wgui_cat103_RSK_function) (void) = NULL;
void (*g_wgui_cat103_resize_and_draw_func) (S32) = NULL;
void (*g_wgui_cat103_highlight_handler) (S32) = NULL;
extern UI_string_type wgui_singleline_inputbox_RSK_label_string;
extern PU8 wgui_singleline_inputbox_RSK_label_icon;


/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_register_highlight_handler
 * DESCRIPTION
 *  register category103 highlight handler
 * PARAMETERS
 *  f      [IN]   highlight handler function
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat103_register_highlight_handler(void (*f) (S32))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat103_highlight_handler = f;
    RegisterHighlightHandler(f);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_set_right_softkey_function
 * DESCRIPTION
 *  set right softkey function of category103
 * PARAMETERS
 *  f      [IN]   RSK function
 *  k      [IN]   key event type
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat103_set_right_softkey_function(void (*f) (void), MMI_key_event_type k)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(k);
    wgui_singleline_inputbox_RSK_function = f;
    g_wgui_cat103_RSK_function = f;
}


#ifdef __MMI_TOUCH_SCREEN__
/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_virtual_keypad_callback
 * DESCRIPTION
 *  virtual keypad callback
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat103_virtual_keypad_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_imc_redraw_screen_by_state();    
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_controlled_area_pen_down_handler
 * DESCRIPTION
 *  pen down handler
 * PARAMETERS
 *  point            [IN]        pen postion
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat103_controlled_area_pen_down_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;
    gui_list_pen_enum menu_event;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_fixed_list_menu.pen_redraw_menu_function = wgui_dynamic_list_show_icontext_menu;
    gui_vertical_scrollbar_set_pen_self_scroll(&MMI_fixed_list_menu.vbar, MMI_TRUE);
    gui_fixed_list_menu_set_pen_scroll_delay(&MMI_fixed_list_menu, GUI_DYNAMIC_LIST_PEN_SCROLL_DELAY);

    ClearHighlightHandler();
    ret = gui_dynamic_list_menu_translate_pen_event(
            &MMI_fixed_list_menu,
            MMI_PEN_EVENT_DOWN,
            point.x,
            point.y,
            &menu_event);
    RegisterHighlightHandler(g_wgui_cat103_highlight_handler);
    if (ret)
    {
        if (menu_event == GUI_LIST_PEN_HIGHLIGHT_CHANGED 
            || menu_event == GUI_LIST_PEN_NEED_REDRAW 
            || wgui_cat103_is_editor_active() == MMI_TRUE)
        {
            wgui_cat103_set_menu_focus_state(MMI_TRUE);
            dynamic_list_highlight_handler(MMI_fixed_list_menu.highlighted_item);
            redraw_dynamic_list();
            wgui_cat103_set_editor_focus_state(MMI_FALSE);
            redraw_singleline_inputbox();
        }
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }    
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_controlled_area_pen_up_handler
 * DESCRIPTION
 *  pen up handler
 * PARAMETERS
 *  point            [IN]        pen postion
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat103_controlled_area_pen_up_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_general_pen_dynamic_list_menu_hdlr(point, MMI_PEN_EVENT_UP);
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_controlled_area_pen_move_handler
 * DESCRIPTION
 *  pen move handler
 * PARAMETERS
 *  point            [IN]        pen postion
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat103_controlled_area_pen_move_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_general_pen_dynamic_list_menu_hdlr(point, MMI_PEN_EVENT_MOVE);
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_controlled_area_pen_long_tap_handler
 * DESCRIPTION
 *  pen long tap handler
 * PARAMETERS
 *  point            [IN]        pen postion
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat103_controlled_area_pen_long_tap_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_general_pen_dynamic_list_menu_hdlr(point, MMI_PEN_EVENT_LONG_TAP);
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat203_controlled_area_pen_repeat_handler
 * DESCRIPTION
 *  pen repeat handler
 * PARAMETERS
 *  point            [IN]        pen postion
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/ 
MMI_BOOL wgui_cat103_controlled_area_pen_repeat_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_general_pen_dynamic_list_menu_hdlr(point, MMI_PEN_EVENT_REPEAT);
    return ret;
}
#endif /* __MMI_TOUCH_SCREEN__ */


/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_resize_and_draw
 * DESCRIPTION
 *  resize category103 component
 * PARAMETERS
 *  ime_h      [IN]   reserve height for ime
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat103_resize_and_draw(S32 ime_h)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 menu_h = 0, singleline_y = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* calculate menu height */
#ifdef MMI_SHOW_STATUS_ICON_IN_TITLE
    menu_h = UI_device_height - MMI_TITLE_HEIGHT - wgui_inputbox_information_bar_height - MMI_SINGLELINE_INPUTBOX_HEIGHT - ime_h - MMI_BUTTON_BAR_HEIGHT - 1;
#else
    menu_h = UI_device_height - MMI_STATUS_BAR_HEIGHT - MMI_TITLE_HEIGHT - wgui_inputbox_information_bar_height - MMI_SINGLELINE_INPUTBOX_HEIGHT - ime_h - MMI_BUTTON_BAR_HEIGHT - 1;
#endif /* MMI_SHOW_STATUS_ICON_IN_TITLE */

    //if (menu_h != MMI_fixed_list_menu.height)  /* resize */
    {
        gdi_layer_lock_frame_buffer();

        ClearHighlightHandler();  /* avoid execute highlight handler when redraw list */

        /* set dynamic list position and resize it */        
        wgui_dynamic_list_move_icontext_menu(0, CAT103_DYNAMIC_LIST_Y);
        wgui_dynamic_list_resize_icontext_menu(UI_device_width, menu_h);
        dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.highlighted_item);
        
        /* set singleline inputbox position */
        singleline_y = CAT103_DYNAMIC_LIST_Y + menu_h + wgui_inputbox_information_bar_height;
        wgui_inputs_sl_move(MMI_singleline_inputbox.x, singleline_y);
        
        /* set information bar position */
        wgui_inputs_setup_input_information( 
                MMI_singleline_inputbox.x,
                MMI_singleline_inputbox.y - wgui_inputbox_information_bar_height,
                MMI_singleline_inputbox.width,
                wgui_inputbox_information_bar_height);
        
        /* clear background and show multiline inputbox, singleline inputbox, and information bar */  
        gdi_draw_solid_rect(
                0,
                CAT103_DYNAMIC_LIST_Y,
                UI_device_width - 1,
                UI_device_height - MMI_BUTTON_BAR_HEIGHT - ime_h - 1,
                GDI_COLOR_TRANSPARENT);        
        
        redraw_dynamic_list();
        //wgui_inputs_sl_redraw();
        wgui_inputs_sl_redraw_information_bar();

        RegisterHighlightHandler(g_wgui_cat103_highlight_handler);

        gdi_layer_unlock_frame_buffer();
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_is_editor_active
 * DESCRIPTION
 *  get editor state
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat103_is_editor_active(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    return g_wgui_cat103_editor_active;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_is_menu_active
 * DESCRIPTION
 *  get menu state
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL wgui_cat103_is_menu_active(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_TRUE;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    if (MMI_fixed_icontext_menuitem.flags & UI_MENUITEM_DISABLE_HIGHLIGHT)
    {
        result = MMI_FALSE;        
	}
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_set_editor_focus_state
 * DESCRIPTION
 *  set editor state
 * PARAMETERS
 *  active    [IN]    editor state
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat103_set_editor_focus_state(MMI_BOOL active)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    g_wgui_cat103_editor_active = active;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_set_menu_focus_state
 * DESCRIPTION
 *  set menu state
 * PARAMETERS
 *  active    [IN]    menu state
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat103_set_menu_focus_state(MMI_BOOL active)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    if (active == MMI_TRUE)
    {
        MMI_fixed_icontext_menuitem.flags &= ~UI_MENUITEM_DISABLE_HIGHLIGHT;
        MMI_fixed_icontext_menuitem.ext_flags &= ~UI_MENUITEM_EXT_DISABLED_SCROLL;
    }
    else
    {
        MMI_fixed_icontext_menuitem.flags |= UI_MENUITEM_DISABLE_HIGHLIGHT;
        MMI_fixed_icontext_menuitem.ext_flags |= UI_MENUITEM_EXT_DISABLED_SCROLL;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_refresh_search_list
 * DESCRIPTION
 *  refresh search list in category103
 * PARAMETERS
 *  input_number    [IN]    editor content
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat103_refresh_search_list(U8 * input_number)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 no_entries = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(g_wgui_cat103_search_function != NULL);
    no_entries = g_wgui_cat103_search_function(input_number);
    init_dynamic_item_buffer(no_entries, dynamic_item_buffer.load_func, dynamic_item_buffer.hint_func, UI_dummy_function);
    MMI_fixed_list_menu.n_items = no_entries;
    dynamic_list_goto_item_no_redraw(0);
    wgui_text_menuitem_reset_scrolling(); /* reset menuitem not to scroll */
    redraw_dynamic_list();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_singleline_inputbox_input_callback
 * DESCRIPTION
 *  editor input callback function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat103_singleline_inputbox_input_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* set menu */
    wgui_cat103_set_menu_focus_state(MMI_FALSE);
    wgui_cat103_set_editor_focus_state(MMI_TRUE); // g_wgui_cat103_editor_active = MMI_TRUE;
    wgui_cat103_refresh_search_list(MMI_singleline_inputbox.text);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_refresh_input_area
 * DESCRIPTION
 *  refresh editor content
 * PARAMETERS
 *  input_buffer               [IN]   input buffer
 *  input_buffer_max_length    [IN]   input buffer max length
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat103_refresh_input_area(U8* input_buffer, S32 input_buffer_max_length)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    if (g_wgui_cat103_from_history == MMI_FALSE)
    {
        gdi_layer_lock_frame_buffer();

        mmi_imm_set_default_input_mode(mmi_imm_get_curr_input_mode());
    #if defined(__MMI_IMC_CAPITAL_SWITCH__)
        mmi_imm_set_writing_language_from_history(mmi_imm_get_current_writing_language());
    #endif  /* defined(__MMI_IMC_CAPITAL_SWITCH__) */
        mmi_imc_disconnect();
        wgui_inputs_sl_disable_up_down_key_register(MMI_TRUE);
        wgui_inputs_sl_setup(
                MMI_singleline_inputbox.x,
                MMI_singleline_inputbox.y,
                MMI_singleline_inputbox.width,
                MMI_singleline_inputbox.height,
                input_buffer,
                input_buffer_max_length,
                MMI_CATEGORY103_ID,
                wgui_singleline_inputbox_RSK_label_string,
                wgui_singleline_inputbox_RSK_label_icon,
                IMM_INPUT_TYPE_URL,
                NULL,
                1);
    #if defined(__MMI_TOUCH_SCREEN__)
        mmi_imc_disable_handwriting();
    #endif /* defined(__MMI_TOUCH_SCREEN__) */
    
        wgui_inputs_setup_input_information(
                0, MMI_singleline_inputbox.y - wgui_inputbox_information_bar_height, 
                UI_device_width, wgui_inputbox_information_bar_height);
    
        MMI_singleline_inputbox.change_callback = wgui_cat103_singleline_inputbox_input_callback;

        wgui_singleline_inputbox_RSK_function = g_wgui_cat103_RSK_function;

        wgui_inputs_sl_redraw_information_bar();
        mmi_imc_redraw_screen_by_state();
        //wgui_inputs_sl_redraw();

        gdi_layer_unlock_frame_buffer();
    }
    else
    {
        g_wgui_cat103_from_history = MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat103_menu_pre_key_handler
 * DESCRIPTION
 *  menu pre-key handler
 * PARAMETERS
 *  key_code    [IN]   key code
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat103_menu_pre_key_handler(MMI_key_code_type key_code)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_FALSE; /* when result = MMI_TRUE, menu will not process key event */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (key_code)
    {
        /* menu key */    
        case KEY_UP_ARROW:
        case KEY_VOL_UP:
            if (wgui_cat103_is_editor_active() == MMI_TRUE)
            {   
                /* set menu inactive */
                wgui_cat103_set_menu_focus_state(MMI_TRUE);
                dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.n_items - 1);
                redraw_dynamic_list();

                wgui_cat103_set_editor_focus_state(MMI_FALSE);
                
                result = MMI_TRUE;
            }            
            else if (wgui_cat103_is_menu_active() == MMI_TRUE)
            {
                if (MMI_fixed_list_menu.highlighted_item == 0) /* highilight on the first item */
                {
                    /* editor do what? */
                    g_wgui_cat103_highlight_handler(CAT103_INVALID_HIGHLIGHT);
                    wgui_cat103_set_editor_focus_state(MMI_TRUE);
                    
                    /* set menu inactive */
                    wgui_cat103_set_menu_focus_state(MMI_FALSE);
                    dynamic_list_goto_item_no_redraw(0);
                    wgui_text_menuitem_reset_scrolling(); /* reset menuitem not to scroll */
                    redraw_dynamic_list();

                    result = MMI_TRUE;
                }
            }
            break;
        case KEY_DOWN_ARROW:
        case KEY_VOL_DOWN: 
            if (wgui_cat103_is_editor_active() == MMI_TRUE)
            {
                /* set menu active*/
                wgui_cat103_set_menu_focus_state(MMI_TRUE);
                dynamic_list_goto_item_no_redraw(0);
                redraw_dynamic_list();

                /* set editor inactive */
                wgui_cat103_set_editor_focus_state(MMI_FALSE);
                
                result = MMI_TRUE;
            }
            else if (wgui_cat103_is_menu_active() == MMI_TRUE)/* highlight on menu */
            {
                if (MMI_fixed_list_menu.highlighted_item == MMI_fixed_list_menu.n_items - 1)
                {
                    /* set editor active */
                    g_wgui_cat103_highlight_handler(CAT103_INVALID_HIGHLIGHT);
                    wgui_cat103_set_editor_focus_state(MMI_TRUE);

                    /* set menu inactive */
                    wgui_cat103_set_menu_focus_state(MMI_FALSE);                    
                    dynamic_list_goto_item_no_redraw(MMI_fixed_list_menu.n_items - 1);
                    wgui_text_menuitem_reset_scrolling(); /* reset menuitem not to scroll */
                    redraw_dynamic_list();

                    result = MMI_TRUE;
                }
            }
            break;
        default:
            break; 
    }
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory103HistorySize
 * DESCRIPTION
 *  get category103 history size
 * PARAMETERS
 *  void
 * RETURNS
 *  S32
 *****************************************************************************/
S32 GetCategory103HistorySize(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (((sizeof(list_menu_category_history) + 3) / 4) * 4 + sizeof(singleline_inputbox_category_history));
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory103History
 * DESCRIPTION
 *  get category103 history
 * PARAMETERS
 *  history_buffer    [IN]   history buffer
 * RETURNS
 *  U8*
 *****************************************************************************/
U8* GetCategory103History(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 s = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    get_list_menu_category_history(MMI_CATEGORY103_ID, history_buffer);
    s = sizeof(list_menu_category_history);
    s = (s + 3) / 4;
    s *= 4;
    wgui_inputs_sl_get_category_history(MMI_CATEGORY103_ID, (U8*) (history_buffer + s));
    return (history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory103Screen
 * DESCRIPTION
 *  exit category103 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory103Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  
    /* enable loop menu */
    MMI_fixed_list_menu.flags |= UI_LIST_MENU_LOOP;

    ClearHighlightHandler();
    reset_fixed_list();
    reset_dynamic_list();
    reset_pop_up_descriptions();
    wgui_inputs_sl_close();
#ifdef __MMI_UI_HINTS_IN_MENUITEM__
    reset_all_force_flags_for_hints();
  #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gui_unblock_list_effect();
  #endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */
#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 

    g_wgui_cat103_search_function = NULL;     
    g_wgui_cat103_resize_and_draw_func = NULL;
    g_wgui_cat103_highlight_handler = NULL;
    g_wgui_cat103_RSK_function = NULL;
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory103Screen
 * DESCRIPTION
 *  category screen for Vodafone WAP auto-complete
 * PARAMETERS
 *  title                   [IN]        Title
 *  title_icon              [IN]        Title icon
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Left softkey icon
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Right softkey icon
 *  number_of_items         [IN]        Number of list items
 *  get_item_func           [IN]        Get menu item function
 *  get_hint_func           [IN]        Get menu hint funtion
 *  search_func             [IN]        Search result function
 *  input_buffer            [IN]        Buffer for input
 *  input_buffer_max_length [IN]        Max length for input
 *  history_buffer          [IN]        Histpry buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory103Screen(
         UI_string_type title,
         PU8 title_icon,
         UI_string_type left_softkey,
         PU8 left_softkey_icon,
         UI_string_type right_softkey,
         PU8 right_softkey_icon,
         S32 number_of_items,    
         S32 highlighted_item,
         GetItemFuncPtr get_item_func,
         GetHintFuncPtr get_hint_func,
         S32(*search_func) (UI_buffer_type),
         U8 *input_buffer,
         S32 input_buffer_max_length,
         U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    U8 h_flag;
    S32 no_entries;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    /* title */
    ShowListCategoryScreen_ext(
                 title, title_icon,
                 left_softkey, left_softkey_icon, 
                 right_softkey, right_softkey_icon);

    /* register search function */
    if (search_func != NULL)
    {
        g_wgui_cat103_search_function = search_func;
    }    
    g_wgui_cat103_resize_and_draw_func = wgui_cat103_resize_and_draw;

    /* dynamic icontext list */
    wgui_dynamic_list_create_icontext_menu(
        number_of_items, 
        get_item_func, 
        get_hint_func, 
        WGUI_LIST_INVALID_HIGHLIGHT,
        MMI_TRUE, 
        UI_dummy_function,
        WGUI_LIST_MENU_DISABLE_SHORTCUT,
        MMI_CATEGORY103_ID,
        NULL);
            
    if (history_buffer != NULL && wgui_cat103_is_editor_active()== MMI_TRUE)  /* from history and focus on editor */
	{
	    wgui_cat103_set_menu_focus_state(MMI_FALSE);
	}

    wgui_fixed_list_register_pre_key_handler(wgui_cat103_menu_pre_key_handler);
       
#ifdef __MMI_TOUCH_SCREEN__
    /* Because the list menu is resized according to virtual keyboard */
    MMI_fixed_list_menu.flags |= UI_LIST_MENU_ALIGN_TO_TOP;
#endif /* __MMI_TOUCH_SCREEN__ */ 
    
    /* disable loop menu */
    MMI_fixed_list_menu.flags &= ~UI_LIST_MENU_LOOP;

    //wgui_dynamic_list_resize_icontext_menu(MAIN_LCD_DEVICE_WIDTH, CAT103_DYNAMIC_LIST_H);
    //wgui_dynamic_list_move_icontext_menu(0, CAT103_DYNAMIC_LIST_Y);
    
    //resize_dynamic_icontext_menuitems_to_list_width();

    ClearHighlightHandler();  /* avoid execute highlight handler when redraw list */

    if (history_buffer == NULL) /* initial */
    {
        /* singleline inputbox */
        mmi_imc_disconnect();
        wgui_inputs_sl_disable_up_down_key_register(MMI_TRUE);
        wgui_inputs_sl_setup(
                    0,
                    CAT103_SINGLE_LINE_INPUTBOX_Y,
                    MAIN_LCD_DEVICE_WIDTH,
                    MMI_SINGLELINE_INPUTBOX_HEIGHT,
                    input_buffer,
                    input_buffer_max_length,
                    MMI_CATEGORY103_ID,
                    right_softkey,
                    right_softkey_icon,
		            IMM_INPUT_TYPE_URL,
                    NULL,
                    1);
        wgui_inputs_setup_input_information(
                    0, MMI_singleline_inputbox.y - wgui_inputbox_information_bar_height, 
                    UI_device_width, wgui_inputbox_information_bar_height);
        
    #if defined(__MMI_TOUCH_SCREEN__)
        mmi_imc_disable_handwriting();
    #endif /* defined(__MMI_TOUCH_SCREEN__) */

        if (highlighted_item >= 0)  /* highlight on list */
        {
            wgui_cat103_set_menu_focus_state(MMI_TRUE);
            wgui_cat103_set_editor_focus_state(MMI_FALSE);
            MMI_fixed_list_menu.highlighted_item = highlighted_item;
            dynamic_list_goto_item_no_redraw(highlighted_item);
        }
        else  /* highlight on editor */
        {
            wgui_cat103_set_menu_focus_state(MMI_FALSE);
            wgui_cat103_set_editor_focus_state(MMI_TRUE);
        }

        if (g_wgui_cat103_search_function)
        {                
            no_entries = g_wgui_cat103_search_function((U8*) MMI_singleline_inputbox.text);
            init_dynamic_item_buffer(no_entries, dynamic_item_buffer.load_func, dynamic_item_buffer.hint_func, UI_dummy_function);
            MMI_fixed_list_menu.n_items = no_entries;
            dynamic_list_goto_item_no_redraw(0);
        }
    }
    else
    {  
        S32 s = sizeof(list_menu_category_history);
        s = (s + 3) / 4;
        s *= 4;

        /* singleline inputbox */
        wgui_inputs_sl_disable_up_down_key_register(MMI_TRUE);
        wgui_inputs_sl_setup(
                    0,
                    CAT103_SINGLE_LINE_INPUTBOX_Y,
                    MAIN_LCD_DEVICE_WIDTH,
                    MMI_SINGLELINE_INPUTBOX_HEIGHT,
                    input_buffer,
                    input_buffer_max_length,
                    MMI_CATEGORY103_ID,
                    right_softkey,
                    right_softkey_icon,
		            IMM_INPUT_TYPE_URL,
                    (U8*) (history_buffer + s),
                    1);
        
        wgui_inputs_setup_input_information(
                    0, MMI_singleline_inputbox.y - wgui_inputbox_information_bar_height, 
                    UI_device_width, wgui_inputbox_information_bar_height);

    #if defined(__MMI_TOUCH_SCREEN__)
        mmi_imc_disable_handwriting();
    #endif /* defined(__MMI_TOUCH_SCREEN__) */

        g_wgui_cat103_from_history = MMI_TRUE;

        if (wgui_cat103_is_editor_active() == MMI_TRUE)  /* highlight on editor */
        {
            wgui_cat103_set_menu_focus_state(MMI_FALSE);
            dynamic_list_goto_item_no_redraw(0);
            if (g_wgui_cat103_search_function)
            {
                no_entries = g_wgui_cat103_search_function((U8*) MMI_singleline_inputbox.text);
                init_dynamic_item_buffer(no_entries, dynamic_item_buffer.load_func, dynamic_item_buffer.hint_func, UI_dummy_function);
                MMI_fixed_list_menu.n_items = no_entries;
                dynamic_list_goto_item_no_redraw(0);
            }
        }
        else /* highlight on menu */
        {
            wgui_cat103_set_menu_focus_state(MMI_TRUE);
            if (highlighted_item >= 0)  /* highlight on list */
			{
                MMI_fixed_list_menu.highlighted_item = highlighted_item;
                dynamic_list_goto_item_no_redraw(highlighted_item);
			}
        }
    }

    RegisterHighlightHandler(g_wgui_cat103_highlight_handler);
    /* singlelin change callback */
    MMI_singleline_inputbox.change_callback = wgui_cat103_singleline_inputbox_input_callback;
    
    gdi_layer_unlock_frame_buffer();
    
    ExitCategoryFunction = ExitCategory103Screen;
    dm_setup_category_functions(dm_redraw_category_screen, GetCategory103History, GetCategory103HistorySize);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY103_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND | DM_SINGLE_LINE_INPUT_BOX_WITH_INFORMATION_BAR;
#ifdef __MMI_TOUCH_SCREEN__
    dm_data.s32flags |= DM_SHOW_VKPAD;
    dm_register_vkpad_callback(wgui_cat103_virtual_keypad_callback);
#endif /* __MMI_TOUCH_SCREEN__ */

    dm_setup_data(&dm_data);


#ifdef __MMI_TOUCH_SCREEN__
    wgui_register_category_screen_control_area_pen_handlers(
            wgui_cat103_controlled_area_pen_down_handler, 
            MMI_PEN_EVENT_DOWN);
    wgui_register_category_screen_control_area_pen_handlers(
            wgui_cat103_controlled_area_pen_up_handler, 
            MMI_PEN_EVENT_UP);
    wgui_register_category_screen_control_area_pen_handlers(
            wgui_cat103_controlled_area_pen_move_handler,
            MMI_PEN_EVENT_MOVE);
    wgui_register_category_screen_control_area_pen_handlers(
            wgui_cat103_controlled_area_pen_long_tap_handler,
            MMI_PEN_EVENT_LONG_TAP);
    wgui_register_category_screen_control_area_pen_handlers(
            wgui_cat103_controlled_area_pen_repeat_handler,
            MMI_PEN_EVENT_REPEAT);    
#endif /* __MMI_TOUCH_SCREEN__ */ 

    dm_redraw_category_screen();
	g_wgui_cat103_from_history = MMI_FALSE;
}
#endif /* __MMI_CAT103_SUPPORT__ */


#ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
/*****************************************************************************
 * FUNCTION
 *  ShowCategory273Screen
 * DESCRIPTION
 *  A category to display thumbnail images in menu item.
 *  * PARAMETERS
 *  *  title                IN Title for the screen
 *  *  title_icon           IN Icon shown with the title
 *  *  left_softkey         IN Left softkey label
 *  *  left_softkey_icon    IN Icon for the Left softkey
 *  *  right_softkey        IN right softkey label
 *  *  right_softkey_icon   IN Icon for the right softkey
 *  *  number_of_items      IN number of items to be displayed
 *  *  get_item_func        IN function pointer to get next displayed items
 *  *  get_display_style_func        IN function pointer to get the display style of next item
 *  *  get_properties_func                          IN      function pointer to get the properties to highlighted menu item
 *  *  highlighted_item     IN index of item to be highlighted
 *  *  history_buffer       IN history buffer
 *  *  disable_data_cache      IN whether caching of dynamic data is disabled
 *  *  flush_data_callback     IN callback function invoked before data is reloaded
 *  *
 *  * RETURNS
 *  *  void
 * PARAMETERS
 *  title                       [IN]        Title for the screen  
 *  title_icon                  [IN]        Icon shown with the title  
 *  left_softkey                [IN]        Left softkey label  
 *  left_softkey_icon           [IN]        Icon for the Left softkey  
 *  right_softkey               [IN]        Right softkey label  
 *  right_softkey_icon          [IN]        Icon for the right softkey  
 *  number_of_items             [IN]        Total count of items
 *  get_item_func               [IN]        Get item function
 *  get_display_style_func      [IN]        Get display style function
 *  get_properties_func         [IN]        Get properties function
 *  highlighted_item            [IN]        Index of highlight item
 *  history_buffer              [IN]        History Buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory273Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        S32 number_of_items,
        GetItemFuncPtr get_item_func,
        wgui_get_display_style get_display_style_func,
        wgui_get_two_line_menu_item_properties get_properties_func,
        S32 highlighted_item,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    wgui_set_pfn_to_get_display_style(get_display_style_func);
    wgui_set_pfn_to_get_current_menu_item_properties(get_properties_func);
    gui_add_cleanup_hook(wgui_two_line_reset_all_pointers); /* 2 line Calvin */
    if (history_buffer)
    {
        wgui_two_line_disable_complete_callback();
    }
    dm_add_title(get_string(title), get_image(title_icon));
    dm_add_softkey(get_string(left_softkey), get_image(left_softkey_icon), get_string(right_softkey), get_image(right_softkey_icon));
    wgui_dynamic_list_create_icontext_menu(
        number_of_items,
        get_item_func,
        NULL,
        highlighted_item,
        MMI_FALSE,
        UI_dummy_function,
        0,
        MMI_CATEGORY273_ID,
        history_buffer);

    gdi_layer_unlock_frame_buffer();
    ExitCategoryFunction = ExitCategory273Screen;
    dm_setup_category_functions(dm_redraw_category_screen, dm_get_category_history, dm_get_category_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY273_ID;
    dm_data.s32flags = 0;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();

}   /* end of ShowCategory273Screen */


/*****************************************************************************
 * FUNCTION
 *  ExitCategory273Screen
 * DESCRIPTION
 *  Exits the Category 273 Screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory273Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ClearHighlightHandler();
    reset_softkeys();
    reset_menu_shortcut_handler();
    reset_dynamic_list();
    reset_pop_up_descriptions();
    dynamic_item_text_align_left = FALSE;
#ifdef __MMI_UI_HINTS_IN_MENUITEM__
    reset_all_force_flags_for_hints();
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gui_unblock_list_effect();
#endif 
#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 
}
#endif /* __MMI_UI_TWO_LINE_MENUITEM_STYLES__ */ 

/* barcode */

extern void register_multiline_inputbox_hilite_keys(void);

#ifdef __MMI_TOUCH_SCREEN__
extern void register_multiline_inputbox_hilite_pen_event_handler(void);
#endif


/*****************************************************************************
 * FUNCTION
 *  ShowCategory228Screen
 * DESCRIPTION
 *  show category 228 screen
 * PARAMETERS
 *  title                   [IN]        Title for the screen  
 *  title_icon              [IN]        Icon shown with the title  
 *  left_softkey            [IN]        Left softkey label  
 *  left_softkey_icon       [IN]        Icon for the Left softkey  
 *  right_softkey           [IN]        Right softkey label  
 *  right_softkey_icon      [IN]        Icon for the right softkey  
 *  buffer                  [IN]        String buffer to set to input box
 *  buffer_size             [IN]        Buffer size of input box
 *  hilite_str_list         [IN]        Hilite string list
 *  hilite_str_number       [IN]        Hilite string number
 *  hilite_cb               [IN]        Hilite callback
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory228Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U8 *buffer,
        S32 buffer_size,
        HILITE_STR hilite_str_list[],
        U16 hilite_str_number,
        void (*hilite_cb) (S32 idx),
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 l;
    U8 h = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    wgui_title_set_menu_shortcut_number(-1);
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    SetupCategoryKeyHandlers();

    MMI_title_string = (UI_string_type) get_string(title);
    MMI_title_icon = (PU8) get_image(title_icon);

    l = gui_strlen((UI_string_type) buffer);
    create_multiline_inputbox_set_buffer((UI_string_type) buffer, buffer_size, l, 0);
    register_multiline_inputbox_viewer_keys();
    register_multiline_inputbox_hilite_keys();
    MMI_multiline_inputbox.hilite_list = hilite_str_list;
    MMI_multiline_inputbox.hilite_str_number = hilite_str_number;
    MMI_multiline_inputbox.current_hilite_idx = 0;

    wgui_inputs_ml_resize(MMI_COMMON_CONTENT_WIDTH, MMI_COMMON_CONTENT_HEIGHT);

#ifdef __MMI_TOUCH_SCREEN__
    register_multiline_inputbox_hilite_pen_event_handler();
#endif 

    MMI_multiline_inputbox.flags |=
        (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE |
         UI_MULTI_LINE_INPUT_BOX_WORD_HIGHLIGHT);
#ifdef __MMI_WALLPAPER_ON_BOTTOM__ 
    dm_get_scr_bg_opacity(&idle_scr_bg_opacity);
    dm_set_scr_bg_opacity((U8)(current_MMI_theme->bg_opacity_low));
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_TRANSPARENT_BACKGROUND;
#endif 
    MMI_multiline_inputbox.hilite_cb = hilite_cb;

    wgui_inputs_ml_show_no_draw();  /* initialize multiline internal data for set text highlight. */
    h = set_multiline_inputbox_category_history(MMI_CATEGORY228_ID, history_buffer);
    if (hilite_str_number != 0)
    {
	    if (h)
	    {
	        gui_multi_line_input_box_go_to_hilite(
	            &MMI_multiline_inputbox,
	            (U16)MMI_multiline_inputbox.current_hilite_idx,
	            MMI_FALSE);
	    }
	    else
	    {
	        gui_multi_line_input_box_go_to_hilite(&MMI_multiline_inputbox, 0, MMI_FALSE);
	    }
    }
    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = ExitCategory74Screen;
    dm_setup_category_functions(dm_redraw_category_screen, dm_get_category_history, dm_get_category_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY228_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();

}


static UI_string_type cat412_display_str = NULL;
static U8 cat412_percentage_value = 0;
static S32 cat412_number_of_items = 0;
static UI_string_type *cat412_list_of_items = NULL;

/*****************************************************************************
 * FUNCTION
 *  ExitCategory412Screen
 * DESCRIPTION
 *  Exit the category412 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void ExitCategory412Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cat412_display_str = NULL;
    cat412_percentage_value = 0;
    cat412_number_of_items = 0;
    cat412_list_of_items = NULL;
}


/*****************************************************************************
 * FUNCTION
 *  Cat412DrawCantent
 * DESCRIPTION
 *  This function will draw the displayed string, percentage value,
 *  progressive bar, and detail information of category 412 
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void Cat412DrawCantent(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x, y, w, h, perc_w, str_w, str_h, img_w, img_h, rect_x, rect_y, rect_w, rect_h, i;
    UI_character_type str_buf[5];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(str_buf, 0, 5 * sizeof(UI_character_type));

    /* set font */
    gui_set_font(&MMI_medium_font);
    gui_set_text_color(*current_MMI_theme->list_normal_text_color);

    /* compute percentage value width */
    {
        U16 temp[] = L"0123456789";
        S32 w, h, pw, w2, w3;

        pw = gui_get_string_width(L"%");
        mmi_fe_measure_string_by_char_num((U8*)temp, 2 /* 99% */, &w2, &h);
        w3 = gui_get_string_width(L"100");
        w = 5 /* gap */ + pw + ((w2 > w3) ? (w2) : (w3));
        perc_w = w;
    }

    gui_push_clip();
    gui_push_text_clip();
    gui_reset_clip();

    /* clear background */
    rect_x = x = MMI_content_x;
    rect_w = w = MMI_content_width;
#if defined(__MMI_SCREEN_ROTATE__)
    if (mmi_frm_is_screen_width_height_swapped())
    {
        rect_y = y = MMI_content_y;
        rect_h = h = MMI_content_height;
    }
    else
#endif /* defined(__MMI_SCREEN_ROTATE__) */
    {
        rect_y = y = MMI_content_y + MMI_MENUITEM_HEIGHT * 2;
        rect_h = h = MMI_content_height - MMI_MENUITEM_HEIGHT * 2;
    }

    gdi_layer_push_clip();
    gdi_layer_set_clip(x, y, x + w - 1, y + h - 1);
    gdi_draw_solid_rect(x, y, x + w - 1, y + h - 1, GDI_COLOR_TRANSPARENT);
    gdi_layer_pop_clip();

    /* draw filename */
    x = (r2lMMIFlag) ? (rect_x + rect_w - 1 - GUI_TEXT_MENUITEM_TEXT_X) : (rect_x + GUI_TEXT_MENUITEM_TEXT_X);
    y = rect_y;
    w = rect_w - perc_w - GUI_TEXT_MENUITEM_TEXT_X * 3 /* gap */;
    h = MMI_MENUITEM_HEIGHT;

    gui_measure_string(cat412_display_str, &str_w, &str_h);
    y += (h - str_h);       /* align bottom */
    gui_print_truncated_text(x, y, w, cat412_display_str);

    /* draw percentage value */
    x = (r2lMMIFlag) ? (rect_x + GUI_TEXT_MENUITEM_TEXT_X) : (rect_x + rect_w - GUI_TEXT_MENUITEM_TEXT_X);
    y = rect_y;
    w = perc_w;
    h = MMI_MENUITEM_HEIGHT;

    if (cat412_percentage_value == 0xFF)
    {
        mmi_ucs2cat((S8*)&str_buf, (S8*)L"--%");
    }
    else
    {
        gui_itoa((S32)cat412_percentage_value, str_buf, 10);
        mmi_ucs2cat((S8*)&str_buf, (S8*)L"%");
    }

    gui_measure_string(str_buf, &str_w, &str_h);
    x += (r2lMMIFlag) ? (str_w) : (0);
    x -= (r2lMMIFlag) ? (0) : (str_w);
    y += (h - str_h);       /* align bottom */
    gui_move_text_cursor(x, y);
    gui_print_text(str_buf);

    /* draw progressive bar */
    x = rect_x;
    y = rect_y + MMI_MENUITEM_HEIGHT;
    w = rect_w;
    h = MMI_MENUITEM_HEIGHT;

    gdi_image_get_dimension((U8*)GetImage(IMG_CAT412_PROG_BAR_BG), &img_w, &img_h);
    x += (w - img_w) >> 1;
    y += (h - img_h) >> 1;

    gdi_layer_push_clip();

    gdi_layer_set_clip(x, y, x + img_w - 1, y + img_h - 1);
    gdi_image_draw(x, y, (U8*)GetImage(IMG_CAT412_PROG_BAR_BG));

    gdi_layer_set_clip(x, y, x + (img_w * cat412_percentage_value / 100) - 1, y + img_h - 1);
    gdi_image_draw(x, y, (U8*)GetImage(IMG_CAT412_PROG_BAR_FULL));

    gdi_layer_pop_clip();

    /* draw detail info */
    x = (r2lMMIFlag) ? (rect_x + rect_w - 1 - GUI_TEXT_MENUITEM_TEXT_X) : (rect_x + GUI_TEXT_MENUITEM_TEXT_X);
    y = rect_y + MMI_MENUITEM_HEIGHT * 2;
    w = rect_w - GUI_TEXT_MENUITEM_TEXT_X;
    h = rect_h - MMI_MENUITEM_HEIGHT * 2;

    for (i = 0 ; i < cat412_number_of_items ; i++)
    {
        if ((y + MMI_MENUITEM_HEIGHT) > (rect_y + rect_h))
        {
            break;
        }

        gui_print_truncated_text(x, y, w, cat412_list_of_items[i]);
        
        y += MMI_MENUITEM_HEIGHT;
    }

    gui_pop_text_clip();
    gui_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  Cat412DrawControlAred
 * DESCRIPTION
 *  Draw Cat412 control area,
 *  including displayed_string, percentage_value, and progressive bar
 * PARAMETERS
 *  coordinate          [IN]    useless, we have pre-defined area
 * RETURNS
 *  void
 *****************************************************************************/
void Cat412DrawControlAred(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    UI_UNUSED_PARAMETER(coordinate);
    Cat412DrawCantent();
}


/* For detail description, please refer to wgui_categories.h */
void Cat412UpdateList(
        UI_string_type display_str,
        U8 percentage_value,
        S32 number_of_items,
        UI_string_type *list_of_items)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cat412_display_str = display_str;
    cat412_percentage_value = percentage_value;
    cat412_number_of_items = number_of_items;
    cat412_list_of_items = list_of_items;
    Cat412DrawCantent();
    gdi_lcd_repaint_all();
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategory412Screen(
        UI_string_type title,
        PU8 title_icon,
        UI_string_type left_softkey,
        PU8 left_softkey_icon,
        UI_string_type right_softkey,
        PU8 right_softkey_icon,
        PU8 progress_image,
        UI_string_type display_str,
        U8 percentage_value,
        S32 number_of_items,
        UI_string_type *list_of_items,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_SCREEN_ROTATE__)
    if (!mmi_frm_is_screen_width_height_swapped())
#endif /* defined(__MMI_SCREEN_ROTATE__) */
    {
        gui_setup_common_layout();
    }

    gdi_layer_lock_frame_buffer();
    
    /* set title */
    dm_add_title(title, title_icon);
    
    /* set softkey */
    dm_add_softkey(left_softkey, left_softkey_icon, right_softkey, right_softkey_icon);

    /* set image */
#if defined(__MMI_SCREEN_ROTATE__)
    if (!mmi_frm_is_screen_width_height_swapped())
#endif /* defined(__MMI_SCREEN_ROTATE__) */
    {
        dm_add_image(progress_image, NULL, NULL);
    }

    /* set information */
    cat412_display_str = display_str;
    cat412_percentage_value = percentage_value;
    cat412_number_of_items = number_of_items;
    cat412_list_of_items = list_of_items;

    gdi_layer_unlock_frame_buffer();

    /* Setup category/draw manager data */
    ExitCategoryFunction = ExitCategory412Screen;
    dm_setup_category_functions(dm_redraw_category_screen, dm_get_category_history, dm_get_category_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY412_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    dm_setup_data(&dm_data);
    dm_register_category_controlled_callback(Cat412DrawControlAred);
    dm_redraw_category_screen();
}


/*****************************************************************************
 * FUNCTION
 *  Cat402ScrolTextBg
 * DESCRIPTION
 *  scrol text background
 * PARAMETERS
 *  x1      [IN]        Start x
 *  y1      [IN]        Start y
 *  x2      [IN]        End x
 *  y2      [IN]        End y
 * RETURNS
 *  void
 *****************************************************************************/
static void Cat402ScrolTextBg(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_WHITE);
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory402Screen
 * DESCRIPTION
 *  exit category 402
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void ExitCategory402Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    Cat402PercentageBarId = 0;
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategory402Screen(
    U8 *title,
    U16 title_icon,
    U16 left_softkey,
    U16 left_softkey_icon,
    U16 right_softkey,
    U16 right_softkey_icon,
    U8 *string,
    U16 percentage,
    U8 *progress_string)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    color text_color = gui_color(0, 0, 0);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    dm_add_title((UI_string_type) title, get_image(title_icon));
    wgui_title_set_menu_shortcut_number(-1);
    
    dm_add_softkey(
        get_string(left_softkey), 
        get_image(left_softkey_icon), 
        get_string(right_softkey), 
        get_image(right_softkey_icon));

    dm_add_scroll_text((UI_string_type) string, NULL, Cat402ScrolTextBg, text_color, text_color);
    Cat402PercentageBarId = dm_add_percentage_bar(
                                percentage,
                                progress_string,
                                /* Vogins Start */
                                #ifdef __VRE30_AM__
                                UI_COLOR_BLUE,
                                #else
                                UI_COLOR_RED,
                                #endif
                                /* Vogins End */
                                IMG_PERCENTAGE_BAR_BG_IMAGE,
                                IMG_PERCENTAGE_BAR_LEFT_IMAGE,
                                IMG_PERCENTAGE_BAR_RIGHT_IMAGE);

    ExitCategoryFunction = ExitCategory402Screen;
    dm_setup_category_functions(dm_redraw_category_screen, dm_get_category_history, dm_get_category_history_size);
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND_COLOR;
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY402_ID;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}


/* For detail description, please refer to wgui_categories.h */
void UpdateCategory402Value(U16 value, U8 *string)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    dm_update_percentage_bar_value(Cat402PercentageBarId, value, string);
    dm_redraw_percentage_bar(Cat402PercentageBarId);
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory501Screen
 * DESCRIPTION
 *  Displays the category501 screen
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the Left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  message_str             [IN]        Message string
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory501Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U8* message_str,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ShowCategory7Screen(
        title,
        title_icon,
        left_softkey,
        left_softkey_icon,
        right_softkey,
        right_softkey_icon,
        message_str,
        history_buffer);
}   /* end of ShowCategory501Screen */


#ifdef __MMI_BROWSER_2__
static GDI_HANDLE mmi_cat431_title_handle = 0;
static GDI_HANDLE mmi_cat431_bottom_handle = 0;
#ifdef __MMI_TOUCH_SCREEN__
static cat431_pen_handler mmi_cat431_pen_event_handler = NULL;
static MMI_BOOL cat431_is_fullscreen = MMI_FALSE;
#endif /* __MMI_TOUCH_SCREEN__ */


/* For detail description, please refer to wgui_categories.h */
void Cat431GetScreenInfo(MMI_BOOL isFullScreen, U32 *x, U32 *y, U32 *w, U32 *h, GDI_HANDLE *title_layer, GDI_HANDLE *bottom_layer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!isFullScreen)
    {
#if defined(__MMI_SCREEN_ROTATE__)
        if(mmi_frm_is_screen_width_height_swapped())
        {
            *x = CAT431_ROTATE_X;
            *y = CAT431_ROTATE_Y;
            *w = CAT431_ROTATE_W;
            *h = CAT431_ROTATE_H;
        }
        else
#endif /* defined(__MMI_SCREEN_ROTATE__) */
        {
            *x = CAT431_X;
            *y = CAT431_Y;
            *w = CAT431_W;
            *h = CAT431_H;
        }
    }
    else
    {
#if defined(__MMI_SCREEN_ROTATE__)
        if(mmi_frm_is_screen_width_height_swapped())
        {
            *x = CAT431_ROTATE_FULLSCREEN_X;
            *y = CAT431_ROTATE_FULLSCREEN_Y;
            *w = CAT431_ROTATE_FULLSCREEN_W;
            *h = CAT431_ROTATE_FULLSCREEN_H;
        }
        else
#endif /* defined(__MMI_SCREEN_ROTATE__) */
        {
            *x = CAT431_FULLSCREEN_X;
            *y = CAT431_FULLSCREEN_Y;
            *w = CAT431_FULLSCREEN_W;
            *h = CAT431_FULLSCREEN_H;
        }
    }
    
    *title_layer = mmi_cat431_title_handle;
    *bottom_layer = mmi_cat431_bottom_handle;
}


#ifdef __MMI_TOUCH_SCREEN__
/*****************************************************************************
 * FUNCTION
 *  Cat431CheckPenEvent
 * DESCRIPTION
 *  Check whether the pen event is available
 * PARAMETERS
 *  point                       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL Cat431CheckPenEvent(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	S32 x, y, w, h;
	GDI_HANDLE dummy_layer1, dummy_layer2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    Cat431GetScreenInfo(cat431_is_fullscreen, (U32*)&x, (U32*)&y, (U32*)&w, (U32*)&h, &dummy_layer1, &dummy_layer2);

    if ((point.x < x) || (point.y < y) || (point.x >= x + w) || (point.y >= y + h))
    {
        return MMI_FALSE;
    }
	else
	{
	    return MMI_TRUE;
	}
}


/*****************************************************************************
 * FUNCTION
 *  Cat431ControlAreaPenDownHandler
 * DESCRIPTION
 *  Pen down events handler function for category431 control area.
 * PARAMETERS
 *  point                       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL Cat431ControlAreaPenDownHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (Cat431CheckPenEvent(point) == MMI_FALSE)
    {
        return MMI_FALSE;
    }
    
    if (mmi_cat431_pen_event_handler != NULL)
    {
        return mmi_cat431_pen_event_handler(point, MMI_PEN_EVENT_DOWN);
    }
    else
    {
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  Cat431ControlAreaPenUpHandler
 * DESCRIPTION
 *  Pen up events handler function for category431 control area.
 * PARAMETERS
 *  point                       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL Cat431ControlAreaPenUpHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (Cat431CheckPenEvent(point) == MMI_FALSE)
    {
        return MMI_FALSE;
    }
    
    if (mmi_cat431_pen_event_handler != NULL)
    {
        return mmi_cat431_pen_event_handler(point, MMI_PEN_EVENT_UP);
    }
    else
    {
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  Cat431ControlAreaPenLongTapHandler
 * DESCRIPTION
 *  Pen long-tap events handler function for category431 control area.
 * PARAMETERS
 *  point                       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL Cat431ControlAreaPenLongTapHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (Cat431CheckPenEvent(point) == MMI_FALSE)
    {
        return MMI_FALSE;
    }
    
    if (mmi_cat431_pen_event_handler != NULL)
    {
        return mmi_cat431_pen_event_handler(point, MMI_PEN_EVENT_LONG_TAP);
    }
    else
    {
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  Cat431ControlAreaPenRepeatHandler
 * DESCRIPTION
 *  Pen repeat events handler function for category431 control area.
 * PARAMETERS
 *  point                       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL Cat431ControlAreaPenRepeatHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (Cat431CheckPenEvent(point) == MMI_FALSE)
    {
        return MMI_FALSE;
    }
    
    if (mmi_cat431_pen_event_handler != NULL)
    {
        return mmi_cat431_pen_event_handler(point, MMI_PEN_EVENT_REPEAT);
    }
    else
    {
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  Cat431ControlAreaPenMoveHandler
 * DESCRIPTION
 *  Pen move events handler function for category431 control area.
 * PARAMETERS
 *  point                       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL Cat431ControlAreaPenMoveHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (Cat431CheckPenEvent(point) == MMI_FALSE)
    {
        return MMI_FALSE;
    }
    
    if (mmi_cat431_pen_event_handler != NULL)
    {
        return mmi_cat431_pen_event_handler(point, MMI_PEN_EVENT_MOVE);
    }
    else
    {
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  Cat431ControlAreaPenAbortHandler
 * DESCRIPTION
 *  Pen abort events handler function for category431 control area.
 * PARAMETERS
 *  point                       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL Cat431ControlAreaPenAbortHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (Cat431CheckPenEvent(point) == MMI_FALSE)
    {
        return MMI_FALSE;
    }
    
    if (mmi_cat431_pen_event_handler != NULL)
    {
        return mmi_cat431_pen_event_handler(point, MMI_PEN_EVENT_ABORT);
    }
    else
    {
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 * Cat431ControlAreaPenDoubleClickHandler 
 * DESCRIPTION
 *  Pen double-click events handler function for category431 control area.
 *  TODO: this function should be triggered from WGUI instead of MMI framework directly.
 * PARAMETERS
 *  point                       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL Cat431ControlAreaPenDoubleClickHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (Cat431CheckPenEvent(point) == MMI_FALSE)
    {
        return MMI_FALSE;
    }
    
    if (mmi_cat431_pen_event_handler != NULL)
    {
        return mmi_cat431_pen_event_handler(point, MMI_PEN_EVENT_DOUBLE_CLICK);
    }
    else
    {
        return MMI_FALSE;
    }
}
#endif /* __MMI_TOUCH_SCREEN__ */ 


#define WGUI_CAT431_PROGRESS_BAR_BG_COLOR       gui_color(135, 135, 135)
#define WGUI_CAT431_PROGRESS_BAR_BORDER_COLOR   gui_color(255, 255, 255)
#define WGUI_CAT431_PROGRESS_BAR_BAR_COLOR      gui_color(253, 143, 0)
#define WGUI_CAT431_PROGRESS_BAR_TEXT_COLOR     gui_color(255, 255, 255)

/* For detail description, please refer to wgui_categories.h */
void wgui_cat431_display_progressive_bar(S32 percentage, S8* display_string)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2, str_w, str_h, bar_x1, bar_y1, bar_x2, bar_y2;
    UI_font_type font;
    UI_character_type str_buf[5] = {0};
    UI_string_type str_buf_p;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((g_dm_data.s32CatId != MMI_CATEGORY431_ID) &&
#if defined(__MMI_SCREEN_ROTATE__)
        (g_dm_data.s32CatId != MMI_CATEGORY431_ROTATE_ID) &&
        (g_dm_data.s32CatId != MMI_CATEGORY431_ROTATE_FULL_ID) &&
#endif /* defined(__MMI_SCREEN_ROTATE__) */
        (g_dm_data.s32CatId != MMI_CATEGORY431_FULL_ID))
    {
        return;
    }

    gdi_layer_lock_frame_buffer();

#if defined(MMI_SHOW_STATUS_ICON_IN_TITLE)
    if (g_dm_data.s32CatId == MMI_CATEGORY431_ID)
    {
        wgui_status_icon_integrated_enable(MMI_FALSE);
        get_status_icon_bar_clip(0, &x1, &y1, &x2, &y2);
    }
    else
#endif /* defined(MMI_SHOW_STATUS_ICON_IN_TITLE) */
    {
        x1 = MMI_title_x;
        y1 = MMI_title_y;
        x2 = MMI_title_x + MMI_title_width - 1;
        y2 = MMI_title_y + MMI_title_height - 1;
    }
    wgui_stop_title_animation();
    font = &MMI_medium_font;

    /* set string */
    gui_set_font(font);
    gui_set_text_color(WGUI_CAT431_PROGRESS_BAR_TEXT_COLOR);
    gui_itoa(percentage, (UI_string_type)&str_buf, 10);
    mmi_ucs2cat((S8*)&str_buf, (S8*)L"%");
    str_buf_p = (display_string) ? ((UI_string_type)display_string) : ((UI_string_type)str_buf);
    gui_measure_string((UI_string_type)str_buf_p, &str_w, &str_h);

    gdi_layer_push_clip();
    gdi_layer_set_clip(x1, y1, x2, y2);

    /* clear background */
    gui_fill_rectangle(x1, y1, x2, y2, WGUI_CAT431_PROGRESS_BAR_BG_COLOR);

    /* calculate bar position */
    {
        /* string upper gap: 3, string lower gap: 2 */
        S32 gap = ((str_h + 5) < (y2 - y1 + 1)) ? (((y2 - y1 + 1) - (str_h + 5)) >> 1) : (0);

        bar_x1 = x1 + gap;
        bar_y1 = y1 + gap;
        bar_x2 = x2 - gap;
        bar_y2 = y2 - gap;
    }

    /* draw percentage */
    {
        S32 w = (bar_x2 - bar_x1 + 1) * percentage / 100;

        gui_fill_rectangle(bar_x1, bar_y1, bar_x1 + w - 1, bar_y2, WGUI_CAT431_PROGRESS_BAR_BAR_COLOR);
    }

    /* draw rect */
    gui_draw_rectangle(bar_x1, bar_y1, bar_x2, bar_y2, WGUI_CAT431_PROGRESS_BAR_BORDER_COLOR);

    /* show string */
    {
        S32 str_x, str_y = bar_y1 + 3;

        str_x = bar_x1 + (((bar_x2 - bar_x1 + 1) - str_w) >> 1);
        str_x += (r2lMMIFlag) ? (str_w - 1) : (0);
        gui_move_text_cursor(str_x, str_y);
        gui_print_text(str_buf_p);
    }

    gdi_layer_pop_clip();

    gdi_layer_unlock_frame_buffer();
    gdi_lcd_repaint_all();
}


/* For detail description, please refer to wgui_categories.h */
void wgui_cat431_disable_progressive_bar(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((g_dm_data.s32CatId != MMI_CATEGORY431_ID) &&
#if defined(__MMI_SCREEN_ROTATE__)
        (g_dm_data.s32CatId != MMI_CATEGORY431_ROTATE_ID) &&
        (g_dm_data.s32CatId != MMI_CATEGORY431_ROTATE_FULL_ID) &&
#endif /* defined(__MMI_SCREEN_ROTATE__) */
        (g_dm_data.s32CatId != MMI_CATEGORY431_FULL_ID))
    {
        return;
    }

    gdi_layer_lock_frame_buffer();

#if defined(MMI_SHOW_STATUS_ICON_IN_TITLE)
    if (g_dm_data.s32CatId == MMI_CATEGORY431_ID)
    {
        wgui_status_icon_integrated_enable(MMI_TRUE);
    }
#endif /* defined(MMI_SHOW_STATUS_ICON_IN_TITLE) */
    draw_title();

    gdi_layer_unlock_frame_buffer();
    gdi_lcd_repaint_all();
}


#if defined(__MMI_SCREEN_ROTATE__)
/*****************************************************************************
 * FUNCTION
 *  wgui_cat431_hide_lsk_cb
 * DESCRIPTION
 *  hide LSK
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat431_hide_lsk_cb(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x, y, w, h;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    x = MMI_softkeys[MMI_LEFT_SOFTKEY].x;
    y = MMI_softkeys[MMI_LEFT_SOFTKEY].y;
    w = MMI_softkeys[MMI_LEFT_SOFTKEY].width;
    h = MMI_softkeys[MMI_LEFT_SOFTKEY].height;

    gdi_layer_push_clip();
    gdi_layer_set_clip(x, y, x + w - 1, y + h - 1);
    gdi_image_draw_id(0, y, IMG_SCREEN_ROTATE_BOTTOM_BG);
    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat431_hide_rsk_cb
 * DESCRIPTION
 *  hide LSK
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat431_hide_rsk_cb(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x, y, w, h;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    x = MMI_softkeys[MMI_RIGHT_SOFTKEY].x;
    y = MMI_softkeys[MMI_RIGHT_SOFTKEY].y;
    w = MMI_softkeys[MMI_RIGHT_SOFTKEY].width;
    h = MMI_softkeys[MMI_RIGHT_SOFTKEY].height;

    gdi_layer_push_clip();
    gdi_layer_set_clip(x, y, x + w - 1, y + h - 1);
    gdi_image_draw_id(0, y, IMG_SCREEN_ROTATE_TOP_BG);
    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat431_hide_title_cb
 * DESCRIPTION
 *  hide title
 * PARAMETERS
 *  x   [IN]
 *  y   [IN]
 *  w   [IN]
 *  h   [IN]
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat431_hide_title_cb(S32 x, S32 y, S32 w, S32 h)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gdi_layer_set_clip(x, y, x + w - 1, y + h - 1);
    gdi_image_draw_id(0, y, IMG_SCREEN_ROTATE_TOP_BG);
    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat431_hide_status_cb
 * DESCRIPTION
 *  hide title
 * PARAMETERS
 *  x   [IN]
 *  y   [IN]
 *  w   [IN]
 *  h   [IN]
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat431_hide_status_cb(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    get_status_icon_bar_clip(0, &x1, &y1, &x2, &y2);
    gui_push_clip();
    gui_set_clip(x1, y1, x2, y2);
    gdi_image_draw_id(0, y1, IMG_SCREEN_ROTATE_BOTTOM_BG);
    gui_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat431_ctrl_area2_cb
 * DESCRIPTION
 *  hide title
 * PARAMETERS
 *  coordinate  [IN]    unused
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat431_ctrl_area2_cb(dm_coordinates* coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_cat431_hide_lsk_cb();
    wgui_cat431_hide_rsk_cb();

    show_softkey(MMI_LEFT_SOFTKEY);
    show_softkey(MMI_RIGHT_SOFTKEY);
}
#endif /* defined(__MMI_SCREEN_ROTATE__) */


/* For detail description, please refer to wgui_categories.h */
void ShowCategory431Screen(
        U8* title,
        U16 title_icon1,
        U16 title_icon2,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        cat431_pen_handler pen_handler,
        MMI_BOOL isFullScreen,
        S32 percentage,
        S8* display_string,
        U8* history_buffer)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* set full screen */
#ifdef __MMI_TOUCH_SCREEN__
    cat431_is_fullscreen = isFullScreen;
#endif /* __MMI_TOUCH_SCREEN__ */

    /* lock GDI frame buffer */
    gdi_layer_lock_frame_buffer();

    /* do not show shortcut */
    wgui_title_set_menu_shortcut_number(-1);

    if(!isFullScreen)
    {  
        /* change soft keys' label & icon */
        change_left_softkey(left_softkey, left_softkey_icon);
        change_right_softkey(right_softkey, right_softkey_icon);
    }
    else
    {
        DisableLeftSoftkey(STRING_ID_NULL, IMAGE_ID_NULL);
        DisableRightSoftkey(STRING_ID_NULL, IMAGE_ID_NULL);
        disable_softkey_background();

#if defined(MMI_SHOW_STATUS_ICON_IN_TITLE)
        /* Because status icon is default enabled in integrated title,
           disable it manually. */
        wgui_status_icon_integrated_enable(MMI_FALSE);
#endif /* defined(MMI_SHOW_STATUS_ICON_IN_TITLE) */
    }
    
    /* clear soft keys' handle function */
    SetupCategoryKeyHandlers();

    /* set title */
    wgui_title_change(title_icon1, title_icon2, title, WGUI_TITLE_CHANGE_ICON | WGUI_TITLE_CHANGE_ICON2 | WGUI_TITLE_CHANGE_TEXT);

    /* set flags */
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND_COLOR;
#if defined(__MMI_SCREEN_ROTATE__)
    dm_data.s32flags |= (mmi_frm_is_screen_width_height_swapped()) ? (DM_LEFT_ALIGN_TITLE | DM_SPECIFIC_HIDE_STATUS_BAR) : (0);
#endif /* defined(__MMI_SCREEN_ROTATE__) */
    dm_data.s32flags |= (percentage >= 0) ? (DM_NO_BLT) : (0);

    /* un-lock GDI frame buffer */
    gdi_layer_unlock_frame_buffer();

    /* set exit category screen function */
    ExitCategoryFunction = ExitCategory431Screen;

    /* register control area callback */
    dm_register_category_controlled_callback(NULL);

#if defined(__MMI_SCREEN_ROTATE__)
    /* set status icon bar */
    if(mmi_frm_is_screen_width_height_swapped())
    {
        /* title */
        wgui_title_register_hide_callback(wgui_cat431_hide_title_cb);

        if (!isFullScreen)
        {
            /* statuc icon */
            move_status_icons(0,
                CAT431_ROTATE_X, (CAT431_ROTATE_Y + CAT431_ROTATE_H),
                (CAT431_ROTATE_X + CAT431_ROTATE_W - MMI_ROTATED_SOFTKEY_WIDTH - 1), (MMI_ROTATED_LCD_HEIGHT - 1));

            wgui_status_icon_set_rotate_flag_for_wap();
            register_hide_status_icon_bar(0, wgui_cat431_hide_status_cb);

            /* softkey */
            register_hide_softkey(wgui_cat431_hide_lsk_cb, MMI_LEFT_SOFTKEY);
            register_hide_softkey(wgui_cat431_hide_rsk_cb, MMI_RIGHT_SOFTKEY);

            /* hook: force to redraw the softkey background */
            dm_register_category_controlled2_callback(wgui_cat431_ctrl_area2_cb);
        }
    }
#endif /* defined(__MMI_SCREEN_ROTATE__) */

    /* set draw manager attributes */
    dm_setup_category_functions(dm_redraw_category_screen, dummy_get_history, dummy_get_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    if(!isFullScreen)
    {
        dm_data.s32CatId = MMI_CATEGORY431_ID;
#if defined(__MMI_SCREEN_ROTATE__)
        dm_data.s32CatId = (mmi_frm_is_screen_width_height_swapped()) ? (MMI_CATEGORY431_ROTATE_ID) : (dm_data.s32CatId);
#endif /* defined(__MMI_SCREEN_ROTATE__) */
    }
    else
    {
        dm_data.s32CatId = MMI_CATEGORY431_FULL_ID;
#if defined(__MMI_SCREEN_ROTATE__)
        dm_data.s32CatId = (mmi_frm_is_screen_width_height_swapped()) ? (MMI_CATEGORY431_ROTATE_FULL_ID) : (dm_data.s32CatId);
#endif /* defined(__MMI_SCREEN_ROTATE__) */
    }
    dm_setup_data(&dm_data);

#if defined(__MMI_SCREEN_ROTATE__)
    if (mmi_frm_is_screen_width_height_swapped() && !isFullScreen)
    {   /* hook: dm_setup_data will clost statuc icon while rotated */
        show_status_icon_bar(0);
    }
#endif /* defined(__MMI_SCREEN_ROTATE__) */

    /* register pen event handler */
#ifdef __MMI_TOUCH_SCREEN__
    mmi_cat431_pen_event_handler = pen_handler,
    wgui_register_category_screen_control_area_pen_handlers(
            Cat431ControlAreaPenDownHandler,
            MMI_PEN_EVENT_DOWN);
    wgui_register_category_screen_control_area_pen_handlers(
            Cat431ControlAreaPenUpHandler,
            MMI_PEN_EVENT_UP);
    wgui_register_category_screen_control_area_pen_handlers(
            Cat431ControlAreaPenLongTapHandler,
            MMI_PEN_EVENT_LONG_TAP);
    wgui_register_category_screen_control_area_pen_handlers(
            Cat431ControlAreaPenRepeatHandler,
            MMI_PEN_EVENT_REPEAT);
    wgui_register_category_screen_control_area_pen_handlers(
            Cat431ControlAreaPenMoveHandler,
            MMI_PEN_EVENT_MOVE);
    wgui_register_category_screen_control_area_pen_handlers(
            Cat431ControlAreaPenAbortHandler,
            MMI_PEN_EVENT_ABORT);
    mmi_pen_register_double_click_handler((mmi_pen_hdlr)Cat431ControlAreaPenDoubleClickHandler);
#endif /* __MMI_TOUCH_SCREEN__ */

    /* re-draw category screen */
    dm_redraw_category_screen();

    if (percentage >= 0)
    {
        wgui_cat431_display_progressive_bar(percentage, display_string);
    }

    gdi_layer_set_active(GDI_LAYER_MAIN_BASE_LAYER_HANDLE);
    MMI_ASSERT((mmi_cat431_title_handle == GDI_NULL_HANDLE) && (mmi_cat431_bottom_handle == GDI_NULL_HANDLE));

    {   /* set title layer */
        S32 ptr_offset = 0;
        S32 x, y, w, h;
        U8 bpp;
        U8 *buf_ptr;
        
        x = 0;
        y = 0;
        w = (isFullScreen) ? (CAT431_FULLSCREEN_W) : (CAT431_W);
        h = (isFullScreen) ? (CAT431_FULLSCREEN_Y) : (CAT431_Y);

#if defined(__MMI_SCREEN_ROTATE__)
		if (mmi_frm_is_screen_width_height_swapped())
		{
			w = CAT431_ROTATE_FULLSCREEN_W;
			h = MMI_ROTATED_SOFTKEY_HEIGHT;
		}
#endif /* defined(__MMI_SCREEN_ROTATE__) */

        bpp = gdi_layer_get_bit_per_pixel();
        gdi_layer_get_buffer_ptr(&buf_ptr);
        gdi_layer_create_cf_using_outside_memory(
                (gdi_color_format)(bpp >> 3),
                x, y, w, h,
                &mmi_cat431_title_handle,
                buf_ptr + ptr_offset,
                ((w*h*bpp + 7) >> 3));

        MMI_ASSERT(mmi_cat431_title_handle);
        gdi_layer_push_and_set_active(mmi_cat431_title_handle);
        gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
        gdi_layer_pop_and_restore_active();
    }

    {   /* set bottom layer */
        if (!isFullScreen)
        {
            S32 ptr_offset = 0;
            S32 x, y, w, h;
            U8 bpp;
            U8 *buf_ptr;

#if defined(__MMI_SCREEN_ROTATE__)
			if (mmi_frm_is_screen_width_height_swapped())
			{
				x = CAT431_ROTATE_X;
				y = CAT431_ROTATE_Y + CAT431_ROTATE_H;
				w = CAT431_ROTATE_FULLSCREEN_W;
				h = MMI_ROTATED_SOFTKEY_HEIGHT;
			}
			else
#endif /* defined(__MMI_SCREEN_ROTATE__) */
			{
				x = 0;
				y = MAIN_LCD_DEVICE_HEIGHT - MMI_BUTTON_BAR_HEIGHT;
				w = MAIN_LCD_DEVICE_WIDTH;
				h = MMI_BUTTON_BAR_HEIGHT;
			}

            bpp = gdi_layer_get_bit_per_pixel();
            gdi_layer_get_buffer_ptr(&buf_ptr);
            ptr_offset = (w*y*bpp + 7) >> 3;
            gdi_layer_create_cf_using_outside_memory(
                    (gdi_color_format)(bpp >> 3),
                    x, y, w, h,
                    &mmi_cat431_bottom_handle,
                    buf_ptr + ptr_offset,
                    ((w*h*bpp + 7) >> 3));

            MMI_ASSERT(mmi_cat431_bottom_handle);
            gdi_layer_push_and_set_active(mmi_cat431_bottom_handle);
            gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
            gdi_layer_pop_and_restore_active();
        }
        else
        {
            mmi_cat431_bottom_handle = GDI_ERROR_HANDLE;
        }
    }
}


/* For detail description, please refer to wgui_categories.h */
void ExitCategory431Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_cat431_title_handle > 0)
    {
        gdi_layer_free(mmi_cat431_title_handle);
        mmi_cat431_title_handle = 0;
    }
    if (mmi_cat431_bottom_handle > 0)
    {
        gdi_layer_free(mmi_cat431_bottom_handle);
        mmi_cat431_bottom_handle = 0;
    }

#ifdef __MMI_TOUCH_SCREEN__
    mmi_cat431_pen_event_handler = NULL;
#endif /* __MMI_TOUCH_SCREEN__ */

    /* in order to flatten the rendering page (in base layer memory) with blue characters,
     * disable the source key */
    gdi_layer_push_and_set_active(GDI_LAYER_MAIN_BASE_LAYER_HANDLE);
    gdi_layer_set_source_key(FALSE, GDI_COLOR_BLUE);
    gdi_layer_pop_and_restore_active();

    reset_softkeys();
    enable_softkey_background();

#if defined(__MMI_SCREEN_ROTATE__)
    wgui_status_icon_reset_rotate_flag_for_wap();
#endif /* defined(__MMI_SCREEN_ROTATE__) */
}
#endif /* __MMI_BROWSER_2__ */

#ifdef __MMI_ECOMPASS__

extern void flat_triangle_fill(polygon_vertex vertices[], color c);
extern void polygon_draw(polygon_vertex vertices[], S32 n_vertices, color c);

#if defined(__MMI_MAINLCD_320X480__) 
    #define WGUI_CAT126_COMPASS_RADIUS 90
    #define WGUI_CAT126_COMPASS_CENTER_X 159
    #define WGUI_CAT126_COMPASS_CENTER_Y 232
#elif defined(__MMI_MAINLCD_240X400__) 
    #define WGUI_CAT126_COMPASS_RADIUS 60
    #define WGUI_CAT126_COMPASS_CENTER_X 120
    #define WGUI_CAT126_COMPASS_CENTER_Y 185
#elif defined(__MMI_MAINLCD_240X320__) 
    #define WGUI_CAT126_COMPASS_RADIUS 60
    #define WGUI_CAT126_COMPASS_CENTER_X 118
    #define WGUI_CAT126_COMPASS_CENTER_Y 155
#elif defined(__MMI_MAINLCD_320X240__) 
    #define WGUI_CAT126_COMPASS_RADIUS 45
    #define WGUI_CAT126_COMPASS_CENTER_X 157
    #define WGUI_CAT126_COMPASS_CENTER_Y 114
#elif defined(__MMI_MAINLCD_176X220__) 
    #define WGUI_CAT126_COMPASS_RADIUS 42
    #define WGUI_CAT126_COMPASS_CENTER_X 86
    #define WGUI_CAT126_COMPASS_CENTER_Y 111
#elif defined(__MMI_MAINLCD_128X160__) 
    #define WGUI_CAT126_COMPASS_RADIUS 30
    #define WGUI_CAT126_COMPASS_CENTER_X 66
    #define WGUI_CAT126_COMPASS_CENTER_Y 74
#else
    #define WGUI_CAT126_COMPASS_RADIUS 43
    #define WGUI_CAT126_COMPASS_CENTER_X 88
    #define WGUI_CAT126_COMPASS_CENTER_Y 117
#endif

static U16 g_cat126_compass_north_degree;
static U16 g_cat126_compass_mecca_degree;
static UI_string_type g_cat126_compass_info;
static const float32 g_wgui_compass_sine_table[] = 
{
    (float32) 0.0, (float32) 0.01745240, (float32) 0.03489949, (float32) 0.05233595,
        (float32) 0.06975647,
        (float32) 0.08715574, (float32) 0.10452846, (float32) 0.12186934,
    (float32) 0.13917310, (float32) 0.15643446, (float32) 0.17364817, (float32) 0.19080899,
        (float32) 0.20791169,
        (float32) 0.22495105, (float32) 0.24192189, (float32)0.25881904, /* 15*/
    (float32) 0.27563735, (float32) 0.29237170, (float32) 0.30901699, (float32) 0.32556815, (float32) 0.34202014,
        (float32) 0.35836794,
        (float32)0.37460659, (float32)0.39073112,
    (float32) 0.40673664, (float32) 0.42261826, (float32) 0.43837114, (float32) 0.45399049, (float32) 0.46947156,
        (float32) 0.48480962,
        (float32)0.5, /*30*/(float32)0.51503807,
    (float32) 0.52991926, (float32) 0.54463903, (float32) 0.55919290, (float32) 0.57357643, (float32) 0.58778525,
        (float32) 0.60181502,
        (float32)0.61566147, (float32)0.62932039,
    (float32) 0.64278760, (float32) 0.656059023, (float32) 0.66913060, (float32) 0.68199836, (float32) 0.69465837,
        (float32) 0.70710678, /*45*/
        (float32) 0.71933980, (float32) 0.73135370,
    (float32) 0.74314482, (float32) 0.75470958, (float32) 0.76604444, (float32) 0.77714596,
        (float32) 0.78801075,
        (float32) 0.79863551, (float32) 0.80901699, (float32) 0.81915204,
    (float32) 0.82903757, (float32) 0.83867056, (float32) 0.84804809, (float32) 0.85716730,(float32) 0.86602540,/*60*/
    (float32) 0.87461970, (float32) 0.88294759, (float32) 0.89100652, (float32) 0.89879404, (float32) 0.90630778,
    (float32) 0.91354545, (float32) 0.92059485, (float32) 0.92718385, (float32) 0.93358042, (float32) 0.93969262,
    (float32) 0.94551857, (float32) 0.95105651, (float32) 0.95630475, (float32) 0.96126169, (float32) 0.96592582,/*75*/
    (float32) 0.97029572, (float32) 0.97437006, (float32) 0.97814760, (float32) 0.98162718, (float32) 0.98480775,
    (float32) 0.98768834, (float32) 0.99026806, (float32) 0.99254615, (float32) 0.99452189, (float32) 0.99619469,
    (float32) 0.99756405, (float32) 0.99862953, (float32) 0.99939082, (float32) 0.99984769, (float32) 1.0
};


/*****************************************************************************
 * FUNCTION
 *  wgui_cat126_map_value
 * DESCRIPTION
 *  map float32 to s32. if > 0.5, value will add 1.
 * PARAMETERS
 *  float32*		[IN]
 *  float32*        [IN]
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat126_map_value(float32 *x1, float32 *y1)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	float32 x, y;
	s32 sx, sy;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/	
	x = *x1;
	y = *y1;
	sx = (s32)x;
	sy = (s32)y;

	if((x - sx) > 0.5)
	{
		*x1 = sx + 1;
	}
	else if((x - sx) < -0.5)
	{
		*x1 = sx - 1;
	}
	
	if((y - sy) > 0.5)
	{
		*y1 = sy + 1;
	}
	else if((y - sy) < -0.5)
	{
		*y1 = sy - 1;
	}
}
/*****************************************************************************
 * FUNCTION
 *  wgui_cat126_rotate_compass_arrow
 * DESCRIPTION
 *  compute offset from center point.
 * PARAMETERS
 *  vertices    [IN]
 *  degree      [IN]
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat126_rotate_compass_arrow(polygon_vertex vertices[], U16 degree)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    float32 cosa, sina, x, y, x1, y1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_DBG_ASSERT(vertices != NULL);
    MMI_DBG_ASSERT(degree<=360);
    switch (degree/90)
        {
            case 0: /* 0<= degree < 90 */
            {
                cosa = g_wgui_compass_sine_table[90 - degree];
                sina = g_wgui_compass_sine_table[degree];
                break;
            }
            case 1: /* 90 <= degree < 180 */
            {
                cosa = -g_wgui_compass_sine_table[degree - 90];
                sina = g_wgui_compass_sine_table[180 - degree];
                break;
            }
            case 2: /* 180 <= degree < 270 */
            {
                cosa = -g_wgui_compass_sine_table[270 - degree];
                sina = -g_wgui_compass_sine_table[degree - 180];
                break;
            }
            case 3: /* 270 <= degree < 360 */
            {
                cosa = g_wgui_compass_sine_table[degree - 270];
                sina = -g_wgui_compass_sine_table[360 - degree];
                break;
            }
			case 4: /* degree = 360 */
			{
				cosa = 1;
				sina = 0;
				break;
			}
            default:
            {
                cosa = 0;
                sina = 0;
                break;
            }

        }    

    x1 = (float32)vertices[0].x;
    y1 = (float32)vertices[0].y;
    x = (x1 * cosa - y1 * sina);
    y = (x1 * sina + y1 * cosa);
	wgui_cat126_map_value(&x, &y);
	vertices[0].x = (s32)x;
	vertices[0].y = (s32)y;

    x1 = (float32)vertices[1].x;
    y1 = (float32)vertices[1].y;
    x = (x1 * cosa - y1 * sina);
    y = (x1 * sina + y1 * cosa);
	wgui_cat126_map_value(&x, &y);
	vertices[1].x = (s32)x;
	vertices[1].y = (s32)y;

    x = (float32)vertices[2].x;
    y = (float32)vertices[2].y;
    vertices[2].x = (S32) (x * cosa - y * sina);
    vertices[2].y = (S32) (x * sina + y * cosa);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat126_draw_arrow
 * DESCRIPTION
 *  draw compass arrow
 *	      .v[2]
 *       /  \ 
 *      /    \ 
 *     v[0]   v[1]
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat126_draw_arrow(void)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	color c = {153, 0, 0, 100};
	color c1 = {51, 51, 51, 100};
	color c2 = {0, 80, 160, 100};
	s32 x1 = WGUI_CAT126_COMPASS_CENTER_X;
	s32 y1 = WGUI_CAT126_COMPASS_CENTER_Y;
	s32 radius = WGUI_CAT126_COMPASS_RADIUS;
    s32 x = 0, y = 0;

    U8 i = 0;
    U16 north_degree, sourth_degree, mecca_degree;

#if defined(__MMI_MAINLCD_320X480__) || defined (__MMI_MAINLCD_240X400__)
	polygon_vertex v[3] = { {-5, 0},
    {+5, 0},
    {0, 0},
    };

	polygon_vertex v1[3] = { {-5, 0},
    {+5, 0},
    {0, 0},
    };
    
	polygon_vertex v2[3] = { {-5, 0},
    {+5, 0},
    {0, 0},
    };
    
    polygon_vertex v3[3] = { {-5, 0},
    {+5, 0},
    {0, 0},
    };
#elif defined(__MMI_MAINLCD_240X320__) || defined (__MMI_MAINLCD_320X240__)
	polygon_vertex v[3] = { {-4, 0},
    {+4, 0},
    {0, 0},
    };

	polygon_vertex v1[3] = { {-4, 0},
    {+4, 0},
    {0, 0},
    };
    
	polygon_vertex v2[3] = { {-4, 0},
    {+4, 0},
    {0, 0},
    };
    
    polygon_vertex v3[3] = { {-4, 0},
    {+4, 0},
    {0, 0},
    };
#else
	polygon_vertex v[3] = { {-3, 0},
    {+3, 0},
    {0, 0},
    };

	polygon_vertex v1[3] = { {-3, 0},
    {+3, 0},
    {0, 0},
    };
    
	polygon_vertex v2[3] = { {-4, 0},
    {+4, 0},
    {0, 0},
    };
    
    polygon_vertex v3[3] = { {-4, 0},
    {+4, 0},
    {0, 0},
    };
#endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

	v[2].y =  -radius;
	v1[2].y = -radius;
    v2[2].y = -radius;
#if defined(__MMI_MAINLCD_176X220__) || defined (__MMI_MAINLCD_128X160__)
    v3[2].y = -(radius*3)/4;    /* temp for Mecca's arrow */
#else
    v3[2].y = -(radius*4)/5;    /* temp for Mecca's arrow */
#endif
    north_degree = g_cat126_compass_north_degree;
    mecca_degree = g_cat126_compass_mecca_degree;
    sourth_degree = (north_degree > 180)? (north_degree - 180):(180 + north_degree);
	wgui_cat126_rotate_compass_arrow(v, north_degree);
	wgui_cat126_rotate_compass_arrow(v1, sourth_degree);
    wgui_cat126_rotate_compass_arrow(v2, mecca_degree);
	wgui_cat126_rotate_compass_arrow(v3, mecca_degree);
    for(i = 0; i < 3; i++)
    {
        v[i].x += x1;
        v[i].y += y1;

        v1[i].x += x1;
        v1[i].y += y1;
    }

/* compute v2 point array for tip arrow of Mecca by setting v3[2] as center point*/
    v2[2].x += x1;
    v2[2].y += y1;

    v3[2].x += x1;
    v3[2].y += y1;

    v2[0].x += v3[2].x;
    v2[0].y += v3[2].y;

    v2[1].x += v3[2].x;
    v2[1].y += v3[2].y;
/* clear background */
    x = x1 - radius;
    y = y1 - radius;
    gdi_draw_solid_rect(x, y, x + 2*radius, y + 2*radius, GDI_COLOR_TRANSPARENT);
    
/* draw mecca arrow */
    gdi_draw_antialiasing_line(x1, y1, v2[2].x, v2[2].y, gdi_act_color_from_rgb(255, c2.r, c2.g, c2.b));
	gdi_draw_antialiasing_line(v2[0].x, v2[0].y, v2[2].x, v2[2].y, gdi_act_color_from_rgb(255, c2.r, c2.g, c2.b));
	gdi_draw_antialiasing_line(v2[1].x, v2[1].y, v2[2].x, v2[2].y, gdi_act_color_from_rgb(255, c2.r, c2.g, c2.b));
/* draw compass arrow */
    flat_triangle_fill(v, c);   /* north arrow */
    gdi_draw_antialiasing_line(v[2].x, v[2].y, v[0].x, v[0].y, gdi_act_color_from_rgb(255, c.r, c.g, c.b));
    gdi_draw_antialiasing_line(v[2].x, v[2].y, v[1].x, v[1].y, gdi_act_color_from_rgb(255, c.r, c.g, c.b));

    flat_triangle_fill(v1, c1); /* sourth arrow */
    gdi_draw_antialiasing_line(v1[2].x, v1[2].y, v1[0].x, v1[0].y, gdi_act_color_from_rgb(255, c1.r, c1.g, c1.b));
    gdi_draw_antialiasing_line(v1[2].x, v1[2].y, v1[1].x, v1[1].y, gdi_act_color_from_rgb(255, c1.r, c1.g, c1.b));
}

/*****************************************************************************
 * FUNCTION
 *  wgui_cat126_draw_controlled_area
 * DESCRIPTION
 *  draw controlled area
 * PARAMETERS
 *  coordinate		[IN]	Unused
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat126_draw_controlled_area(dm_coordinates *coordinate)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    GDI_HANDLE handle0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(coordinate);
    handle0 = dm_get_layer_handle(0);

    gdi_layer_push_and_set_active(handle0);
    gdi_image_draw_id(MMI_COMMON_CONTENT_X, MMI_COMMON_CONTENT_Y,IMG_ID_COMPASS_BACKGROUND);
    gdi_layer_pop_and_restore_active();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat126_draw_info
 * DESCRIPTION
 *  draw arrow in compass
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat126_draw_info(void)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 y1, y2;
    S32 sw, sh, w;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	y1 = MAIN_LCD_DEVICE_HEIGHT - MMI_BUTTON_BAR_HEIGHT - MMI_MENUITEM_HEIGHT - 1;
	y2 = MAIN_LCD_DEVICE_HEIGHT - MMI_BUTTON_BAR_HEIGHT - 1;
    w = UI_device_width - 2;    /* left and right gap is 1*/
    gdi_layer_lock_frame_buffer();
    gui_push_clip();
    gui_set_clip(0, y1, UI_device_width, y2);
    gdi_draw_solid_rect(0,  y1, UI_device_width, y2, GDI_COLOR_TRANSPARENT); 
	gui_set_text_color(*current_MMI_theme->title_text_color);
    Get_StringWidthHeight((U8*)g_cat126_compass_info, &sw, &sh);
    if (sw > w)
    {
         if (r2lMMIFlag)
         {
             gui_print_truncated_text(
                 UI_device_width - 2,
                 y1,
                 w,
                 g_cat126_compass_info);
         }
         else
         {
             gui_print_truncated_text(1, y1, w, g_cat126_compass_info);
         }
     }
     else
     {
         if (r2lMMIFlag)
         {
             gui_move_text_cursor((w + sw)>>1, y1);
         }
         else
         {
             gui_move_text_cursor(1 + (w - sw)>>1, y1);
         }
         gui_print_text(g_cat126_compass_info);
     }
     gui_pop_clip();
     gdi_layer_unlock_frame_buffer();

}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat126_draw_controlled2_area
 * DESCRIPTION
 *  draw controlled2 area
 * PARAMETERS
 *  coordinate	[IN]	Unused
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat126_draw_controlled2_area(dm_coordinates *coordinate)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(coordinate);
	wgui_cat126_draw_arrow();
    wgui_cat126_draw_info();
}

/*****************************************************************************
 * FUNCTION
 *  wgui_cat126_exit_screen
 * DESCRIPTION
 *  Exits the category126 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat126_exit_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    gui_hide_animations();

}
/*****************************************************************************
 * FUNCTION
 *  ShowCategory126Screen
 * DESCRIPTION
 *  Displays the category126 screen
 * PARAMETERS
 *  mecca_string            [IN]        Mecca direction string
 *  mecca_icon              [IN]        Mecca icon
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the right softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the left softkey
 *  info_message            [IN]        String to display singal strength
 *	north_degree			[IN]		Degree of North from NS axis.
 *  mecca_degree			[IN]		Degree of Mecca from NS axis.
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory126Screen(
        UI_string_type mecca_string,
        PU8 mecca_icon,
        UI_string_type left_softkey,
        PU8 left_softkey_icon,
        UI_string_type right_softkey,
        PU8 right_softkey_icon,
        UI_string_type info_message,
        U16 north_degree, 
        U16 mecca_degree,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

	dm_add_title(mecca_string, mecca_icon);
	dm_add_softkey(left_softkey, left_softkey_icon, right_softkey, right_softkey_icon);
    g_cat126_compass_info = info_message;
    g_cat126_compass_north_degree = north_degree;
    g_cat126_compass_mecca_degree = mecca_degree;
	
    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = wgui_cat126_exit_screen;
    dm_setup_category_functions(dm_redraw_category_screen, dummy_get_history, dummy_get_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY126_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND | DM_SCR_BG_NO_CACHE;
    dm_setup_data(&dm_data);
	dm_register_category_controlled_callback(wgui_cat126_draw_controlled_area);
    dm_register_category_controlled2_callback(wgui_cat126_draw_controlled2_area);
    dm_redraw_category_screen();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat126_update_degree
 * DESCRIPTION
 *  update north and Mecca degree, and Mecca string in title.
 * PARAMETERS
 *  north_degree		[IN]	Degree of North from NS axis.
 *  mecca_degree		[IN]	Degree of Mecca from NS axis.
 *	mecca_string		[IN]	String of Mecca in title.
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat126_update_degree(U16 north_degree, U16 mecca_degree, UI_string_type mecca_string)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_cat126_compass_north_degree = north_degree;
    g_cat126_compass_mecca_degree = mecca_degree;
    gdi_layer_lock_frame_buffer();
    wgui_cat126_draw_arrow();

    ChangeTitleString((U8*)mecca_string);
    draw_title();
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
}

/*****************************************************************************
 * FUNCTION
 *  wgui_cat126_update_info
 * DESCRIPTION
 *  display singal strength info message on bottom.
 * PARAMETERS
 *  info_message	[IN]	info message on bottom.
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat126_update_info(UI_string_type info_message)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	g_cat126_compass_info = info_message;
    wgui_cat126_draw_info();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);

}
#endif /* __MMI_ECOMPASS__ */

static void (*wgui_cat6001_app_draw) (S16 x, S16 y, S16 width, S16 height ) = NULL;
static U32 g_wgui_cat6001_config_info;
#ifdef __MMI_TOUCH_SCREEN__
static MMI_BOOL (*wgui_cat6001_ctrl_area_pen_hdlr)(mmi_pen_event_type_enum pen_event, mmi_pen_point_struct point) = NULL;


/*****************************************************************************
 * FUNCTION
 *  wgui_cat6001_is_in_control_area
 * DESCRIPTION
 *  Check the point is in control area or not.
 * PARAMETERS
 *  mmi_pen_point_struct  point [IN]  The coordinates of the pen events. 
 * RETURNS VALUES
 *  MMI_TRUE                          In control area.
 *  MMI_FALSE                         Not in control area.
 *****************************************************************************/
static MMI_BOOL wgui_cat6001_is_in_control_area(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_coordinates control_area_coordinates;
    S32 cat_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(g_wgui_cat6001_config_info & WGUI_CAT6001_NEED_SCR_BG)
    {
        cat_id = MMI_CAT6001_ID_WITH_SCR_BG;
    }
    else
    {
        cat_id = MMI_CAT6001_ID;
    }

    /* initialize control area */
    dm_get_control_coordinates_from_category(
        -1,
        cat_id,
        DM_CATEGORY_CONTROLLED_AREA,
        -1,
        &control_area_coordinates);

    /* reset by config infomation */
    if (!(g_wgui_cat6001_config_info & WGUI_CAT6001_NEED_TITLE))
    {
        control_area_coordinates.s16Y -= MMI_title_height;
        control_area_coordinates.s16Height += MMI_title_height;
    }
    if (!(g_wgui_cat6001_config_info & WGUI_CAT6001_NEED_STATUS_ICON))
    {
        control_area_coordinates.s16Y -= MMI_status_bar_height;
        control_area_coordinates.s16Height += MMI_status_bar_height;
    }    
    if (!(g_wgui_cat6001_config_info & WGUI_CAT6001_NEED_SOFTKEY))
    {
        control_area_coordinates.s16Height += MMI_softkey_height;
    }

    /* check the point whether within the control area */
    if ((point.x < control_area_coordinates.s16X) ||
        (point.x > control_area_coordinates.s16X + control_area_coordinates.s16Width) ||
        (point.y < control_area_coordinates.s16Y) ||
        (point.y > control_area_coordinates.s16Y + control_area_coordinates.s16Height))
    {
        return MMI_FALSE;
    }
    else
    {
        return MMI_TRUE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat6001_pen_down_hdlr
 * DESCRIPTION
 *  Execute application pen down handler.
 * PARAMETERS
 *  mmi_pen_point_struct  point [IN]  The coordinates of the pen events. 
 * RETURNS VALUES
 *  MMI_TRUE                          Success.
 *  MMI_FALSE                         Fail.
 *****************************************************************************/
MMI_BOOL wgui_cat6001_pen_down_hdlr(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_FW_TRC_G3_CAT, MMI_WGUI_TRC_CAT6001_PEN_POINT, point.x, point.y);

    if ((wgui_cat6001_is_in_control_area(point)) && (wgui_cat6001_ctrl_area_pen_hdlr != NULL))
    {
        return wgui_cat6001_ctrl_area_pen_hdlr(MMI_PEN_EVENT_DOWN, point);
    }
    else
    {
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat6001_pen_up_hdlr
 * DESCRIPTION
 *  Execute application pen up handler.
 * PARAMETERS
 *  mmi_pen_point_struct  point [IN]  The coordinates of the pen events. 
 * RETURNS VALUES
 *  MMI_TRUE                          Success.
 *  MMI_FALSE                         Fail.
 *****************************************************************************/
MMI_BOOL wgui_cat6001_pen_up_hdlr(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_FW_TRC_G3_CAT, MMI_WGUI_TRC_CAT6001_PEN_POINT, point.x, point.y);

    if ((wgui_cat6001_is_in_control_area(point)) && (wgui_cat6001_ctrl_area_pen_hdlr != NULL))
    {
        return wgui_cat6001_ctrl_area_pen_hdlr(MMI_PEN_EVENT_UP, point);
    }
    else
    {
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat6001_pen_move_hdlr
 * DESCRIPTION
 *  Execute application pen move handler.
 * PARAMETERS
 *  mmi_pen_point_struct  point [IN]  The coordinates of the pen events. 
 * RETURNS VALUES
 *  MMI_TRUE                          Success.
 *  MMI_FALSE                         Fail.
 *****************************************************************************/
MMI_BOOL wgui_cat6001_pen_move_hdlr(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_FW_TRC_G3_CAT, MMI_WGUI_TRC_CAT6001_PEN_POINT, point.x, point.y);

    if ((wgui_cat6001_is_in_control_area(point)) && (wgui_cat6001_ctrl_area_pen_hdlr != NULL))
    {
        return wgui_cat6001_ctrl_area_pen_hdlr(MMI_PEN_EVENT_MOVE, point);
    }
    else
    {
        return MMI_FALSE;
    }
}
#endif /* __MMI_TOUCH_SCREEN__ */


/*****************************************************************************
 * FUNCTION
 *  wgui_cat6001_draw_ctrl_area
 * DESCRIPTION
 *  Draw Cat6001 control area,
 * 
 * PARAMETERS
 *  coordinate          [IN]    useless, we have pre-defined area
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat6001_draw_ctrl_area(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 x = coordinate->s16X, y = coordinate->s16Y, w = coordinate->s16Width, h = coordinate->s16Height;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* confirm the control area */
    if(!(g_wgui_cat6001_config_info & WGUI_CAT6001_NEED_TITLE))
    {
        y -= MMI_title_height;
        h += MMI_title_height;
    }

    if(!(g_wgui_cat6001_config_info & WGUI_CAT6001_NEED_STATUS_ICON))
    {
        y -= MMI_status_bar_height;
        h += MMI_status_bar_height;
        /* if need titile but without status icon bar, the title will be moved up. */
        if(g_wgui_cat6001_config_info & WGUI_CAT6001_NEED_TITLE)
        {
            wgui_title_move(x, y - MMI_title_height);
            draw_title();
        }
    }    

    if(!(g_wgui_cat6001_config_info & WGUI_CAT6001_NEED_SOFTKEY))
    {
        h += MMI_softkey_height;
    }

    MMI_TRACE(MMI_FW_TRC_G3_CAT, MMI_WGUI_TRC_CAT6001_CONTROL_AREA, y, h);

    /* draw by application */
    if (wgui_cat6001_app_draw != NULL)
    {
        wgui_cat6001_app_draw(x, y, w, h);
    }
}


/* For detail description, please refer to wgui_categories.h */
void wgui_cat6001_show(
        UI_string_type title_string,
        PU8 title_icon,
        UI_string_type left_softkey_string,
        PU8 left_softkey_icon,
        UI_string_type right_softkey_string,
        PU8 right_softkey_icon,
        U32 config_info,
        void (*display_call_back) (S16 x, S16 y, S16 width, S16 height),
        MMI_BOOL (*pen_all_call_back)(mmi_pen_event_type_enum pen_event, mmi_pen_point_struct point))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* setup title bar and softkey bar */
    dm_add_title(title_string,title_icon);
    dm_add_softkey(left_softkey_string, left_softkey_icon, right_softkey_string, right_softkey_icon);
    wgui_title_set_menu_shortcut_number(-1);

    /* for confirm control area */
    g_wgui_cat6001_config_info = config_info;

    dm_setup_category_functions(dm_redraw_category_screen, dm_get_category_history, dm_get_category_history_size);
    ExitCategoryFunction = UI_dummy_function;

    if(config_info & WGUI_CAT6001_NEED_SCR_BG)
    {
        dm_data.s32CatId = MMI_CAT6001_ID_WITH_SCR_BG; /* include "DM_SCR_BG" */
        dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    }
    else
    {
        dm_data.s32CatId = MMI_CAT6001_ID;
        dm_data.s32flags = DM_NO_FLAGS;
    }
    dm_data.s32ScrId = GetActiveScreenId();
    
    /* don't need the title bar */
    if(!(config_info & WGUI_CAT6001_NEED_TITLE))
    {
        dm_data.s32flags |= DM_NO_TITLE;
    }
    /* don't need the status icon bar */
    if(!(config_info & WGUI_CAT6001_NEED_STATUS_ICON))
    {
        /* title will be moved up, so it will be displayed by control area callback */
        dm_data.s32flags |= DM_NO_STATUS_BAR | DM_NO_TITLE;
    }
    /* don't need the softkey bar */
    if(!(config_info & WGUI_CAT6001_NEED_SOFTKEY))
    {
        dm_data.s32flags |= DM_NO_SOFTKEY;
    }
    dm_setup_data(&dm_data);
    
    wgui_cat6001_app_draw = display_call_back;
    dm_register_category_controlled_callback(wgui_cat6001_draw_ctrl_area);
#if defined(__MMI_TOUCH_SCREEN__)
    wgui_cat6001_ctrl_area_pen_hdlr = pen_all_call_back;
    wgui_register_category_screen_control_area_pen_handlers(wgui_cat6001_pen_down_hdlr, MMI_PEN_EVENT_DOWN);
    wgui_register_category_screen_control_area_pen_handlers(wgui_cat6001_pen_up_hdlr, MMI_PEN_EVENT_UP);
    wgui_register_category_screen_control_area_pen_handlers(wgui_cat6001_pen_move_hdlr, MMI_PEN_EVENT_MOVE);
#endif /* defined(__MMI_TOUCH_SCREEN__) */

    dm_redraw_category_screen();
}
static void wgui_cat9002_draw_ctrl_area(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_draw_solid_rect(0, 0, UI_device_width - 1, UI_device_height - 1, GDI_COLOR_BLACK);
}

static void wgui_cat9002_exit(void)
{
    
}

/*****************************************************************************
 * FUNCTION
 *  wgui_cat9002_show
 * DESCRIPTION
 *  Show category9 screen (usb animated icon)
 * PARAMETERS
 *  image_icon_1        [IN]       usb text image
 *  image_icon_2         [IN]        usb animation image
 *  history_buffer          [IN]        History buffer
 *  flags                   [IN]   reserved
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat9002_show(U16 image_icon_1, U16 image_icon_2, U8 *history_buffer, U8 flags)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    entry_full_screen();
    UI_UNUSED_PARAMETER(history_buffer);
    gdi_layer_lock_frame_buffer();
    wgui_title_set_menu_shortcut_number(-1);
    clear_category_screen_key_handlers();
    clear_left_softkey();
    clear_right_softkey();
    
    dm_add_image(get_image(image_icon_1), NULL, NULL);
    dm_add_image(get_image(image_icon_2), NULL, NULL);


    gdi_layer_unlock_frame_buffer();
    ExitCategoryFunction = wgui_cat9002_exit;
    dm_setup_category_functions(dm_redraw_category_screen, dm_get_category_history, dm_get_category_history_size);
    dm_register_category_controlled_callback(wgui_cat9002_draw_ctrl_area);

    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CAT9002_ID;
    dm_data.s32flags = 0;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}
